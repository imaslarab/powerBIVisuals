{"visual":{"name":"powerBIVisuals","displayName":"PowerBIVisuals","guid":"PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG","visualClassName":"Visual","version":"1.0.0","description":"","supportUrl":"","gitHubUrl":""},"apiVersion":"1.2.0","author":{"name":"","email":""},"assets":{"icon":"assets/icon.png"},"externalJS":[],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Category Data","name":"category","kind":"Grouping"},{"displayName":"Title Data","name":"title","kind":"Grouping"},{"displayName":"Measure Data","name":"measure","kind":"Measure"}],"dataViewMappings":[{"conditions":[{"category":{"max":1},"title":{"max":1},"measure":{"max":1}}],"categorical":{"categories":{"select":[{"for":{"in":"category"}},{"for":{"in":"title"}}],"dataReductionAlgorithm":{"top":{}}},"values":{"select":[{"bind":{"to":"measure"}}]}}}]},"content":{"js":"var powerbi;\n(function (powerbi) {\n    var extensibility;\n    (function (extensibility) {\n        var visual;\n        (function (visual) {\n            var PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B;\n            (function (PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B) {\n                ;\n                function visualTransform(options, host) {\n                    var dataViews = options.dataViews;\n                    var viewModel = {\n                        dataPoints: [],\n                        minDate: null,\n                        maxDate: null\n                    };\n                    if (!dataViews\n                        || !dataViews[0]\n                        || !dataViews[0].categorical\n                        || !dataViews[0].categorical.categories\n                        || !dataViews[0].categorical.categories[0].source\n                        || !dataViews[0].categorical.values)\n                        return viewModel;\n                    var categorical = dataViews[0].categorical;\n                    var category = categorical.categories[0];\n                    var title = categorical.categories[1];\n                    var dataValue = categorical.values[0];\n                    var timelineDataPoints = [];\n                    for (var i in category.values) {\n                        timelineDataPoints.push({\n                            title: String(title.values[i]),\n                            date: new Date(category.values[i].toString())\n                        });\n                    }\n                    var dates = timelineDataPoints.map(function (obj) {\n                        return obj.date;\n                    });\n                    var maxdate = new Date(Math.max.apply(null, dates));\n                    var mindate = new Date(Math.min.apply(null, dates));\n                    return {\n                        dataPoints: timelineDataPoints,\n                        maxDate: maxdate,\n                        minDate: mindate\n                    };\n                }\n                var Visual = (function () {\n                    function Visual(options) {\n                        this.host = options.host;\n                        this.container = d3.select(options.element).append('div').style(\"background\", \"pink\").classed('container', true);\n                        this.slider = d3.select('div.container').append('div').classed('slider', true);\n                        this.svg = d3.select('div.slider').append('svg');\n                        this.g = this.svg.append('g');\n                    }\n                    Visual.prototype.update = function (options) {\n                        var viewModel = visualTransform(options, this.host);\n                        var timelineData = viewModel.dataPoints;\n                        var width = options.viewport.width, height = options.viewport.height, padding = 100;\n                        d3.select('div.container').attr({\n                            width: width\n                        });\n                        d3.select('div.slider').attr({\n                            width: width\n                        });\n                        this.svg.attr({\n                            width: width\n                        });\n                        var maxdate = viewModel.maxDate;\n                        var mindate = viewModel.minDate;\n                        // var mindate = new Date(2016,10,1),\n                        //     maxdate = new Date(2016,11,31);\n                        var xScale = d3.time.scale()\n                            .domain([mindate, maxdate])\n                            .range([padding, width - padding]);\n                        var xAxis = d3.svg.axis()\n                            .orient(\"bottom\")\n                            .scale(xScale)\n                            .ticks(d3.time.month)\n                            .tickFormat(d3.time.format(\"%b %y\"))\n                            .tickSize(16, 2);\n                        this.svg.selectAll(\"*\").remove();\n                        this.svg.append(\"g\")\n                            .attr(\"class\", \"xaxis\")\n                            .attr(\"transform\", \"translate(0,\" + (height - padding) + \")\")\n                            .call(xAxis);\n                        this.svg.selectAll(\".xaxis text\")\n                            .attr(\"transform\", function (d) {\n                            return \"translate(\" + this.getBBox().height * -2 + \",\" + this.getBBox().height + \")rotate(-45)\";\n                        });\n                        var lines = this.svg.selectAll('.line').data(timelineData);\n                        lines.enter()\n                            .append('line')\n                            .classed('line', true);\n                        lines.style(\"stroke\", \"black\");\n                        lines.attr({\n                            x1: function (d) { return xScale(d.date); },\n                            y1: height - padding,\n                            x2: function (d) { return xScale(d.date); },\n                            y2: height - padding - 100\n                        });\n                    };\n                    Visual.prototype.destroy = function () {\n                        //TODO: Perform any cleanup tasks here\n                    };\n                    return Visual;\n                }());\n                PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B.Visual = Visual;\n            })(PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B = visual.PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B || (visual.PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B = {}));\n        })(visual = extensibility.visual || (extensibility.visual = {}));\n    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));\n})(powerbi || (powerbi = {}));\n!function () {\n    function n(n) { return n && (n.ownerDocument || n.document || n).documentElement; }\n    function t(n) { return n && (n.ownerDocument && n.ownerDocument.defaultView || n.document && n || n.defaultView); }\n    function e(n, t) { return t > n ? -1 : n > t ? 1 : n >= t ? 0 : 0 / 0; }\n    function r(n) { return null === n ? 0 / 0 : +n; }\n    function u(n) { return !isNaN(n); }\n    function i(n) { return { left: function (t, e, r, u) { for (arguments.length < 3 && (r = 0), arguments.length < 4 && (u = t.length); u > r;) {\n            var i = r + u >>> 1;\n            n(t[i], e) < 0 ? r = i + 1 : u = i;\n        } return r; }, right: function (t, e, r, u) { for (arguments.length < 3 && (r = 0), arguments.length < 4 && (u = t.length); u > r;) {\n            var i = r + u >>> 1;\n            n(t[i], e) > 0 ? u = i : r = i + 1;\n        } return r; } }; }\n    function o(n) { return n.length; }\n    function a(n) { for (var t = 1; n * t % 1;)\n        t *= 10; return t; }\n    function c(n, t) { for (var e in t)\n        Object.defineProperty(n.prototype, e, { value: t[e], enumerable: !1 }); }\n    function l() { this._ = Object.create(null); }\n    function s(n) { return (n += \"\") === pa || n[0] === va ? va + n : n; }\n    function f(n) { return (n += \"\")[0] === va ? n.slice(1) : n; }\n    function h(n) { return s(n) in this._; }\n    function g(n) { return (n = s(n)) in this._ && delete this._[n]; }\n    function p() { var n = []; for (var t in this._)\n        n.push(f(t)); return n; }\n    function v() { var n = 0; for (var t in this._)\n        ++n; return n; }\n    function d() { for (var n in this._)\n        return !1; return !0; }\n    function m() { this._ = Object.create(null); }\n    function y(n) { return n; }\n    function M(n, t, e) { return function () { var r = e.apply(t, arguments); return r === t ? n : r; }; }\n    function x(n, t) { if (t in n)\n        return t; t = t.charAt(0).toUpperCase() + t.slice(1); for (var e = 0, r = da.length; r > e; ++e) {\n        var u = da[e] + t;\n        if (u in n)\n            return u;\n    } }\n    function b() { }\n    function _() { }\n    function w(n) { function t() { for (var t, r = e, u = -1, i = r.length; ++u < i;)\n        (t = r[u].on) && t.apply(this, arguments); return n; } var e = [], r = new l; return t.on = function (t, u) { var i, o = r.get(t); return arguments.length < 2 ? o && o.on : (o && (o.on = null, e = e.slice(0, i = e.indexOf(o)).concat(e.slice(i + 1)), r.remove(t)), u && e.push(r.set(t, { on: u })), n); }, t; }\n    function S() { ta.event.preventDefault(); }\n    function k() { for (var n, t = ta.event; n = t.sourceEvent;)\n        t = n; return t; }\n    function E(n) { for (var t = new _, e = 0, r = arguments.length; ++e < r;)\n        t[arguments[e]] = w(t); return t.of = function (e, r) { return function (u) { try {\n        var i = u.sourceEvent = ta.event;\n        u.target = n, ta.event = u, t[u.type].apply(e, r);\n    }\n    finally {\n        ta.event = i;\n    } }; }, t; }\n    function A(n) { return ya(n, _a), n; }\n    function N(n) { return \"function\" == typeof n ? n : function () { return Ma(n, this); }; }\n    function C(n) { return \"function\" == typeof n ? n : function () { return xa(n, this); }; }\n    function z(n, t) { function e() { this.removeAttribute(n); } function r() { this.removeAttributeNS(n.space, n.local); } function u() { this.setAttribute(n, t); } function i() { this.setAttributeNS(n.space, n.local, t); } function o() { var e = t.apply(this, arguments); null == e ? this.removeAttribute(n) : this.setAttribute(n, e); } function a() { var e = t.apply(this, arguments); null == e ? this.removeAttributeNS(n.space, n.local) : this.setAttributeNS(n.space, n.local, e); } return n = ta.ns.qualify(n), null == t ? n.local ? r : e : \"function\" == typeof t ? n.local ? a : o : n.local ? i : u; }\n    function q(n) { return n.trim().replace(/\\s+/g, \" \"); }\n    function L(n) { return new RegExp(\"(?:^|\\\\s+)\" + ta.requote(n) + \"(?:\\\\s+|$)\", \"g\"); }\n    function T(n) { return (n + \"\").trim().split(/^|\\s+/); }\n    function R(n, t) { function e() { for (var e = -1; ++e < u;)\n        n[e](this, t); } function r() { for (var e = -1, r = t.apply(this, arguments); ++e < u;)\n        n[e](this, r); } n = T(n).map(D); var u = n.length; return \"function\" == typeof t ? r : e; }\n    function D(n) { var t = L(n); return function (e, r) { if (u = e.classList)\n        return r ? u.add(n) : u.remove(n); var u = e.getAttribute(\"class\") || \"\"; r ? (t.lastIndex = 0, t.test(u) || e.setAttribute(\"class\", q(u + \" \" + n))) : e.setAttribute(\"class\", q(u.replace(t, \" \"))); }; }\n    function P(n, t, e) { function r() { this.style.removeProperty(n); } function u() { this.style.setProperty(n, t, e); } function i() { var r = t.apply(this, arguments); null == r ? this.style.removeProperty(n) : this.style.setProperty(n, r, e); } return null == t ? r : \"function\" == typeof t ? i : u; }\n    function U(n, t) { function e() { delete this[n]; } function r() { this[n] = t; } function u() { var e = t.apply(this, arguments); null == e ? delete this[n] : this[n] = e; } return null == t ? e : \"function\" == typeof t ? u : r; }\n    function j(n) { function t() { var t = this.ownerDocument, e = this.namespaceURI; return e ? t.createElementNS(e, n) : t.createElement(n); } function e() { return this.ownerDocument.createElementNS(n.space, n.local); } return \"function\" == typeof n ? n : (n = ta.ns.qualify(n)).local ? e : t; }\n    function F() { var n = this.parentNode; n && n.removeChild(this); }\n    function H(n) { return { __data__: n }; }\n    function O(n) { return function () { return ba(this, n); }; }\n    function I(n) { return arguments.length || (n = e), function (t, e) { return t && e ? n(t.__data__, e.__data__) : !t - !e; }; }\n    function Y(n, t) { for (var e = 0, r = n.length; r > e; e++)\n        for (var u, i = n[e], o = 0, a = i.length; a > o; o++)\n            (u = i[o]) && t(u, o, e); return n; }\n    function Z(n) { return ya(n, Sa), n; }\n    function V(n) { var t, e; return function (r, u, i) { var o, a = n[i].update, c = a.length; for (i != e && (e = i, t = 0), u >= t && (t = u + 1); !(o = a[t]) && ++t < c;)\n        ; return o; }; }\n    function X(n, t, e) { function r() { var t = this[o]; t && (this.removeEventListener(n, t, t.$), delete this[o]); } function u() { var u = c(t, ra(arguments)); r.call(this), this.addEventListener(n, this[o] = u, u.$ = e), u._ = t; } function i() { var t, e = new RegExp(\"^__on([^.]+)\" + ta.requote(n) + \"$\"); for (var r in this)\n        if (t = r.match(e)) {\n            var u = this[r];\n            this.removeEventListener(t[1], u, u.$), delete this[r];\n        } } var o = \"__on\" + n, a = n.indexOf(\".\"), c = $; a > 0 && (n = n.slice(0, a)); var l = ka.get(n); return l && (n = l, c = B), a ? t ? u : r : t ? b : i; }\n    function $(n, t) { return function (e) { var r = ta.event; ta.event = e, t[0] = this.__data__; try {\n        n.apply(this, t);\n    }\n    finally {\n        ta.event = r;\n    } }; }\n    function B(n, t) { var e = $(n, t); return function (n) { var t = this, r = n.relatedTarget; r && (r === t || 8 & r.compareDocumentPosition(t)) || e.call(t, n); }; }\n    function W(e) { var r = \".dragsuppress-\" + ++Aa, u = \"click\" + r, i = ta.select(t(e)).on(\"touchmove\" + r, S).on(\"dragstart\" + r, S).on(\"selectstart\" + r, S); if (null == Ea && (Ea = \"onselectstart\" in e ? !1 : x(e.style, \"userSelect\")), Ea) {\n        var o = n(e).style, a = o[Ea];\n        o[Ea] = \"none\";\n    } return function (n) { if (i.on(r, null), Ea && (o[Ea] = a), n) {\n        var t = function () { i.on(u, null); };\n        i.on(u, function () { S(), t(); }, !0), setTimeout(t, 0);\n    } }; }\n    function J(n, e) { e.changedTouches && (e = e.changedTouches[0]); var r = n.ownerSVGElement || n; if (r.createSVGPoint) {\n        var u = r.createSVGPoint();\n        if (0 > Na) {\n            var i = t(n);\n            if (i.scrollX || i.scrollY) {\n                r = ta.select(\"body\").append(\"svg\").style({ position: \"absolute\", top: 0, left: 0, margin: 0, padding: 0, border: \"none\" }, \"important\");\n                var o = r[0][0].getScreenCTM();\n                Na = !(o.f || o.e), r.remove();\n            }\n        }\n        return Na ? (u.x = e.pageX, u.y = e.pageY) : (u.x = e.clientX, u.y = e.clientY), u = u.matrixTransform(n.getScreenCTM().inverse()), [u.x, u.y];\n    } var a = n.getBoundingClientRect(); return [e.clientX - a.left - n.clientLeft, e.clientY - a.top - n.clientTop]; }\n    function G() { return ta.event.changedTouches[0].identifier; }\n    function K(n) { return n > 0 ? 1 : 0 > n ? -1 : 0; }\n    function Q(n, t, e) { return (t[0] - n[0]) * (e[1] - n[1]) - (t[1] - n[1]) * (e[0] - n[0]); }\n    function nt(n) { return n > 1 ? 0 : -1 > n ? qa : Math.acos(n); }\n    function tt(n) { return n > 1 ? Ra : -1 > n ? -Ra : Math.asin(n); }\n    function et(n) { return ((n = Math.exp(n)) - 1 / n) / 2; }\n    function rt(n) { return ((n = Math.exp(n)) + 1 / n) / 2; }\n    function ut(n) { return ((n = Math.exp(2 * n)) - 1) / (n + 1); }\n    function it(n) { return (n = Math.sin(n / 2)) * n; }\n    function ot() { }\n    function at(n, t, e) { return this instanceof at ? (this.h = +n, this.s = +t, void (this.l = +e)) : arguments.length < 2 ? n instanceof at ? new at(n.h, n.s, n.l) : bt(\"\" + n, _t, at) : new at(n, t, e); }\n    function ct(n, t, e) { function r(n) { return n > 360 ? n -= 360 : 0 > n && (n += 360), 60 > n ? i + (o - i) * n / 60 : 180 > n ? o : 240 > n ? i + (o - i) * (240 - n) / 60 : i; } function u(n) { return Math.round(255 * r(n)); } var i, o; return n = isNaN(n) ? 0 : (n %= 360) < 0 ? n + 360 : n, t = isNaN(t) ? 0 : 0 > t ? 0 : t > 1 ? 1 : t, e = 0 > e ? 0 : e > 1 ? 1 : e, o = .5 >= e ? e * (1 + t) : e + t - e * t, i = 2 * e - o, new mt(u(n + 120), u(n), u(n - 120)); }\n    function lt(n, t, e) { return this instanceof lt ? (this.h = +n, this.c = +t, void (this.l = +e)) : arguments.length < 2 ? n instanceof lt ? new lt(n.h, n.c, n.l) : n instanceof ft ? gt(n.l, n.a, n.b) : gt((n = wt((n = ta.rgb(n)).r, n.g, n.b)).l, n.a, n.b) : new lt(n, t, e); }\n    function st(n, t, e) { return isNaN(n) && (n = 0), isNaN(t) && (t = 0), new ft(e, Math.cos(n *= Da) * t, Math.sin(n) * t); }\n    function ft(n, t, e) { return this instanceof ft ? (this.l = +n, this.a = +t, void (this.b = +e)) : arguments.length < 2 ? n instanceof ft ? new ft(n.l, n.a, n.b) : n instanceof lt ? st(n.h, n.c, n.l) : wt((n = mt(n)).r, n.g, n.b) : new ft(n, t, e); }\n    function ht(n, t, e) { var r = (n + 16) / 116, u = r + t / 500, i = r - e / 200; return u = pt(u) * Xa, r = pt(r) * $a, i = pt(i) * Ba, new mt(dt(3.2404542 * u - 1.5371385 * r - .4985314 * i), dt(-.969266 * u + 1.8760108 * r + .041556 * i), dt(.0556434 * u - .2040259 * r + 1.0572252 * i)); }\n    function gt(n, t, e) { return n > 0 ? new lt(Math.atan2(e, t) * Pa, Math.sqrt(t * t + e * e), n) : new lt(0 / 0, 0 / 0, n); }\n    function pt(n) { return n > .206893034 ? n * n * n : (n - 4 / 29) / 7.787037; }\n    function vt(n) { return n > .008856 ? Math.pow(n, 1 / 3) : 7.787037 * n + 4 / 29; }\n    function dt(n) { return Math.round(255 * (.00304 >= n ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - .055)); }\n    function mt(n, t, e) { return this instanceof mt ? (this.r = ~~n, this.g = ~~t, void (this.b = ~~e)) : arguments.length < 2 ? n instanceof mt ? new mt(n.r, n.g, n.b) : bt(\"\" + n, mt, ct) : new mt(n, t, e); }\n    function yt(n) { return new mt(n >> 16, n >> 8 & 255, 255 & n); }\n    function Mt(n) { return yt(n) + \"\"; }\n    function xt(n) { return 16 > n ? \"0\" + Math.max(0, n).toString(16) : Math.min(255, n).toString(16); }\n    function bt(n, t, e) { var r, u, i, o = 0, a = 0, c = 0; if (r = /([a-z]+)\\((.*)\\)/i.exec(n))\n        switch (u = r[2].split(\",\"), r[1]) {\n            case \"hsl\": return e(parseFloat(u[0]), parseFloat(u[1]) / 100, parseFloat(u[2]) / 100);\n            case \"rgb\": return t(kt(u[0]), kt(u[1]), kt(u[2]));\n        } return (i = Ga.get(n.toLowerCase())) ? t(i.r, i.g, i.b) : (null == n || \"#\" !== n.charAt(0) || isNaN(i = parseInt(n.slice(1), 16)) || (4 === n.length ? (o = (3840 & i) >> 4, o = o >> 4 | o, a = 240 & i, a = a >> 4 | a, c = 15 & i, c = c << 4 | c) : 7 === n.length && (o = (16711680 & i) >> 16, a = (65280 & i) >> 8, c = 255 & i)), t(o, a, c)); }\n    function _t(n, t, e) { var r, u, i = Math.min(n /= 255, t /= 255, e /= 255), o = Math.max(n, t, e), a = o - i, c = (o + i) / 2; return a ? (u = .5 > c ? a / (o + i) : a / (2 - o - i), r = n == o ? (t - e) / a + (e > t ? 6 : 0) : t == o ? (e - n) / a + 2 : (n - t) / a + 4, r *= 60) : (r = 0 / 0, u = c > 0 && 1 > c ? 0 : r), new at(r, u, c); }\n    function wt(n, t, e) { n = St(n), t = St(t), e = St(e); var r = vt((.4124564 * n + .3575761 * t + .1804375 * e) / Xa), u = vt((.2126729 * n + .7151522 * t + .072175 * e) / $a), i = vt((.0193339 * n + .119192 * t + .9503041 * e) / Ba); return ft(116 * u - 16, 500 * (r - u), 200 * (u - i)); }\n    function St(n) { return (n /= 255) <= .04045 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4); }\n    function kt(n) { var t = parseFloat(n); return \"%\" === n.charAt(n.length - 1) ? Math.round(2.55 * t) : t; }\n    function Et(n) { return \"function\" == typeof n ? n : function () { return n; }; }\n    function At(n) { return function (t, e, r) { return 2 === arguments.length && \"function\" == typeof e && (r = e, e = null), Nt(t, e, n, r); }; }\n    function Nt(n, t, e, r) { function u() { var n, t = c.status; if (!t && zt(c) || t >= 200 && 300 > t || 304 === t) {\n        try {\n            n = e.call(i, c);\n        }\n        catch (r) {\n            return void o.error.call(i, r);\n        }\n        o.load.call(i, n);\n    }\n    else\n        o.error.call(i, c); } var i = {}, o = ta.dispatch(\"beforesend\", \"progress\", \"load\", \"error\"), a = {}, c = new XMLHttpRequest, l = null; return !this.XDomainRequest || \"withCredentials\" in c || !/^(http(s)?:)?\\/\\//.test(n) || (c = new XDomainRequest), \"onload\" in c ? c.onload = c.onerror = u : c.onreadystatechange = function () { c.readyState > 3 && u(); }, c.onprogress = function (n) { var t = ta.event; ta.event = n; try {\n        o.progress.call(i, c);\n    }\n    finally {\n        ta.event = t;\n    } }, i.header = function (n, t) { return n = (n + \"\").toLowerCase(), arguments.length < 2 ? a[n] : (null == t ? delete a[n] : a[n] = t + \"\", i); }, i.mimeType = function (n) { return arguments.length ? (t = null == n ? null : n + \"\", i) : t; }, i.responseType = function (n) { return arguments.length ? (l = n, i) : l; }, i.response = function (n) { return e = n, i; }, [\"get\", \"post\"].forEach(function (n) { i[n] = function () { return i.send.apply(i, [n].concat(ra(arguments))); }; }), i.send = function (e, r, u) { if (2 === arguments.length && \"function\" == typeof r && (u = r, r = null), c.open(e, n, !0), null == t || \"accept\" in a || (a.accept = t + \",*/*\"), c.setRequestHeader)\n        for (var s in a)\n            c.setRequestHeader(s, a[s]); return null != t && c.overrideMimeType && c.overrideMimeType(t), null != l && (c.responseType = l), null != u && i.on(\"error\", u).on(\"load\", function (n) { u(null, n); }), o.beforesend.call(i, c), c.send(null == r ? null : r), i; }, i.abort = function () { return c.abort(), i; }, ta.rebind(i, o, \"on\"), null == r ? i : i.get(Ct(r)); }\n    function Ct(n) { return 1 === n.length ? function (t, e) { n(null == t ? e : null); } : n; }\n    function zt(n) { var t = n.responseType; return t && \"text\" !== t ? n.response : n.responseText; }\n    function qt() { var n = Lt(), t = Tt() - n; t > 24 ? (isFinite(t) && (clearTimeout(tc), tc = setTimeout(qt, t)), nc = 0) : (nc = 1, rc(qt)); }\n    function Lt() { var n = Date.now(); for (ec = Ka; ec;)\n        n >= ec.t && (ec.f = ec.c(n - ec.t)), ec = ec.n; return n; }\n    function Tt() { for (var n, t = Ka, e = 1 / 0; t;)\n        t.f ? t = n ? n.n = t.n : Ka = t.n : (t.t < e && (e = t.t), t = (n = t).n); return Qa = n, e; }\n    function Rt(n, t) { return t - (n ? Math.ceil(Math.log(n) / Math.LN10) : 1); }\n    function Dt(n, t) { var e = Math.pow(10, 3 * ga(8 - t)); return { scale: t > 8 ? function (n) { return n / e; } : function (n) { return n * e; }, symbol: n }; }\n    function Pt(n) { var t = n.decimal, e = n.thousands, r = n.grouping, u = n.currency, i = r && e ? function (n, t) { for (var u = n.length, i = [], o = 0, a = r[0], c = 0; u > 0 && a > 0 && (c + a + 1 > t && (a = Math.max(1, t - c)), i.push(n.substring(u -= a, u + a)), !((c += a + 1) > t));)\n        a = r[o = (o + 1) % r.length]; return i.reverse().join(e); } : y; return function (n) { var e = ic.exec(n), r = e[1] || \" \", o = e[2] || \">\", a = e[3] || \"-\", c = e[4] || \"\", l = e[5], s = +e[6], f = e[7], h = e[8], g = e[9], p = 1, v = \"\", d = \"\", m = !1, y = !0; switch (h && (h = +h.substring(1)), (l || \"0\" === r && \"=\" === o) && (l = r = \"0\", o = \"=\"), g) {\n        case \"n\":\n            f = !0, g = \"g\";\n            break;\n        case \"%\":\n            p = 100, d = \"%\", g = \"f\";\n            break;\n        case \"p\":\n            p = 100, d = \"%\", g = \"r\";\n            break;\n        case \"b\":\n        case \"o\":\n        case \"x\":\n        case \"X\": \"#\" === c && (v = \"0\" + g.toLowerCase());\n        case \"c\": y = !1;\n        case \"d\":\n            m = !0, h = 0;\n            break;\n        case \"s\": p = -1, g = \"r\";\n    } \"$\" === c && (v = u[0], d = u[1]), \"r\" != g || h || (g = \"g\"), null != h && (\"g\" == g ? h = Math.max(1, Math.min(21, h)) : (\"e\" == g || \"f\" == g) && (h = Math.max(0, Math.min(20, h)))), g = oc.get(g) || Ut; var M = l && f; return function (n) { var e = d; if (m && n % 1)\n        return \"\"; var u = 0 > n || 0 === n && 0 > 1 / n ? (n = -n, \"-\") : \"-\" === a ? \"\" : a; if (0 > p) {\n        var c = ta.formatPrefix(n, h);\n        n = c.scale(n), e = c.symbol + d;\n    }\n    else\n        n *= p; n = g(n, h); var x, b, _ = n.lastIndexOf(\".\"); if (0 > _) {\n        var w = y ? n.lastIndexOf(\"e\") : -1;\n        0 > w ? (x = n, b = \"\") : (x = n.substring(0, w), b = n.substring(w));\n    }\n    else\n        x = n.substring(0, _), b = t + n.substring(_ + 1); !l && f && (x = i(x, 1 / 0)); var S = v.length + x.length + b.length + (M ? 0 : u.length), k = s > S ? new Array(S = s - S + 1).join(r) : \"\"; return M && (x = i(k + x, k.length ? s - b.length : 1 / 0)), u += v, n = x + b, (\"<\" === o ? u + n + k : \">\" === o ? k + u + n : \"^\" === o ? k.substring(0, S >>= 1) + u + n + k.substring(S) : u + (M ? n : k + n)) + e; }; }; }\n    function Ut(n) { return n + \"\"; }\n    function jt() { this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]); }\n    function Ft(n, t, e) { function r(t) { var e = n(t), r = i(e, 1); return r - t > t - e ? e : r; } function u(e) { return t(e = n(new cc(e - 1)), 1), e; } function i(n, e) { return t(n = new cc(+n), e), n; } function o(n, r, i) { var o = u(n), a = []; if (i > 1)\n        for (; r > o;)\n            e(o) % i || a.push(new Date(+o)), t(o, 1);\n    else\n        for (; r > o;)\n            a.push(new Date(+o)), t(o, 1); return a; } function a(n, t, e) { try {\n        cc = jt;\n        var r = new jt;\n        return r._ = n, o(r, t, e);\n    }\n    finally {\n        cc = Date;\n    } } n.floor = n, n.round = r, n.ceil = u, n.offset = i, n.range = o; var c = n.utc = Ht(n); return c.floor = c, c.round = Ht(r), c.ceil = Ht(u), c.offset = Ht(i), c.range = a, n; }\n    function Ht(n) { return function (t, e) { try {\n        cc = jt;\n        var r = new jt;\n        return r._ = t, n(r, e)._;\n    }\n    finally {\n        cc = Date;\n    } }; }\n    function Ot(n) { function t(n) { function t(t) { for (var e, u, i, o = [], a = -1, c = 0; ++a < r;)\n        37 === n.charCodeAt(a) && (o.push(n.slice(c, a)), null != (u = sc[e = n.charAt(++a)]) && (e = n.charAt(++a)), (i = N[e]) && (e = i(t, null == u ? \"e\" === e ? \" \" : \"0\" : u)), o.push(e), c = a + 1); return o.push(n.slice(c, a)), o.join(\"\"); } var r = n.length; return t.parse = function (t) { var r = { y: 1900, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0, Z: null }, u = e(r, n, t, 0); if (u != t.length)\n        return null; \"p\" in r && (r.H = r.H % 12 + 12 * r.p); var i = null != r.Z && cc !== jt, o = new (i ? jt : cc); return \"j\" in r ? o.setFullYear(r.y, 0, r.j) : \"w\" in r && (\"W\" in r || \"U\" in r) ? (o.setFullYear(r.y, 0, 1), o.setFullYear(r.y, 0, \"W\" in r ? (r.w + 6) % 7 + 7 * r.W - (o.getDay() + 5) % 7 : r.w + 7 * r.U - (o.getDay() + 6) % 7)) : o.setFullYear(r.y, r.m, r.d), o.setHours(r.H + (r.Z / 100 | 0), r.M + r.Z % 100, r.S, r.L), i ? o._ : o; }, t.toString = function () { return n; }, t; } function e(n, t, e, r) { for (var u, i, o, a = 0, c = t.length, l = e.length; c > a;) {\n        if (r >= l)\n            return -1;\n        if (u = t.charCodeAt(a++), 37 === u) {\n            if (o = t.charAt(a++), i = C[o in sc ? t.charAt(a++) : o], !i || (r = i(n, e, r)) < 0)\n                return -1;\n        }\n        else if (u != e.charCodeAt(r++))\n            return -1;\n    } return r; } function r(n, t, e) { _.lastIndex = 0; var r = _.exec(t.slice(e)); return r ? (n.w = w.get(r[0].toLowerCase()), e + r[0].length) : -1; } function u(n, t, e) { x.lastIndex = 0; var r = x.exec(t.slice(e)); return r ? (n.w = b.get(r[0].toLowerCase()), e + r[0].length) : -1; } function i(n, t, e) { E.lastIndex = 0; var r = E.exec(t.slice(e)); return r ? (n.m = A.get(r[0].toLowerCase()), e + r[0].length) : -1; } function o(n, t, e) { S.lastIndex = 0; var r = S.exec(t.slice(e)); return r ? (n.m = k.get(r[0].toLowerCase()), e + r[0].length) : -1; } function a(n, t, r) { return e(n, N.c.toString(), t, r); } function c(n, t, r) { return e(n, N.x.toString(), t, r); } function l(n, t, r) { return e(n, N.X.toString(), t, r); } function s(n, t, e) { var r = M.get(t.slice(e, e += 2).toLowerCase()); return null == r ? -1 : (n.p = r, e); } var f = n.dateTime, h = n.date, g = n.time, p = n.periods, v = n.days, d = n.shortDays, m = n.months, y = n.shortMonths; t.utc = function (n) { function e(n) { try {\n        cc = jt;\n        var t = new cc;\n        return t._ = n, r(t);\n    }\n    finally {\n        cc = Date;\n    } } var r = t(n); return e.parse = function (n) { try {\n        cc = jt;\n        var t = r.parse(n);\n        return t && t._;\n    }\n    finally {\n        cc = Date;\n    } }, e.toString = r.toString, e; }, t.multi = t.utc.multi = ae; var M = ta.map(), x = Yt(v), b = Zt(v), _ = Yt(d), w = Zt(d), S = Yt(m), k = Zt(m), E = Yt(y), A = Zt(y); p.forEach(function (n, t) { M.set(n.toLowerCase(), t); }); var N = { a: function (n) { return d[n.getDay()]; }, A: function (n) { return v[n.getDay()]; }, b: function (n) { return y[n.getMonth()]; }, B: function (n) { return m[n.getMonth()]; }, c: t(f), d: function (n, t) { return It(n.getDate(), t, 2); }, e: function (n, t) { return It(n.getDate(), t, 2); }, H: function (n, t) { return It(n.getHours(), t, 2); }, I: function (n, t) { return It(n.getHours() % 12 || 12, t, 2); }, j: function (n, t) { return It(1 + ac.dayOfYear(n), t, 3); }, L: function (n, t) { return It(n.getMilliseconds(), t, 3); }, m: function (n, t) { return It(n.getMonth() + 1, t, 2); }, M: function (n, t) { return It(n.getMinutes(), t, 2); }, p: function (n) { return p[+(n.getHours() >= 12)]; }, S: function (n, t) { return It(n.getSeconds(), t, 2); }, U: function (n, t) { return It(ac.sundayOfYear(n), t, 2); }, w: function (n) { return n.getDay(); }, W: function (n, t) { return It(ac.mondayOfYear(n), t, 2); }, x: t(h), X: t(g), y: function (n, t) { return It(n.getFullYear() % 100, t, 2); }, Y: function (n, t) { return It(n.getFullYear() % 1e4, t, 4); }, Z: ie, \"%\": function () { return \"%\"; } }, C = { a: r, A: u, b: i, B: o, c: a, d: Qt, e: Qt, H: te, I: te, j: ne, L: ue, m: Kt, M: ee, p: s, S: re, U: Xt, w: Vt, W: $t, x: c, X: l, y: Wt, Y: Bt, Z: Jt, \"%\": oe }; return t; }\n    function It(n, t, e) { var r = 0 > n ? \"-\" : \"\", u = (r ? -n : n) + \"\", i = u.length; return r + (e > i ? new Array(e - i + 1).join(t) + u : u); }\n    function Yt(n) { return new RegExp(\"^(?:\" + n.map(ta.requote).join(\"|\") + \")\", \"i\"); }\n    function Zt(n) { for (var t = new l, e = -1, r = n.length; ++e < r;)\n        t.set(n[e].toLowerCase(), e); return t; }\n    function Vt(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 1)); return r ? (n.w = +r[0], e + r[0].length) : -1; }\n    function Xt(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e)); return r ? (n.U = +r[0], e + r[0].length) : -1; }\n    function $t(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e)); return r ? (n.W = +r[0], e + r[0].length) : -1; }\n    function Bt(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 4)); return r ? (n.y = +r[0], e + r[0].length) : -1; }\n    function Wt(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 2)); return r ? (n.y = Gt(+r[0]), e + r[0].length) : -1; }\n    function Jt(n, t, e) { return /^[+-]\\d{4}$/.test(t = t.slice(e, e + 5)) ? (n.Z = -t, e + 5) : -1; }\n    function Gt(n) { return n + (n > 68 ? 1900 : 2e3); }\n    function Kt(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 2)); return r ? (n.m = r[0] - 1, e + r[0].length) : -1; }\n    function Qt(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 2)); return r ? (n.d = +r[0], e + r[0].length) : -1; }\n    function ne(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 3)); return r ? (n.j = +r[0], e + r[0].length) : -1; }\n    function te(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 2)); return r ? (n.H = +r[0], e + r[0].length) : -1; }\n    function ee(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 2)); return r ? (n.M = +r[0], e + r[0].length) : -1; }\n    function re(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 2)); return r ? (n.S = +r[0], e + r[0].length) : -1; }\n    function ue(n, t, e) { fc.lastIndex = 0; var r = fc.exec(t.slice(e, e + 3)); return r ? (n.L = +r[0], e + r[0].length) : -1; }\n    function ie(n) { var t = n.getTimezoneOffset(), e = t > 0 ? \"-\" : \"+\", r = ga(t) / 60 | 0, u = ga(t) % 60; return e + It(r, \"0\", 2) + It(u, \"0\", 2); }\n    function oe(n, t, e) { hc.lastIndex = 0; var r = hc.exec(t.slice(e, e + 1)); return r ? e + r[0].length : -1; }\n    function ae(n) { for (var t = n.length, e = -1; ++e < t;)\n        n[e][0] = this(n[e][0]); return function (t) { for (var e = 0, r = n[e]; !r[1](t);)\n        r = n[++e]; return r[0](t); }; }\n    function ce() { }\n    function le(n, t, e) { var r = e.s = n + t, u = r - n, i = r - u; e.t = n - i + (t - u); }\n    function se(n, t) { n && dc.hasOwnProperty(n.type) && dc[n.type](n, t); }\n    function fe(n, t, e) { var r, u = -1, i = n.length - e; for (t.lineStart(); ++u < i;)\n        r = n[u], t.point(r[0], r[1], r[2]); t.lineEnd(); }\n    function he(n, t) { var e = -1, r = n.length; for (t.polygonStart(); ++e < r;)\n        fe(n[e], t, 1); t.polygonEnd(); }\n    function ge() { function n(n, t) { n *= Da, t = t * Da / 2 + qa / 4; var e = n - r, o = e >= 0 ? 1 : -1, a = o * e, c = Math.cos(t), l = Math.sin(t), s = i * l, f = u * c + s * Math.cos(a), h = s * o * Math.sin(a); yc.add(Math.atan2(h, f)), r = n, u = c, i = l; } var t, e, r, u, i; Mc.point = function (o, a) { Mc.point = n, r = (t = o) * Da, u = Math.cos(a = (e = a) * Da / 2 + qa / 4), i = Math.sin(a); }, Mc.lineEnd = function () { n(t, e); }; }\n    function pe(n) { var t = n[0], e = n[1], r = Math.cos(e); return [r * Math.cos(t), r * Math.sin(t), Math.sin(e)]; }\n    function ve(n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]; }\n    function de(n, t) { return [n[1] * t[2] - n[2] * t[1], n[2] * t[0] - n[0] * t[2], n[0] * t[1] - n[1] * t[0]]; }\n    function me(n, t) { n[0] += t[0], n[1] += t[1], n[2] += t[2]; }\n    function ye(n, t) { return [n[0] * t, n[1] * t, n[2] * t]; }\n    function Me(n) { var t = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]); n[0] /= t, n[1] /= t, n[2] /= t; }\n    function xe(n) { return [Math.atan2(n[1], n[0]), tt(n[2])]; }\n    function be(n, t) { return ga(n[0] - t[0]) < Ca && ga(n[1] - t[1]) < Ca; }\n    function _e(n, t) { n *= Da; var e = Math.cos(t *= Da); we(e * Math.cos(n), e * Math.sin(n), Math.sin(t)); }\n    function we(n, t, e) { ++xc, _c += (n - _c) / xc, wc += (t - wc) / xc, Sc += (e - Sc) / xc; }\n    function Se() { function n(n, u) { n *= Da; var i = Math.cos(u *= Da), o = i * Math.cos(n), a = i * Math.sin(n), c = Math.sin(u), l = Math.atan2(Math.sqrt((l = e * c - r * a) * l + (l = r * o - t * c) * l + (l = t * a - e * o) * l), t * o + e * a + r * c); bc += l, kc += l * (t + (t = o)), Ec += l * (e + (e = a)), Ac += l * (r + (r = c)), we(t, e, r); } var t, e, r; qc.point = function (u, i) { u *= Da; var o = Math.cos(i *= Da); t = o * Math.cos(u), e = o * Math.sin(u), r = Math.sin(i), qc.point = n, we(t, e, r); }; }\n    function ke() { qc.point = _e; }\n    function Ee() { function n(n, t) { n *= Da; var e = Math.cos(t *= Da), o = e * Math.cos(n), a = e * Math.sin(n), c = Math.sin(t), l = u * c - i * a, s = i * o - r * c, f = r * a - u * o, h = Math.sqrt(l * l + s * s + f * f), g = r * o + u * a + i * c, p = h && -nt(g) / h, v = Math.atan2(h, g); Nc += p * l, Cc += p * s, zc += p * f, bc += v, kc += v * (r + (r = o)), Ec += v * (u + (u = a)), Ac += v * (i + (i = c)), we(r, u, i); } var t, e, r, u, i; qc.point = function (o, a) { t = o, e = a, qc.point = n, o *= Da; var c = Math.cos(a *= Da); r = c * Math.cos(o), u = c * Math.sin(o), i = Math.sin(a), we(r, u, i); }, qc.lineEnd = function () { n(t, e), qc.lineEnd = ke, qc.point = _e; }; }\n    function Ae(n, t) { function e(e, r) { return e = n(e, r), t(e[0], e[1]); } return n.invert && t.invert && (e.invert = function (e, r) { return e = t.invert(e, r), e && n.invert(e[0], e[1]); }), e; }\n    function Ne() { return !0; }\n    function Ce(n, t, e, r, u) { var i = [], o = []; if (n.forEach(function (n) { if (!((t = n.length - 1) <= 0)) {\n        var t, e = n[0], r = n[t];\n        if (be(e, r)) {\n            u.lineStart();\n            for (var a = 0; t > a; ++a)\n                u.point((e = n[a])[0], e[1]);\n            return void u.lineEnd();\n        }\n        var c = new qe(e, n, null, !0), l = new qe(e, null, c, !1);\n        c.o = l, i.push(c), o.push(l), c = new qe(r, n, null, !1), l = new qe(r, null, c, !0), c.o = l, i.push(c), o.push(l);\n    } }), o.sort(t), ze(i), ze(o), i.length) {\n        for (var a = 0, c = e, l = o.length; l > a; ++a)\n            o[a].e = c = !c;\n        for (var s, f, h = i[0];;) {\n            for (var g = h, p = !0; g.v;)\n                if ((g = g.n) === h)\n                    return;\n            s = g.z, u.lineStart();\n            do {\n                if (g.v = g.o.v = !0, g.e) {\n                    if (p)\n                        for (var a = 0, l = s.length; l > a; ++a)\n                            u.point((f = s[a])[0], f[1]);\n                    else\n                        r(g.x, g.n.x, 1, u);\n                    g = g.n;\n                }\n                else {\n                    if (p) {\n                        s = g.p.z;\n                        for (var a = s.length - 1; a >= 0; --a)\n                            u.point((f = s[a])[0], f[1]);\n                    }\n                    else\n                        r(g.x, g.p.x, -1, u);\n                    g = g.p;\n                }\n                g = g.o, s = g.z, p = !p;\n            } while (!g.v);\n            u.lineEnd();\n        }\n    } }\n    function ze(n) { if (t = n.length) {\n        for (var t, e, r = 0, u = n[0]; ++r < t;)\n            u.n = e = n[r], e.p = u, u = e;\n        u.n = e = n[0], e.p = u;\n    } }\n    function qe(n, t, e, r) { this.x = n, this.z = t, this.o = e, this.e = r, this.v = !1, this.n = this.p = null; }\n    function Le(n, t, e, r) { return function (u, i) { function o(t, e) { var r = u(t, e); n(t = r[0], e = r[1]) && i.point(t, e); } function a(n, t) { var e = u(n, t); d.point(e[0], e[1]); } function c() { y.point = a, d.lineStart(); } function l() { y.point = o, d.lineEnd(); } function s(n, t) { v.push([n, t]); var e = u(n, t); x.point(e[0], e[1]); } function f() { x.lineStart(), v = []; } function h() { s(v[0][0], v[0][1]), x.lineEnd(); var n, t = x.clean(), e = M.buffer(), r = e.length; if (v.pop(), p.push(v), v = null, r)\n        if (1 & t) {\n            n = e[0];\n            var u, r = n.length - 1, o = -1;\n            if (r > 0) {\n                for (b || (i.polygonStart(), b = !0), i.lineStart(); ++o < r;)\n                    i.point((u = n[o])[0], u[1]);\n                i.lineEnd();\n            }\n        }\n        else\n            r > 1 && 2 & t && e.push(e.pop().concat(e.shift())), g.push(e.filter(Te)); } var g, p, v, d = t(i), m = u.invert(r[0], r[1]), y = { point: o, lineStart: c, lineEnd: l, polygonStart: function () { y.point = s, y.lineStart = f, y.lineEnd = h, g = [], p = []; }, polygonEnd: function () { y.point = o, y.lineStart = c, y.lineEnd = l, g = ta.merge(g); var n = Fe(m, p); g.length ? (b || (i.polygonStart(), b = !0), Ce(g, De, n, e, i)) : n && (b || (i.polygonStart(), b = !0), i.lineStart(), e(null, null, 1, i), i.lineEnd()), b && (i.polygonEnd(), b = !1), g = p = null; }, sphere: function () { i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd(); } }, M = Re(), x = t(M), b = !1; return y; }; }\n    function Te(n) { return n.length > 1; }\n    function Re() { var n, t = []; return { lineStart: function () { t.push(n = []); }, point: function (t, e) { n.push([t, e]); }, lineEnd: b, buffer: function () { var e = t; return t = [], n = null, e; }, rejoin: function () { t.length > 1 && t.push(t.pop().concat(t.shift())); } }; }\n    function De(n, t) { return ((n = n.x)[0] < 0 ? n[1] - Ra - Ca : Ra - n[1]) - ((t = t.x)[0] < 0 ? t[1] - Ra - Ca : Ra - t[1]); }\n    function Pe(n) { var t, e = 0 / 0, r = 0 / 0, u = 0 / 0; return { lineStart: function () { n.lineStart(), t = 1; }, point: function (i, o) { var a = i > 0 ? qa : -qa, c = ga(i - e); ga(c - qa) < Ca ? (n.point(e, r = (r + o) / 2 > 0 ? Ra : -Ra), n.point(u, r), n.lineEnd(), n.lineStart(), n.point(a, r), n.point(i, r), t = 0) : u !== a && c >= qa && (ga(e - u) < Ca && (e -= u * Ca), ga(i - a) < Ca && (i -= a * Ca), r = Ue(e, r, i, o), n.point(u, r), n.lineEnd(), n.lineStart(), n.point(a, r), t = 0), n.point(e = i, r = o), u = a; }, lineEnd: function () { n.lineEnd(), e = r = 0 / 0; }, clean: function () { return 2 - t; } }; }\n    function Ue(n, t, e, r) { var u, i, o = Math.sin(n - e); return ga(o) > Ca ? Math.atan((Math.sin(t) * (i = Math.cos(r)) * Math.sin(e) - Math.sin(r) * (u = Math.cos(t)) * Math.sin(n)) / (u * i * o)) : (t + r) / 2; }\n    function je(n, t, e, r) { var u; if (null == n)\n        u = e * Ra, r.point(-qa, u), r.point(0, u), r.point(qa, u), r.point(qa, 0), r.point(qa, -u), r.point(0, -u), r.point(-qa, -u), r.point(-qa, 0), r.point(-qa, u);\n    else if (ga(n[0] - t[0]) > Ca) {\n        var i = n[0] < t[0] ? qa : -qa;\n        u = e * i / 2, r.point(-i, u), r.point(0, u), r.point(i, u);\n    }\n    else\n        r.point(t[0], t[1]); }\n    function Fe(n, t) { var e = n[0], r = n[1], u = [Math.sin(e), -Math.cos(e), 0], i = 0, o = 0; yc.reset(); for (var a = 0, c = t.length; c > a; ++a) {\n        var l = t[a], s = l.length;\n        if (s)\n            for (var f = l[0], h = f[0], g = f[1] / 2 + qa / 4, p = Math.sin(g), v = Math.cos(g), d = 1;;) {\n                d === s && (d = 0), n = l[d];\n                var m = n[0], y = n[1] / 2 + qa / 4, M = Math.sin(y), x = Math.cos(y), b = m - h, _ = b >= 0 ? 1 : -1, w = _ * b, S = w > qa, k = p * M;\n                if (yc.add(Math.atan2(k * _ * Math.sin(w), v * x + k * Math.cos(w))), i += S ? b + _ * La : b, S ^ h >= e ^ m >= e) {\n                    var E = de(pe(f), pe(n));\n                    Me(E);\n                    var A = de(u, E);\n                    Me(A);\n                    var N = (S ^ b >= 0 ? -1 : 1) * tt(A[2]);\n                    (r > N || r === N && (E[0] || E[1])) && (o += S ^ b >= 0 ? 1 : -1);\n                }\n                if (!d++)\n                    break;\n                h = m, p = M, v = x, f = n;\n            }\n    } return (-Ca > i || Ca > i && 0 > yc) ^ 1 & o; }\n    function He(n) { function t(n, t) { return Math.cos(n) * Math.cos(t) > i; } function e(n) { var e, i, c, l, s; return { lineStart: function () { l = c = !1, s = 1; }, point: function (f, h) { var g, p = [f, h], v = t(f, h), d = o ? v ? 0 : u(f, h) : v ? u(f + (0 > f ? qa : -qa), h) : 0; if (!e && (l = c = v) && n.lineStart(), v !== c && (g = r(e, p), (be(e, g) || be(p, g)) && (p[0] += Ca, p[1] += Ca, v = t(p[0], p[1]))), v !== c)\n            s = 0, v ? (n.lineStart(), g = r(p, e), n.point(g[0], g[1])) : (g = r(e, p), n.point(g[0], g[1]), n.lineEnd()), e = g;\n        else if (a && e && o ^ v) {\n            var m;\n            d & i || !(m = r(p, e, !0)) || (s = 0, o ? (n.lineStart(), n.point(m[0][0], m[0][1]), n.point(m[1][0], m[1][1]), n.lineEnd()) : (n.point(m[1][0], m[1][1]), n.lineEnd(), n.lineStart(), n.point(m[0][0], m[0][1])));\n        } !v || e && be(e, p) || n.point(p[0], p[1]), e = p, c = v, i = d; }, lineEnd: function () { c && n.lineEnd(), e = null; }, clean: function () { return s | (l && c) << 1; } }; } function r(n, t, e) { var r = pe(n), u = pe(t), o = [1, 0, 0], a = de(r, u), c = ve(a, a), l = a[0], s = c - l * l; if (!s)\n        return !e && n; var f = i * c / s, h = -i * l / s, g = de(o, a), p = ye(o, f), v = ye(a, h); me(p, v); var d = g, m = ve(p, d), y = ve(d, d), M = m * m - y * (ve(p, p) - 1); if (!(0 > M)) {\n        var x = Math.sqrt(M), b = ye(d, (-m - x) / y);\n        if (me(b, p), b = xe(b), !e)\n            return b;\n        var _, w = n[0], S = t[0], k = n[1], E = t[1];\n        w > S && (_ = w, w = S, S = _);\n        var A = S - w, N = ga(A - qa) < Ca, C = N || Ca > A;\n        if (!N && k > E && (_ = k, k = E, E = _), C ? N ? k + E > 0 ^ b[1] < (ga(b[0] - w) < Ca ? k : E) : k <= b[1] && b[1] <= E : A > qa ^ (w <= b[0] && b[0] <= S)) {\n            var z = ye(d, (-m + x) / y);\n            return me(z, p), [b, xe(z)];\n        }\n    } } function u(t, e) { var r = o ? n : qa - n, u = 0; return -r > t ? u |= 1 : t > r && (u |= 2), -r > e ? u |= 4 : e > r && (u |= 8), u; } var i = Math.cos(n), o = i > 0, a = ga(i) > Ca, c = gr(n, 6 * Da); return Le(t, e, c, o ? [0, -n] : [-qa, n - qa]); }\n    function Oe(n, t, e, r) { return function (u) { var i, o = u.a, a = u.b, c = o.x, l = o.y, s = a.x, f = a.y, h = 0, g = 1, p = s - c, v = f - l; if (i = n - c, p || !(i > 0)) {\n        if (i /= p, 0 > p) {\n            if (h > i)\n                return;\n            g > i && (g = i);\n        }\n        else if (p > 0) {\n            if (i > g)\n                return;\n            i > h && (h = i);\n        }\n        if (i = e - c, p || !(0 > i)) {\n            if (i /= p, 0 > p) {\n                if (i > g)\n                    return;\n                i > h && (h = i);\n            }\n            else if (p > 0) {\n                if (h > i)\n                    return;\n                g > i && (g = i);\n            }\n            if (i = t - l, v || !(i > 0)) {\n                if (i /= v, 0 > v) {\n                    if (h > i)\n                        return;\n                    g > i && (g = i);\n                }\n                else if (v > 0) {\n                    if (i > g)\n                        return;\n                    i > h && (h = i);\n                }\n                if (i = r - l, v || !(0 > i)) {\n                    if (i /= v, 0 > v) {\n                        if (i > g)\n                            return;\n                        i > h && (h = i);\n                    }\n                    else if (v > 0) {\n                        if (h > i)\n                            return;\n                        g > i && (g = i);\n                    }\n                    return h > 0 && (u.a = { x: c + h * p, y: l + h * v }), 1 > g && (u.b = { x: c + g * p, y: l + g * v }), u;\n                }\n            }\n        }\n    } }; }\n    function Ie(n, t, e, r) { function u(r, u) { return ga(r[0] - n) < Ca ? u > 0 ? 0 : 3 : ga(r[0] - e) < Ca ? u > 0 ? 2 : 1 : ga(r[1] - t) < Ca ? u > 0 ? 1 : 0 : u > 0 ? 3 : 2; } function i(n, t) { return o(n.x, t.x); } function o(n, t) { var e = u(n, 1), r = u(t, 1); return e !== r ? e - r : 0 === e ? t[1] - n[1] : 1 === e ? n[0] - t[0] : 2 === e ? n[1] - t[1] : t[0] - n[0]; } return function (a) { function c(n) { for (var t = 0, e = d.length, r = n[1], u = 0; e > u; ++u)\n        for (var i, o = 1, a = d[u], c = a.length, l = a[0]; c > o; ++o)\n            i = a[o], l[1] <= r ? i[1] > r && Q(l, i, n) > 0 && ++t : i[1] <= r && Q(l, i, n) < 0 && --t, l = i; return 0 !== t; } function l(i, a, c, l) { var s = 0, f = 0; if (null == i || (s = u(i, c)) !== (f = u(a, c)) || o(i, a) < 0 ^ c > 0) {\n        do\n            l.point(0 === s || 3 === s ? n : e, s > 1 ? r : t);\n        while ((s = (s + c + 4) % 4) !== f);\n    }\n    else\n        l.point(a[0], a[1]); } function s(u, i) { return u >= n && e >= u && i >= t && r >= i; } function f(n, t) { s(n, t) && a.point(n, t); } function h() { C.point = p, d && d.push(m = []), S = !0, w = !1, b = _ = 0 / 0; } function g() { v && (p(y, M), x && w && A.rejoin(), v.push(A.buffer())), C.point = f, w && a.lineEnd(); } function p(n, t) { n = Math.max(-Tc, Math.min(Tc, n)), t = Math.max(-Tc, Math.min(Tc, t)); var e = s(n, t); if (d && m.push([n, t]), S)\n        y = n, M = t, x = e, S = !1, e && (a.lineStart(), a.point(n, t));\n    else if (e && w)\n        a.point(n, t);\n    else {\n        var r = { a: { x: b, y: _ }, b: { x: n, y: t } };\n        N(r) ? (w || (a.lineStart(), a.point(r.a.x, r.a.y)), a.point(r.b.x, r.b.y), e || a.lineEnd(), k = !1) : e && (a.lineStart(), a.point(n, t), k = !1);\n    } b = n, _ = t, w = e; } var v, d, m, y, M, x, b, _, w, S, k, E = a, A = Re(), N = Oe(n, t, e, r), C = { point: f, lineStart: h, lineEnd: g, polygonStart: function () { a = A, v = [], d = [], k = !0; }, polygonEnd: function () { a = E, v = ta.merge(v); var t = c([n, r]), e = k && t, u = v.length; (e || u) && (a.polygonStart(), e && (a.lineStart(), l(null, null, 1, a), a.lineEnd()), u && Ce(v, i, t, l, a), a.polygonEnd()), v = d = m = null; } }; return C; }; }\n    function Ye(n) { var t = 0, e = qa / 3, r = ir(n), u = r(t, e); return u.parallels = function (n) { return arguments.length ? r(t = n[0] * qa / 180, e = n[1] * qa / 180) : [t / qa * 180, e / qa * 180]; }, u; }\n    function Ze(n, t) { function e(n, t) { var e = Math.sqrt(i - 2 * u * Math.sin(t)) / u; return [e * Math.sin(n *= u), o - e * Math.cos(n)]; } var r = Math.sin(n), u = (r + Math.sin(t)) / 2, i = 1 + r * (2 * u - r), o = Math.sqrt(i) / u; return e.invert = function (n, t) { var e = o - t; return [Math.atan2(n, e) / u, tt((i - (n * n + e * e) * u * u) / (2 * u))]; }, e; }\n    function Ve() { function n(n, t) { Dc += u * n - r * t, r = n, u = t; } var t, e, r, u; Hc.point = function (i, o) { Hc.point = n, t = r = i, e = u = o; }, Hc.lineEnd = function () { n(t, e); }; }\n    function Xe(n, t) { Pc > n && (Pc = n), n > jc && (jc = n), Uc > t && (Uc = t), t > Fc && (Fc = t); }\n    function $e() { function n(n, t) { o.push(\"M\", n, \",\", t, i); } function t(n, t) { o.push(\"M\", n, \",\", t), a.point = e; } function e(n, t) { o.push(\"L\", n, \",\", t); } function r() { a.point = n; } function u() { o.push(\"Z\"); } var i = Be(4.5), o = [], a = { point: n, lineStart: function () { a.point = t; }, lineEnd: r, polygonStart: function () { a.lineEnd = u; }, polygonEnd: function () { a.lineEnd = r, a.point = n; }, pointRadius: function (n) { return i = Be(n), a; }, result: function () { if (o.length) {\n            var n = o.join(\"\");\n            return o = [], n;\n        } } }; return a; }\n    function Be(n) { return \"m0,\" + n + \"a\" + n + \",\" + n + \" 0 1,1 0,\" + -2 * n + \"a\" + n + \",\" + n + \" 0 1,1 0,\" + 2 * n + \"z\"; }\n    function We(n, t) { _c += n, wc += t, ++Sc; }\n    function Je() { function n(n, r) { var u = n - t, i = r - e, o = Math.sqrt(u * u + i * i); kc += o * (t + n) / 2, Ec += o * (e + r) / 2, Ac += o, We(t = n, e = r); } var t, e; Ic.point = function (r, u) { Ic.point = n, We(t = r, e = u); }; }\n    function Ge() { Ic.point = We; }\n    function Ke() { function n(n, t) { var e = n - r, i = t - u, o = Math.sqrt(e * e + i * i); kc += o * (r + n) / 2, Ec += o * (u + t) / 2, Ac += o, o = u * n - r * t, Nc += o * (r + n), Cc += o * (u + t), zc += 3 * o, We(r = n, u = t); } var t, e, r, u; Ic.point = function (i, o) { Ic.point = n, We(t = r = i, e = u = o); }, Ic.lineEnd = function () { n(t, e); }; }\n    function Qe(n) { function t(t, e) { n.moveTo(t + o, e), n.arc(t, e, o, 0, La); } function e(t, e) { n.moveTo(t, e), a.point = r; } function r(t, e) { n.lineTo(t, e); } function u() { a.point = t; } function i() { n.closePath(); } var o = 4.5, a = { point: t, lineStart: function () { a.point = e; }, lineEnd: u, polygonStart: function () { a.lineEnd = i; }, polygonEnd: function () { a.lineEnd = u, a.point = t; }, pointRadius: function (n) { return o = n, a; }, result: b }; return a; }\n    function nr(n) {\n        function t(n) { return (a ? r : e)(n); }\n        function e(t) { return rr(t, function (e, r) { e = n(e, r), t.point(e[0], e[1]); }); }\n        function r(t) {\n            function e(e, r) { e = n(e, r), t.point(e[0], e[1]); }\n            function r() { M = 0 / 0, S.point = i, t.lineStart(); }\n            function i(e, r) { var i = pe([e, r]), o = n(e, r); u(M, x, y, b, _, w, M = o[0], x = o[1], y = e, b = i[0], _ = i[1], w = i[2], a, t), t.point(M, x); }\n            function o() { S.point = e, t.lineEnd(); }\n            function c() { r(), S.point = l, S.lineEnd = s; }\n            function l(n, t) { i(f = n, h = t), g = M, p = x, v = b, d = _, m = w, S.point = i; }\n            function s() { u(M, x, y, b, _, w, g, p, f, v, d, m, a, t), S.lineEnd = o, o(); }\n            var f, h, g, p, v, d, m, y, M, x, b, _, w, S = { point: e, lineStart: r, lineEnd: o, polygonStart: function () {\n                    t.polygonStart(), S.lineStart = c;\n                }, polygonEnd: function () { t.polygonEnd(), S.lineStart = r; } };\n            return S;\n        }\n        function u(t, e, r, a, c, l, s, f, h, g, p, v, d, m) { var y = s - t, M = f - e, x = y * y + M * M; if (x > 4 * i && d--) {\n            var b = a + g, _ = c + p, w = l + v, S = Math.sqrt(b * b + _ * _ + w * w), k = Math.asin(w /= S), E = ga(ga(w) - 1) < Ca || ga(r - h) < Ca ? (r + h) / 2 : Math.atan2(_, b), A = n(E, k), N = A[0], C = A[1], z = N - t, q = C - e, L = M * z - y * q;\n            (L * L / x > i || ga((y * z + M * q) / x - .5) > .3 || o > a * g + c * p + l * v) && (u(t, e, r, a, c, l, N, C, E, b /= S, _ /= S, w, d, m), m.point(N, C), u(N, C, E, b, _, w, s, f, h, g, p, v, d, m));\n        } }\n        var i = .5, o = Math.cos(30 * Da), a = 16;\n        return t.precision = function (n) { return arguments.length ? (a = (i = n * n) > 0 && 16, t) : Math.sqrt(i); }, t;\n    }\n    function tr(n) { var t = nr(function (t, e) { return n([t * Pa, e * Pa]); }); return function (n) { return or(t(n)); }; }\n    function er(n) { this.stream = n; }\n    function rr(n, t) { return { point: t, sphere: function () { n.sphere(); }, lineStart: function () { n.lineStart(); }, lineEnd: function () { n.lineEnd(); }, polygonStart: function () { n.polygonStart(); }, polygonEnd: function () { n.polygonEnd(); } }; }\n    function ur(n) { return ir(function () { return n; })(); }\n    function ir(n) { function t(n) { return n = a(n[0] * Da, n[1] * Da), [n[0] * h + c, l - n[1] * h]; } function e(n) { return n = a.invert((n[0] - c) / h, (l - n[1]) / h), n && [n[0] * Pa, n[1] * Pa]; } function r() { a = Ae(o = lr(m, M, x), i); var n = i(v, d); return c = g - n[0] * h, l = p + n[1] * h, u(); } function u() { return s && (s.valid = !1, s = null), t; } var i, o, a, c, l, s, f = nr(function (n, t) { return n = i(n, t), [n[0] * h + c, l - n[1] * h]; }), h = 150, g = 480, p = 250, v = 0, d = 0, m = 0, M = 0, x = 0, b = Lc, _ = y, w = null, S = null; return t.stream = function (n) { return s && (s.valid = !1), s = or(b(o, f(_(n)))), s.valid = !0, s; }, t.clipAngle = function (n) { return arguments.length ? (b = null == n ? (w = n, Lc) : He((w = +n) * Da), u()) : w; }, t.clipExtent = function (n) { return arguments.length ? (S = n, _ = n ? Ie(n[0][0], n[0][1], n[1][0], n[1][1]) : y, u()) : S; }, t.scale = function (n) { return arguments.length ? (h = +n, r()) : h; }, t.translate = function (n) { return arguments.length ? (g = +n[0], p = +n[1], r()) : [g, p]; }, t.center = function (n) { return arguments.length ? (v = n[0] % 360 * Da, d = n[1] % 360 * Da, r()) : [v * Pa, d * Pa]; }, t.rotate = function (n) { return arguments.length ? (m = n[0] % 360 * Da, M = n[1] % 360 * Da, x = n.length > 2 ? n[2] % 360 * Da : 0, r()) : [m * Pa, M * Pa, x * Pa]; }, ta.rebind(t, f, \"precision\"), function () { return i = n.apply(this, arguments), t.invert = i.invert && e, r(); }; }\n    function or(n) { return rr(n, function (t, e) { n.point(t * Da, e * Da); }); }\n    function ar(n, t) { return [n, t]; }\n    function cr(n, t) { return [n > qa ? n - La : -qa > n ? n + La : n, t]; }\n    function lr(n, t, e) { return n ? t || e ? Ae(fr(n), hr(t, e)) : fr(n) : t || e ? hr(t, e) : cr; }\n    function sr(n) { return function (t, e) { return t += n, [t > qa ? t - La : -qa > t ? t + La : t, e]; }; }\n    function fr(n) { var t = sr(n); return t.invert = sr(-n), t; }\n    function hr(n, t) { function e(n, t) { var e = Math.cos(t), a = Math.cos(n) * e, c = Math.sin(n) * e, l = Math.sin(t), s = l * r + a * u; return [Math.atan2(c * i - s * o, a * r - l * u), tt(s * i + c * o)]; } var r = Math.cos(n), u = Math.sin(n), i = Math.cos(t), o = Math.sin(t); return e.invert = function (n, t) { var e = Math.cos(t), a = Math.cos(n) * e, c = Math.sin(n) * e, l = Math.sin(t), s = l * i - c * o; return [Math.atan2(c * i + l * o, a * r + s * u), tt(s * r - a * u)]; }, e; }\n    function gr(n, t) { var e = Math.cos(n), r = Math.sin(n); return function (u, i, o, a) { var c = o * t; null != u ? (u = pr(e, u), i = pr(e, i), (o > 0 ? i > u : u > i) && (u += o * La)) : (u = n + o * La, i = n - .5 * c); for (var l, s = u; o > 0 ? s > i : i > s; s -= c)\n        a.point((l = xe([e, -r * Math.cos(s), -r * Math.sin(s)]))[0], l[1]); }; }\n    function pr(n, t) { var e = pe(t); e[0] -= n, Me(e); var r = nt(-e[1]); return ((-e[2] < 0 ? -r : r) + 2 * Math.PI - Ca) % (2 * Math.PI); }\n    function vr(n, t, e) { var r = ta.range(n, t - Ca, e).concat(t); return function (n) { return r.map(function (t) { return [n, t]; }); }; }\n    function dr(n, t, e) { var r = ta.range(n, t - Ca, e).concat(t); return function (n) { return r.map(function (t) { return [t, n]; }); }; }\n    function mr(n) { return n.source; }\n    function yr(n) { return n.target; }\n    function Mr(n, t, e, r) { var u = Math.cos(t), i = Math.sin(t), o = Math.cos(r), a = Math.sin(r), c = u * Math.cos(n), l = u * Math.sin(n), s = o * Math.cos(e), f = o * Math.sin(e), h = 2 * Math.asin(Math.sqrt(it(r - t) + u * o * it(e - n))), g = 1 / Math.sin(h), p = h ? function (n) { var t = Math.sin(n *= h) * g, e = Math.sin(h - n) * g, r = e * c + t * s, u = e * l + t * f, o = e * i + t * a; return [Math.atan2(u, r) * Pa, Math.atan2(o, Math.sqrt(r * r + u * u)) * Pa]; } : function () { return [n * Pa, t * Pa]; }; return p.distance = h, p; }\n    function xr() { function n(n, u) { var i = Math.sin(u *= Da), o = Math.cos(u), a = ga((n *= Da) - t), c = Math.cos(a); Yc += Math.atan2(Math.sqrt((a = o * Math.sin(a)) * a + (a = r * i - e * o * c) * a), e * i + r * o * c), t = n, e = i, r = o; } var t, e, r; Zc.point = function (u, i) { t = u * Da, e = Math.sin(i *= Da), r = Math.cos(i), Zc.point = n; }, Zc.lineEnd = function () { Zc.point = Zc.lineEnd = b; }; }\n    function br(n, t) { function e(t, e) { var r = Math.cos(t), u = Math.cos(e), i = n(r * u); return [i * u * Math.sin(t), i * Math.sin(e)]; } return e.invert = function (n, e) { var r = Math.sqrt(n * n + e * e), u = t(r), i = Math.sin(u), o = Math.cos(u); return [Math.atan2(n * i, r * o), Math.asin(r && e * i / r)]; }, e; }\n    function _r(n, t) { function e(n, t) { o > 0 ? -Ra + Ca > t && (t = -Ra + Ca) : t > Ra - Ca && (t = Ra - Ca); var e = o / Math.pow(u(t), i); return [e * Math.sin(i * n), o - e * Math.cos(i * n)]; } var r = Math.cos(n), u = function (n) { return Math.tan(qa / 4 + n / 2); }, i = n === t ? Math.sin(n) : Math.log(r / Math.cos(t)) / Math.log(u(t) / u(n)), o = r * Math.pow(u(n), i) / i; return i ? (e.invert = function (n, t) { var e = o - t, r = K(i) * Math.sqrt(n * n + e * e); return [Math.atan2(n, e) / i, 2 * Math.atan(Math.pow(o / r, 1 / i)) - Ra]; }, e) : Sr; }\n    function wr(n, t) { function e(n, t) { var e = i - t; return [e * Math.sin(u * n), i - e * Math.cos(u * n)]; } var r = Math.cos(n), u = n === t ? Math.sin(n) : (r - Math.cos(t)) / (t - n), i = r / u + n; return ga(u) < Ca ? ar : (e.invert = function (n, t) { var e = i - t; return [Math.atan2(n, e) / u, i - K(u) * Math.sqrt(n * n + e * e)]; }, e); }\n    function Sr(n, t) { return [n, Math.log(Math.tan(qa / 4 + t / 2))]; }\n    function kr(n) { var t, e = ur(n), r = e.scale, u = e.translate, i = e.clipExtent; return e.scale = function () { var n = r.apply(e, arguments); return n === e ? t ? e.clipExtent(null) : e : n; }, e.translate = function () { var n = u.apply(e, arguments); return n === e ? t ? e.clipExtent(null) : e : n; }, e.clipExtent = function (n) { var o = i.apply(e, arguments); if (o === e) {\n        if (t = null == n) {\n            var a = qa * r(), c = u();\n            i([[c[0] - a, c[1] - a], [c[0] + a, c[1] + a]]);\n        }\n    }\n    else\n        t && (o = null); return o; }, e.clipExtent(null); }\n    function Er(n, t) { return [Math.log(Math.tan(qa / 4 + t / 2)), -n]; }\n    function Ar(n) { return n[0]; }\n    function Nr(n) { return n[1]; }\n    function Cr(n) { for (var t = n.length, e = [0, 1], r = 2, u = 2; t > u; u++) {\n        for (; r > 1 && Q(n[e[r - 2]], n[e[r - 1]], n[u]) <= 0;)\n            --r;\n        e[r++] = u;\n    } return e.slice(0, r); }\n    function zr(n, t) { return n[0] - t[0] || n[1] - t[1]; }\n    function qr(n, t, e) { return (e[0] - t[0]) * (n[1] - t[1]) < (e[1] - t[1]) * (n[0] - t[0]); }\n    function Lr(n, t, e, r) { var u = n[0], i = e[0], o = t[0] - u, a = r[0] - i, c = n[1], l = e[1], s = t[1] - c, f = r[1] - l, h = (a * (c - l) - f * (u - i)) / (f * o - a * s); return [u + h * o, c + h * s]; }\n    function Tr(n) { var t = n[0], e = n[n.length - 1]; return !(t[0] - e[0] || t[1] - e[1]); }\n    function Rr() { tu(this), this.edge = this.site = this.circle = null; }\n    function Dr(n) { var t = el.pop() || new Rr; return t.site = n, t; }\n    function Pr(n) { Xr(n), Qc.remove(n), el.push(n), tu(n); }\n    function Ur(n) { var t = n.circle, e = t.x, r = t.cy, u = { x: e, y: r }, i = n.P, o = n.N, a = [n]; Pr(n); for (var c = i; c.circle && ga(e - c.circle.x) < Ca && ga(r - c.circle.cy) < Ca;)\n        i = c.P, a.unshift(c), Pr(c), c = i; a.unshift(c), Xr(c); for (var l = o; l.circle && ga(e - l.circle.x) < Ca && ga(r - l.circle.cy) < Ca;)\n        o = l.N, a.push(l), Pr(l), l = o; a.push(l), Xr(l); var s, f = a.length; for (s = 1; f > s; ++s)\n        l = a[s], c = a[s - 1], Kr(l.edge, c.site, l.site, u); c = a[0], l = a[f - 1], l.edge = Jr(c.site, l.site, null, u), Vr(c), Vr(l); }\n    function jr(n) { for (var t, e, r, u, i = n.x, o = n.y, a = Qc._; a;)\n        if (r = Fr(a, o) - i, r > Ca)\n            a = a.L;\n        else {\n            if (u = i - Hr(a, o), !(u > Ca)) {\n                r > -Ca ? (t = a.P, e = a) : u > -Ca ? (t = a, e = a.N) : t = e = a;\n                break;\n            }\n            if (!a.R) {\n                t = a;\n                break;\n            }\n            a = a.R;\n        } var c = Dr(n); if (Qc.insert(t, c), t || e) {\n        if (t === e)\n            return Xr(t), e = Dr(t.site), Qc.insert(c, e), c.edge = e.edge = Jr(t.site, c.site), Vr(t), void Vr(e);\n        if (!e)\n            return void (c.edge = Jr(t.site, c.site));\n        Xr(t), Xr(e);\n        var l = t.site, s = l.x, f = l.y, h = n.x - s, g = n.y - f, p = e.site, v = p.x - s, d = p.y - f, m = 2 * (h * d - g * v), y = h * h + g * g, M = v * v + d * d, x = { x: (d * y - g * M) / m + s, y: (h * M - v * y) / m + f };\n        Kr(e.edge, l, p, x), c.edge = Jr(l, n, null, x), e.edge = Jr(n, p, null, x), Vr(t), Vr(e);\n    } }\n    function Fr(n, t) { var e = n.site, r = e.x, u = e.y, i = u - t; if (!i)\n        return r; var o = n.P; if (!o)\n        return -1 / 0; e = o.site; var a = e.x, c = e.y, l = c - t; if (!l)\n        return a; var s = a - r, f = 1 / i - 1 / l, h = s / l; return f ? (-h + Math.sqrt(h * h - 2 * f * (s * s / (-2 * l) - c + l / 2 + u - i / 2))) / f + r : (r + a) / 2; }\n    function Hr(n, t) { var e = n.N; if (e)\n        return Fr(e, t); var r = n.site; return r.y === t ? r.x : 1 / 0; }\n    function Or(n) { this.site = n, this.edges = []; }\n    function Ir(n) { for (var t, e, r, u, i, o, a, c, l, s, f = n[0][0], h = n[1][0], g = n[0][1], p = n[1][1], v = Kc, d = v.length; d--;)\n        if (i = v[d], i && i.prepare())\n            for (a = i.edges, c = a.length, o = 0; c > o;)\n                s = a[o].end(), r = s.x, u = s.y, l = a[++o % c].start(), t = l.x, e = l.y, (ga(r - t) > Ca || ga(u - e) > Ca) && (a.splice(o, 0, new Qr(Gr(i.site, s, ga(r - f) < Ca && p - u > Ca ? { x: f, y: ga(t - f) < Ca ? e : p } : ga(u - p) < Ca && h - r > Ca ? { x: ga(e - p) < Ca ? t : h, y: p } : ga(r - h) < Ca && u - g > Ca ? { x: h, y: ga(t - h) < Ca ? e : g } : ga(u - g) < Ca && r - f > Ca ? { x: ga(e - g) < Ca ? t : f, y: g } : null), i.site, null)), ++c); }\n    function Yr(n, t) { return t.angle - n.angle; }\n    function Zr() { tu(this), this.x = this.y = this.arc = this.site = this.cy = null; }\n    function Vr(n) { var t = n.P, e = n.N; if (t && e) {\n        var r = t.site, u = n.site, i = e.site;\n        if (r !== i) {\n            var o = u.x, a = u.y, c = r.x - o, l = r.y - a, s = i.x - o, f = i.y - a, h = 2 * (c * f - l * s);\n            if (!(h >= -za)) {\n                var g = c * c + l * l, p = s * s + f * f, v = (f * g - l * p) / h, d = (c * p - s * g) / h, f = d + a, m = rl.pop() || new Zr;\n                m.arc = n, m.site = u, m.x = v + o, m.y = f + Math.sqrt(v * v + d * d), m.cy = f, n.circle = m;\n                for (var y = null, M = tl._; M;)\n                    if (m.y < M.y || m.y === M.y && m.x <= M.x) {\n                        if (!M.L) {\n                            y = M.P;\n                            break;\n                        }\n                        M = M.L;\n                    }\n                    else {\n                        if (!M.R) {\n                            y = M;\n                            break;\n                        }\n                        M = M.R;\n                    }\n                tl.insert(y, m), y || (nl = m);\n            }\n        }\n    } }\n    function Xr(n) { var t = n.circle; t && (t.P || (nl = t.N), tl.remove(t), rl.push(t), tu(t), n.circle = null); }\n    function $r(n) { for (var t, e = Gc, r = Oe(n[0][0], n[0][1], n[1][0], n[1][1]), u = e.length; u--;)\n        t = e[u], (!Br(t, n) || !r(t) || ga(t.a.x - t.b.x) < Ca && ga(t.a.y - t.b.y) < Ca) && (t.a = t.b = null, e.splice(u, 1)); }\n    function Br(n, t) { var e = n.b; if (e)\n        return !0; var r, u, i = n.a, o = t[0][0], a = t[1][0], c = t[0][1], l = t[1][1], s = n.l, f = n.r, h = s.x, g = s.y, p = f.x, v = f.y, d = (h + p) / 2, m = (g + v) / 2; if (v === g) {\n        if (o > d || d >= a)\n            return;\n        if (h > p) {\n            if (i) {\n                if (i.y >= l)\n                    return;\n            }\n            else\n                i = { x: d, y: c };\n            e = { x: d, y: l };\n        }\n        else {\n            if (i) {\n                if (i.y < c)\n                    return;\n            }\n            else\n                i = { x: d, y: l };\n            e = { x: d, y: c };\n        }\n    }\n    else if (r = (h - p) / (v - g), u = m - r * d, -1 > r || r > 1)\n        if (h > p) {\n            if (i) {\n                if (i.y >= l)\n                    return;\n            }\n            else\n                i = { x: (c - u) / r, y: c };\n            e = { x: (l - u) / r, y: l };\n        }\n        else {\n            if (i) {\n                if (i.y < c)\n                    return;\n            }\n            else\n                i = { x: (l - u) / r, y: l };\n            e = { x: (c - u) / r, y: c };\n        }\n    else if (v > g) {\n        if (i) {\n            if (i.x >= a)\n                return;\n        }\n        else\n            i = { x: o, y: r * o + u };\n        e = { x: a, y: r * a + u };\n    }\n    else {\n        if (i) {\n            if (i.x < o)\n                return;\n        }\n        else\n            i = { x: a, y: r * a + u };\n        e = { x: o, y: r * o + u };\n    } return n.a = i, n.b = e, !0; }\n    function Wr(n, t) { this.l = n, this.r = t, this.a = this.b = null; }\n    function Jr(n, t, e, r) { var u = new Wr(n, t); return Gc.push(u), e && Kr(u, n, t, e), r && Kr(u, t, n, r), Kc[n.i].edges.push(new Qr(u, n, t)), Kc[t.i].edges.push(new Qr(u, t, n)), u; }\n    function Gr(n, t, e) { var r = new Wr(n, null); return r.a = t, r.b = e, Gc.push(r), r; }\n    function Kr(n, t, e, r) { n.a || n.b ? n.l === e ? n.b = r : n.a = r : (n.a = r, n.l = t, n.r = e); }\n    function Qr(n, t, e) { var r = n.a, u = n.b; this.edge = n, this.site = t, this.angle = e ? Math.atan2(e.y - t.y, e.x - t.x) : n.l === t ? Math.atan2(u.x - r.x, r.y - u.y) : Math.atan2(r.x - u.x, u.y - r.y); }\n    function nu() { this._ = null; }\n    function tu(n) { n.U = n.C = n.L = n.R = n.P = n.N = null; }\n    function eu(n, t) { var e = t, r = t.R, u = e.U; u ? u.L === e ? u.L = r : u.R = r : n._ = r, r.U = u, e.U = r, e.R = r.L, e.R && (e.R.U = e), r.L = e; }\n    function ru(n, t) { var e = t, r = t.L, u = e.U; u ? u.L === e ? u.L = r : u.R = r : n._ = r, r.U = u, e.U = r, e.L = r.R, e.L && (e.L.U = e), r.R = e; }\n    function uu(n) { for (; n.L;)\n        n = n.L; return n; }\n    function iu(n, t) { var e, r, u, i = n.sort(ou).pop(); for (Gc = [], Kc = new Array(n.length), Qc = new nu, tl = new nu;;)\n        if (u = nl, i && (!u || i.y < u.y || i.y === u.y && i.x < u.x))\n            (i.x !== e || i.y !== r) && (Kc[i.i] = new Or(i), jr(i), e = i.x, r = i.y), i = n.pop();\n        else {\n            if (!u)\n                break;\n            Ur(u.arc);\n        } t && ($r(t), Ir(t)); var o = { cells: Kc, edges: Gc }; return Qc = tl = Gc = Kc = null, o; }\n    function ou(n, t) { return t.y - n.y || t.x - n.x; }\n    function au(n, t, e) { return (n.x - e.x) * (t.y - n.y) - (n.x - t.x) * (e.y - n.y); }\n    function cu(n) { return n.x; }\n    function lu(n) { return n.y; }\n    function su() { return { leaf: !0, nodes: [], point: null, x: null, y: null }; }\n    function fu(n, t, e, r, u, i) { if (!n(t, e, r, u, i)) {\n        var o = .5 * (e + u), a = .5 * (r + i), c = t.nodes;\n        c[0] && fu(n, c[0], e, r, o, a), c[1] && fu(n, c[1], o, r, u, a), c[2] && fu(n, c[2], e, a, o, i), c[3] && fu(n, c[3], o, a, u, i);\n    } }\n    function hu(n, t, e, r, u, i, o) { var a, c = 1 / 0; return function l(n, s, f, h, g) { if (!(s > i || f > o || r > h || u > g)) {\n        if (p = n.point) {\n            var p, v = t - n.x, d = e - n.y, m = v * v + d * d;\n            if (c > m) {\n                var y = Math.sqrt(c = m);\n                r = t - y, u = e - y, i = t + y, o = e + y, a = p;\n            }\n        }\n        for (var M = n.nodes, x = .5 * (s + h), b = .5 * (f + g), _ = t >= x, w = e >= b, S = w << 1 | _, k = S + 4; k > S; ++S)\n            if (n = M[3 & S])\n                switch (3 & S) {\n                    case 0:\n                        l(n, s, f, x, b);\n                        break;\n                    case 1:\n                        l(n, x, f, h, b);\n                        break;\n                    case 2:\n                        l(n, s, b, x, g);\n                        break;\n                    case 3: l(n, x, b, h, g);\n                }\n    } }(n, r, u, i, o), a; }\n    function gu(n, t) { n = ta.rgb(n), t = ta.rgb(t); var e = n.r, r = n.g, u = n.b, i = t.r - e, o = t.g - r, a = t.b - u; return function (n) { return \"#\" + xt(Math.round(e + i * n)) + xt(Math.round(r + o * n)) + xt(Math.round(u + a * n)); }; }\n    function pu(n, t) { var e, r = {}, u = {}; for (e in n)\n        e in t ? r[e] = mu(n[e], t[e]) : u[e] = n[e]; for (e in t)\n        e in n || (u[e] = t[e]); return function (n) { for (e in r)\n        u[e] = r[e](n); return u; }; }\n    function vu(n, t) { return n = +n, t = +t, function (e) { return n * (1 - e) + t * e; }; }\n    function du(n, t) { var e, r, u, i = il.lastIndex = ol.lastIndex = 0, o = -1, a = [], c = []; for (n += \"\", t += \"\"; (e = il.exec(n)) && (r = ol.exec(t));)\n        (u = r.index) > i && (u = t.slice(i, u), a[o] ? a[o] += u : a[++o] = u), (e = e[0]) === (r = r[0]) ? a[o] ? a[o] += r : a[++o] = r : (a[++o] = null, c.push({ i: o, x: vu(e, r) })), i = ol.lastIndex; return i < t.length && (u = t.slice(i), a[o] ? a[o] += u : a[++o] = u), a.length < 2 ? c[0] ? (t = c[0].x, function (n) { return t(n) + \"\"; }) : function () { return t; } : (t = c.length, function (n) { for (var e, r = 0; t > r; ++r)\n        a[(e = c[r]).i] = e.x(n); return a.join(\"\"); }); }\n    function mu(n, t) { for (var e, r = ta.interpolators.length; --r >= 0 && !(e = ta.interpolators[r](n, t));)\n        ; return e; }\n    function yu(n, t) { var e, r = [], u = [], i = n.length, o = t.length, a = Math.min(n.length, t.length); for (e = 0; a > e; ++e)\n        r.push(mu(n[e], t[e])); for (; i > e; ++e)\n        u[e] = n[e]; for (; o > e; ++e)\n        u[e] = t[e]; return function (n) { for (e = 0; a > e; ++e)\n        u[e] = r[e](n); return u; }; }\n    function Mu(n) { return function (t) { return 0 >= t ? 0 : t >= 1 ? 1 : n(t); }; }\n    function xu(n) { return function (t) { return 1 - n(1 - t); }; }\n    function bu(n) { return function (t) { return .5 * (.5 > t ? n(2 * t) : 2 - n(2 - 2 * t)); }; }\n    function _u(n) { return n * n; }\n    function wu(n) { return n * n * n; }\n    function Su(n) { if (0 >= n)\n        return 0; if (n >= 1)\n        return 1; var t = n * n, e = t * n; return 4 * (.5 > n ? e : 3 * (n - t) + e - .75); }\n    function ku(n) { return function (t) { return Math.pow(t, n); }; }\n    function Eu(n) { return 1 - Math.cos(n * Ra); }\n    function Au(n) { return Math.pow(2, 10 * (n - 1)); }\n    function Nu(n) { return 1 - Math.sqrt(1 - n * n); }\n    function Cu(n, t) { var e; return arguments.length < 2 && (t = .45), arguments.length ? e = t / La * Math.asin(1 / n) : (n = 1, e = t / 4), function (r) { return 1 + n * Math.pow(2, -10 * r) * Math.sin((r - e) * La / t); }; }\n    function zu(n) { return n || (n = 1.70158), function (t) { return t * t * ((n + 1) * t - n); }; }\n    function qu(n) { return 1 / 2.75 > n ? 7.5625 * n * n : 2 / 2.75 > n ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : 2.5 / 2.75 > n ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375; }\n    function Lu(n, t) { n = ta.hcl(n), t = ta.hcl(t); var e = n.h, r = n.c, u = n.l, i = t.h - e, o = t.c - r, a = t.l - u; return isNaN(o) && (o = 0, r = isNaN(r) ? t.c : r), isNaN(i) ? (i = 0, e = isNaN(e) ? t.h : e) : i > 180 ? i -= 360 : -180 > i && (i += 360), function (n) { return st(e + i * n, r + o * n, u + a * n) + \"\"; }; }\n    function Tu(n, t) { n = ta.hsl(n), t = ta.hsl(t); var e = n.h, r = n.s, u = n.l, i = t.h - e, o = t.s - r, a = t.l - u; return isNaN(o) && (o = 0, r = isNaN(r) ? t.s : r), isNaN(i) ? (i = 0, e = isNaN(e) ? t.h : e) : i > 180 ? i -= 360 : -180 > i && (i += 360), function (n) { return ct(e + i * n, r + o * n, u + a * n) + \"\"; }; }\n    function Ru(n, t) { n = ta.lab(n), t = ta.lab(t); var e = n.l, r = n.a, u = n.b, i = t.l - e, o = t.a - r, a = t.b - u; return function (n) { return ht(e + i * n, r + o * n, u + a * n) + \"\"; }; }\n    function Du(n, t) { return t -= n, function (e) { return Math.round(n + t * e); }; }\n    function Pu(n) { var t = [n.a, n.b], e = [n.c, n.d], r = ju(t), u = Uu(t, e), i = ju(Fu(e, t, -u)) || 0; t[0] * e[1] < e[0] * t[1] && (t[0] *= -1, t[1] *= -1, r *= -1, u *= -1), this.rotate = (r ? Math.atan2(t[1], t[0]) : Math.atan2(-e[0], e[1])) * Pa, this.translate = [n.e, n.f], this.scale = [r, i], this.skew = i ? Math.atan2(u, i) * Pa : 0; }\n    function Uu(n, t) { return n[0] * t[0] + n[1] * t[1]; }\n    function ju(n) { var t = Math.sqrt(Uu(n, n)); return t && (n[0] /= t, n[1] /= t), t; }\n    function Fu(n, t, e) { return n[0] += e * t[0], n[1] += e * t[1], n; }\n    function Hu(n, t) { var e, r = [], u = [], i = ta.transform(n), o = ta.transform(t), a = i.translate, c = o.translate, l = i.rotate, s = o.rotate, f = i.skew, h = o.skew, g = i.scale, p = o.scale; return a[0] != c[0] || a[1] != c[1] ? (r.push(\"translate(\", null, \",\", null, \")\"), u.push({ i: 1, x: vu(a[0], c[0]) }, { i: 3, x: vu(a[1], c[1]) })) : r.push(c[0] || c[1] ? \"translate(\" + c + \")\" : \"\"), l != s ? (l - s > 180 ? s += 360 : s - l > 180 && (l += 360), u.push({ i: r.push(r.pop() + \"rotate(\", null, \")\") - 2, x: vu(l, s) })) : s && r.push(r.pop() + \"rotate(\" + s + \")\"), f != h ? u.push({ i: r.push(r.pop() + \"skewX(\", null, \")\") - 2, x: vu(f, h) }) : h && r.push(r.pop() + \"skewX(\" + h + \")\"), g[0] != p[0] || g[1] != p[1] ? (e = r.push(r.pop() + \"scale(\", null, \",\", null, \")\"), u.push({ i: e - 4, x: vu(g[0], p[0]) }, { i: e - 2, x: vu(g[1], p[1]) })) : (1 != p[0] || 1 != p[1]) && r.push(r.pop() + \"scale(\" + p + \")\"), e = u.length, function (n) { for (var t, i = -1; ++i < e;)\n        r[(t = u[i]).i] = t.x(n); return r.join(\"\"); }; }\n    function Ou(n, t) { return t = (t -= n = +n) || 1 / t, function (e) { return (e - n) / t; }; }\n    function Iu(n, t) { return t = (t -= n = +n) || 1 / t, function (e) { return Math.max(0, Math.min(1, (e - n) / t)); }; }\n    function Yu(n) { for (var t = n.source, e = n.target, r = Vu(t, e), u = [t]; t !== r;)\n        t = t.parent, u.push(t); for (var i = u.length; e !== r;)\n        u.splice(i, 0, e), e = e.parent; return u; }\n    function Zu(n) { for (var t = [], e = n.parent; null != e;)\n        t.push(n), n = e, e = e.parent; return t.push(n), t; }\n    function Vu(n, t) { if (n === t)\n        return n; for (var e = Zu(n), r = Zu(t), u = e.pop(), i = r.pop(), o = null; u === i;)\n        o = u, u = e.pop(), i = r.pop(); return o; }\n    function Xu(n) { n.fixed |= 2; }\n    function $u(n) { n.fixed &= -7; }\n    function Bu(n) { n.fixed |= 4, n.px = n.x, n.py = n.y; }\n    function Wu(n) { n.fixed &= -5; }\n    function Ju(n, t, e) { var r = 0, u = 0; if (n.charge = 0, !n.leaf)\n        for (var i, o = n.nodes, a = o.length, c = -1; ++c < a;)\n            i = o[c], null != i && (Ju(i, t, e), n.charge += i.charge, r += i.charge * i.cx, u += i.charge * i.cy); if (n.point) {\n        n.leaf || (n.point.x += Math.random() - .5, n.point.y += Math.random() - .5);\n        var l = t * e[n.point.index];\n        n.charge += n.pointCharge = l, r += l * n.point.x, u += l * n.point.y;\n    } n.cx = r / n.charge, n.cy = u / n.charge; }\n    function Gu(n, t) { return ta.rebind(n, t, \"sort\", \"children\", \"value\"), n.nodes = n, n.links = ri, n; }\n    function Ku(n, t) { for (var e = [n]; null != (n = e.pop());)\n        if (t(n), (u = n.children) && (r = u.length))\n            for (var r, u; --r >= 0;)\n                e.push(u[r]); }\n    function Qu(n, t) { for (var e = [n], r = []; null != (n = e.pop());)\n        if (r.push(n), (i = n.children) && (u = i.length))\n            for (var u, i, o = -1; ++o < u;)\n                e.push(i[o]); for (; null != (n = r.pop());)\n        t(n); }\n    function ni(n) { return n.children; }\n    function ti(n) { return n.value; }\n    function ei(n, t) { return t.value - n.value; }\n    function ri(n) { return ta.merge(n.map(function (n) { return (n.children || []).map(function (t) { return { source: n, target: t }; }); })); }\n    function ui(n) { return n.x; }\n    function ii(n) { return n.y; }\n    function oi(n, t, e) { n.y0 = t, n.y = e; }\n    function ai(n) { return ta.range(n.length); }\n    function ci(n) { for (var t = -1, e = n[0].length, r = []; ++t < e;)\n        r[t] = 0; return r; }\n    function li(n) { for (var t, e = 1, r = 0, u = n[0][1], i = n.length; i > e; ++e)\n        (t = n[e][1]) > u && (r = e, u = t); return r; }\n    function si(n) { return n.reduce(fi, 0); }\n    function fi(n, t) { return n + t[1]; }\n    function hi(n, t) { return gi(n, Math.ceil(Math.log(t.length) / Math.LN2 + 1)); }\n    function gi(n, t) { for (var e = -1, r = +n[0], u = (n[1] - r) / t, i = []; ++e <= t;)\n        i[e] = u * e + r; return i; }\n    function pi(n) { return [ta.min(n), ta.max(n)]; }\n    function vi(n, t) { return n.value - t.value; }\n    function di(n, t) { var e = n._pack_next; n._pack_next = t, t._pack_prev = n, t._pack_next = e, e._pack_prev = t; }\n    function mi(n, t) { n._pack_next = t, t._pack_prev = n; }\n    function yi(n, t) { var e = t.x - n.x, r = t.y - n.y, u = n.r + t.r; return .999 * u * u > e * e + r * r; }\n    function Mi(n) { function t(n) { s = Math.min(n.x - n.r, s), f = Math.max(n.x + n.r, f), h = Math.min(n.y - n.r, h), g = Math.max(n.y + n.r, g); } if ((e = n.children) && (l = e.length)) {\n        var e, r, u, i, o, a, c, l, s = 1 / 0, f = -1 / 0, h = 1 / 0, g = -1 / 0;\n        if (e.forEach(xi), r = e[0], r.x = -r.r, r.y = 0, t(r), l > 1 && (u = e[1], u.x = u.r, u.y = 0, t(u), l > 2))\n            for (i = e[2], wi(r, u, i), t(i), di(r, i), r._pack_prev = i, di(i, u), u = r._pack_next, o = 3; l > o; o++) {\n                wi(r, u, i = e[o]);\n                var p = 0, v = 1, d = 1;\n                for (a = u._pack_next; a !== u; a = a._pack_next, v++)\n                    if (yi(a, i)) {\n                        p = 1;\n                        break;\n                    }\n                if (1 == p)\n                    for (c = r._pack_prev; c !== a._pack_prev && !yi(c, i); c = c._pack_prev, d++)\n                        ;\n                p ? (d > v || v == d && u.r < r.r ? mi(r, u = a) : mi(r = c, u), o--) : (di(r, i), u = i, t(i));\n            }\n        var m = (s + f) / 2, y = (h + g) / 2, M = 0;\n        for (o = 0; l > o; o++)\n            i = e[o], i.x -= m, i.y -= y, M = Math.max(M, i.r + Math.sqrt(i.x * i.x + i.y * i.y));\n        n.r = M, e.forEach(bi);\n    } }\n    function xi(n) { n._pack_next = n._pack_prev = n; }\n    function bi(n) { delete n._pack_next, delete n._pack_prev; }\n    function _i(n, t, e, r) { var u = n.children; if (n.x = t += r * n.x, n.y = e += r * n.y, n.r *= r, u)\n        for (var i = -1, o = u.length; ++i < o;)\n            _i(u[i], t, e, r); }\n    function wi(n, t, e) { var r = n.r + e.r, u = t.x - n.x, i = t.y - n.y; if (r && (u || i)) {\n        var o = t.r + e.r, a = u * u + i * i;\n        o *= o, r *= r;\n        var c = .5 + (r - o) / (2 * a), l = Math.sqrt(Math.max(0, 2 * o * (r + a) - (r -= a) * r - o * o)) / (2 * a);\n        e.x = n.x + c * u + l * i, e.y = n.y + c * i - l * u;\n    }\n    else\n        e.x = n.x + r, e.y = n.y; }\n    function Si(n, t) { return n.parent == t.parent ? 1 : 2; }\n    function ki(n) { var t = n.children; return t.length ? t[0] : n.t; }\n    function Ei(n) { var t, e = n.children; return (t = e.length) ? e[t - 1] : n.t; }\n    function Ai(n, t, e) { var r = e / (t.i - n.i); t.c -= r, t.s += e, n.c += r, t.z += e, t.m += e; }\n    function Ni(n) { for (var t, e = 0, r = 0, u = n.children, i = u.length; --i >= 0;)\n        t = u[i], t.z += e, t.m += e, e += t.s + (r += t.c); }\n    function Ci(n, t, e) { return n.a.parent === t.parent ? n.a : e; }\n    function zi(n) { return 1 + ta.max(n, function (n) { return n.y; }); }\n    function qi(n) { return n.reduce(function (n, t) { return n + t.x; }, 0) / n.length; }\n    function Li(n) { var t = n.children; return t && t.length ? Li(t[0]) : n; }\n    function Ti(n) { var t, e = n.children; return e && (t = e.length) ? Ti(e[t - 1]) : n; }\n    function Ri(n) { return { x: n.x, y: n.y, dx: n.dx, dy: n.dy }; }\n    function Di(n, t) { var e = n.x + t[3], r = n.y + t[0], u = n.dx - t[1] - t[3], i = n.dy - t[0] - t[2]; return 0 > u && (e += u / 2, u = 0), 0 > i && (r += i / 2, i = 0), { x: e, y: r, dx: u, dy: i }; }\n    function Pi(n) { var t = n[0], e = n[n.length - 1]; return e > t ? [t, e] : [e, t]; }\n    function Ui(n) { return n.rangeExtent ? n.rangeExtent() : Pi(n.range()); }\n    function ji(n, t, e, r) { var u = e(n[0], n[1]), i = r(t[0], t[1]); return function (n) { return i(u(n)); }; }\n    function Fi(n, t) { var e, r = 0, u = n.length - 1, i = n[r], o = n[u]; return i > o && (e = r, r = u, u = e, e = i, i = o, o = e), n[r] = t.floor(i), n[u] = t.ceil(o), n; }\n    function Hi(n) { return n ? { floor: function (t) { return Math.floor(t / n) * n; }, ceil: function (t) { return Math.ceil(t / n) * n; } } : ml; }\n    function Oi(n, t, e, r) { var u = [], i = [], o = 0, a = Math.min(n.length, t.length) - 1; for (n[a] < n[0] && (n = n.slice().reverse(), t = t.slice().reverse()); ++o <= a;)\n        u.push(e(n[o - 1], n[o])), i.push(r(t[o - 1], t[o])); return function (t) { var e = ta.bisect(n, t, 1, a) - 1; return i[e](u[e](t)); }; }\n    function Ii(n, t, e, r) { function u() { var u = Math.min(n.length, t.length) > 2 ? Oi : ji, c = r ? Iu : Ou; return o = u(n, t, c, e), a = u(t, n, c, mu), i; } function i(n) { return o(n); } var o, a; return i.invert = function (n) { return a(n); }, i.domain = function (t) { return arguments.length ? (n = t.map(Number), u()) : n; }, i.range = function (n) { return arguments.length ? (t = n, u()) : t; }, i.rangeRound = function (n) { return i.range(n).interpolate(Du); }, i.clamp = function (n) { return arguments.length ? (r = n, u()) : r; }, i.interpolate = function (n) { return arguments.length ? (e = n, u()) : e; }, i.ticks = function (t) { return Xi(n, t); }, i.tickFormat = function (t, e) { return $i(n, t, e); }, i.nice = function (t) { return Zi(n, t), u(); }, i.copy = function () { return Ii(n, t, e, r); }, u(); }\n    function Yi(n, t) { return ta.rebind(n, t, \"range\", \"rangeRound\", \"interpolate\", \"clamp\"); }\n    function Zi(n, t) { return Fi(n, Hi(Vi(n, t)[2])); }\n    function Vi(n, t) { null == t && (t = 10); var e = Pi(n), r = e[1] - e[0], u = Math.pow(10, Math.floor(Math.log(r / t) / Math.LN10)), i = t / r * u; return .15 >= i ? u *= 10 : .35 >= i ? u *= 5 : .75 >= i && (u *= 2), e[0] = Math.ceil(e[0] / u) * u, e[1] = Math.floor(e[1] / u) * u + .5 * u, e[2] = u, e; }\n    function Xi(n, t) { return ta.range.apply(ta, Vi(n, t)); }\n    function $i(n, t, e) { var r = Vi(n, t); if (e) {\n        var u = ic.exec(e);\n        if (u.shift(), \"s\" === u[8]) {\n            var i = ta.formatPrefix(Math.max(ga(r[0]), ga(r[1])));\n            return u[7] || (u[7] = \".\" + Bi(i.scale(r[2]))), u[8] = \"f\", e = ta.format(u.join(\"\")), function (n) { return e(i.scale(n)) + i.symbol; };\n        }\n        u[7] || (u[7] = \".\" + Wi(u[8], r)), e = u.join(\"\");\n    }\n    else\n        e = \",.\" + Bi(r[2]) + \"f\"; return ta.format(e); }\n    function Bi(n) { return -Math.floor(Math.log(n) / Math.LN10 + .01); }\n    function Wi(n, t) { var e = Bi(t[2]); return n in yl ? Math.abs(e - Bi(Math.max(ga(t[0]), ga(t[1])))) + +(\"e\" !== n) : e - 2 * (\"%\" === n); }\n    function Ji(n, t, e, r) { function u(n) { return (e ? Math.log(0 > n ? 0 : n) : -Math.log(n > 0 ? 0 : -n)) / Math.log(t); } function i(n) { return e ? Math.pow(t, n) : -Math.pow(t, -n); } function o(t) { return n(u(t)); } return o.invert = function (t) { return i(n.invert(t)); }, o.domain = function (t) { return arguments.length ? (e = t[0] >= 0, n.domain((r = t.map(Number)).map(u)), o) : r; }, o.base = function (e) { return arguments.length ? (t = +e, n.domain(r.map(u)), o) : t; }, o.nice = function () { var t = Fi(r.map(u), e ? Math : xl); return n.domain(t), r = t.map(i), o; }, o.ticks = function () { var n = Pi(r), o = [], a = n[0], c = n[1], l = Math.floor(u(a)), s = Math.ceil(u(c)), f = t % 1 ? 2 : t; if (isFinite(s - l)) {\n        if (e) {\n            for (; s > l; l++)\n                for (var h = 1; f > h; h++)\n                    o.push(i(l) * h);\n            o.push(i(l));\n        }\n        else\n            for (o.push(i(l)); l++ < s;)\n                for (var h = f - 1; h > 0; h--)\n                    o.push(i(l) * h);\n        for (l = 0; o[l] < a; l++)\n            ;\n        for (s = o.length; o[s - 1] > c; s--)\n            ;\n        o = o.slice(l, s);\n    } return o; }, o.tickFormat = function (n, t) { if (!arguments.length)\n        return Ml; arguments.length < 2 ? t = Ml : \"function\" != typeof t && (t = ta.format(t)); var r, a = Math.max(.1, n / o.ticks().length), c = e ? (r = 1e-12, Math.ceil) : (r = -1e-12, Math.floor); return function (n) { return n / i(c(u(n) + r)) <= a ? t(n) : \"\"; }; }, o.copy = function () { return Ji(n.copy(), t, e, r); }, Yi(o, n); }\n    function Gi(n, t, e) { function r(t) { return n(u(t)); } var u = Ki(t), i = Ki(1 / t); return r.invert = function (t) { return i(n.invert(t)); }, r.domain = function (t) { return arguments.length ? (n.domain((e = t.map(Number)).map(u)), r) : e; }, r.ticks = function (n) { return Xi(e, n); }, r.tickFormat = function (n, t) { return $i(e, n, t); }, r.nice = function (n) { return r.domain(Zi(e, n)); }, r.exponent = function (o) { return arguments.length ? (u = Ki(t = o), i = Ki(1 / t), n.domain(e.map(u)), r) : t; }, r.copy = function () { return Gi(n.copy(), t, e); }, Yi(r, n); }\n    function Ki(n) { return function (t) { return 0 > t ? -Math.pow(-t, n) : Math.pow(t, n); }; }\n    function Qi(n, t) { function e(e) { return i[((u.get(e) || (\"range\" === t.t ? u.set(e, n.push(e)) : 0 / 0)) - 1) % i.length]; } function r(t, e) { return ta.range(n.length).map(function (n) { return t + e * n; }); } var u, i, o; return e.domain = function (r) { if (!arguments.length)\n        return n; n = [], u = new l; for (var i, o = -1, a = r.length; ++o < a;)\n        u.has(i = r[o]) || u.set(i, n.push(i)); return e[t.t].apply(e, t.a); }, e.range = function (n) { return arguments.length ? (i = n, o = 0, t = { t: \"range\", a: arguments }, e) : i; }, e.rangePoints = function (u, a) { arguments.length < 2 && (a = 0); var c = u[0], l = u[1], s = n.length < 2 ? (c = (c + l) / 2, 0) : (l - c) / (n.length - 1 + a); return i = r(c + s * a / 2, s), o = 0, t = { t: \"rangePoints\", a: arguments }, e; }, e.rangeRoundPoints = function (u, a) { arguments.length < 2 && (a = 0); var c = u[0], l = u[1], s = n.length < 2 ? (c = l = Math.round((c + l) / 2), 0) : (l - c) / (n.length - 1 + a) | 0; return i = r(c + Math.round(s * a / 2 + (l - c - (n.length - 1 + a) * s) / 2), s), o = 0, t = { t: \"rangeRoundPoints\", a: arguments }, e; }, e.rangeBands = function (u, a, c) { arguments.length < 2 && (a = 0), arguments.length < 3 && (c = a); var l = u[1] < u[0], s = u[l - 0], f = u[1 - l], h = (f - s) / (n.length - a + 2 * c); return i = r(s + h * c, h), l && i.reverse(), o = h * (1 - a), t = { t: \"rangeBands\", a: arguments }, e; }, e.rangeRoundBands = function (u, a, c) { arguments.length < 2 && (a = 0), arguments.length < 3 && (c = a); var l = u[1] < u[0], s = u[l - 0], f = u[1 - l], h = Math.floor((f - s) / (n.length - a + 2 * c)); return i = r(s + Math.round((f - s - (n.length - a) * h) / 2), h), l && i.reverse(), o = Math.round(h * (1 - a)), t = { t: \"rangeRoundBands\", a: arguments }, e; }, e.rangeBand = function () { return o; }, e.rangeExtent = function () { return Pi(t.a[0]); }, e.copy = function () { return Qi(n, t); }, e.domain(n); }\n    function no(n, t) { function i() { var e = 0, r = t.length; for (a = []; ++e < r;)\n        a[e - 1] = ta.quantile(n, e / r); return o; } function o(n) { return isNaN(n = +n) ? void 0 : t[ta.bisect(a, n)]; } var a; return o.domain = function (t) { return arguments.length ? (n = t.map(r).filter(u).sort(e), i()) : n; }, o.range = function (n) { return arguments.length ? (t = n, i()) : t; }, o.quantiles = function () { return a; }, o.invertExtent = function (e) { return e = t.indexOf(e), 0 > e ? [0 / 0, 0 / 0] : [e > 0 ? a[e - 1] : n[0], e < a.length ? a[e] : n[n.length - 1]]; }, o.copy = function () { return no(n, t); }, i(); }\n    function to(n, t, e) { function r(t) { return e[Math.max(0, Math.min(o, Math.floor(i * (t - n))))]; } function u() { return i = e.length / (t - n), o = e.length - 1, r; } var i, o; return r.domain = function (e) { return arguments.length ? (n = +e[0], t = +e[e.length - 1], u()) : [n, t]; }, r.range = function (n) { return arguments.length ? (e = n, u()) : e; }, r.invertExtent = function (t) { return t = e.indexOf(t), t = 0 > t ? 0 / 0 : t / i + n, [t, t + 1 / i]; }, r.copy = function () { return to(n, t, e); }, u(); }\n    function eo(n, t) { function e(e) { return e >= e ? t[ta.bisect(n, e)] : void 0; } return e.domain = function (t) { return arguments.length ? (n = t, e) : n; }, e.range = function (n) { return arguments.length ? (t = n, e) : t; }, e.invertExtent = function (e) { return e = t.indexOf(e), [n[e - 1], n[e]]; }, e.copy = function () { return eo(n, t); }, e; }\n    function ro(n) { function t(n) { return +n; } return t.invert = t, t.domain = t.range = function (e) { return arguments.length ? (n = e.map(t), t) : n; }, t.ticks = function (t) { return Xi(n, t); }, t.tickFormat = function (t, e) { return $i(n, t, e); }, t.copy = function () { return ro(n); }, t; }\n    function uo() { return 0; }\n    function io(n) { return n.innerRadius; }\n    function oo(n) { return n.outerRadius; }\n    function ao(n) { return n.startAngle; }\n    function co(n) { return n.endAngle; }\n    function lo(n) { return n && n.padAngle; }\n    function so(n, t, e, r) { return (n - e) * t - (t - r) * n > 0 ? 0 : 1; }\n    function fo(n, t, e, r, u) { var i = n[0] - t[0], o = n[1] - t[1], a = (u ? r : -r) / Math.sqrt(i * i + o * o), c = a * o, l = -a * i, s = n[0] + c, f = n[1] + l, h = t[0] + c, g = t[1] + l, p = (s + h) / 2, v = (f + g) / 2, d = h - s, m = g - f, y = d * d + m * m, M = e - r, x = s * g - h * f, b = (0 > m ? -1 : 1) * Math.sqrt(M * M * y - x * x), _ = (x * m - d * b) / y, w = (-x * d - m * b) / y, S = (x * m + d * b) / y, k = (-x * d + m * b) / y, E = _ - p, A = w - v, N = S - p, C = k - v; return E * E + A * A > N * N + C * C && (_ = S, w = k), [[_ - c, w - l], [_ * e / M, w * e / M]]; }\n    function ho(n) { function t(t) { function o() { l.push(\"M\", i(n(s), a)); } for (var c, l = [], s = [], f = -1, h = t.length, g = Et(e), p = Et(r); ++f < h;)\n        u.call(this, c = t[f], f) ? s.push([+g.call(this, c, f), +p.call(this, c, f)]) : s.length && (o(), s = []); return s.length && o(), l.length ? l.join(\"\") : null; } var e = Ar, r = Nr, u = Ne, i = go, o = i.key, a = .7; return t.x = function (n) { return arguments.length ? (e = n, t) : e; }, t.y = function (n) { return arguments.length ? (r = n, t) : r; }, t.defined = function (n) { return arguments.length ? (u = n, t) : u; }, t.interpolate = function (n) { return arguments.length ? (o = \"function\" == typeof n ? i = n : (i = El.get(n) || go).key, t) : o; }, t.tension = function (n) { return arguments.length ? (a = n, t) : a; }, t; }\n    function go(n) { return n.join(\"L\"); }\n    function po(n) { return go(n) + \"Z\"; }\n    function vo(n) { for (var t = 0, e = n.length, r = n[0], u = [r[0], \",\", r[1]]; ++t < e;)\n        u.push(\"H\", (r[0] + (r = n[t])[0]) / 2, \"V\", r[1]); return e > 1 && u.push(\"H\", r[0]), u.join(\"\"); }\n    function mo(n) { for (var t = 0, e = n.length, r = n[0], u = [r[0], \",\", r[1]]; ++t < e;)\n        u.push(\"V\", (r = n[t])[1], \"H\", r[0]); return u.join(\"\"); }\n    function yo(n) { for (var t = 0, e = n.length, r = n[0], u = [r[0], \",\", r[1]]; ++t < e;)\n        u.push(\"H\", (r = n[t])[0], \"V\", r[1]); return u.join(\"\"); }\n    function Mo(n, t) { return n.length < 4 ? go(n) : n[1] + _o(n.slice(1, -1), wo(n, t)); }\n    function xo(n, t) { return n.length < 3 ? go(n) : n[0] + _o((n.push(n[0]), n), wo([n[n.length - 2]].concat(n, [n[1]]), t)); }\n    function bo(n, t) { return n.length < 3 ? go(n) : n[0] + _o(n, wo(n, t)); }\n    function _o(n, t) { if (t.length < 1 || n.length != t.length && n.length != t.length + 2)\n        return go(n); var e = n.length != t.length, r = \"\", u = n[0], i = n[1], o = t[0], a = o, c = 1; if (e && (r += \"Q\" + (i[0] - 2 * o[0] / 3) + \",\" + (i[1] - 2 * o[1] / 3) + \",\" + i[0] + \",\" + i[1], u = n[1], c = 2), t.length > 1) {\n        a = t[1], i = n[c], c++, r += \"C\" + (u[0] + o[0]) + \",\" + (u[1] + o[1]) + \",\" + (i[0] - a[0]) + \",\" + (i[1] - a[1]) + \",\" + i[0] + \",\" + i[1];\n        for (var l = 2; l < t.length; l++, c++)\n            i = n[c], a = t[l], r += \"S\" + (i[0] - a[0]) + \",\" + (i[1] - a[1]) + \",\" + i[0] + \",\" + i[1];\n    } if (e) {\n        var s = n[c];\n        r += \"Q\" + (i[0] + 2 * a[0] / 3) + \",\" + (i[1] + 2 * a[1] / 3) + \",\" + s[0] + \",\" + s[1];\n    } return r; }\n    function wo(n, t) { for (var e, r = [], u = (1 - t) / 2, i = n[0], o = n[1], a = 1, c = n.length; ++a < c;)\n        e = i, i = o, o = n[a], r.push([u * (o[0] - e[0]), u * (o[1] - e[1])]); return r; }\n    function So(n) { if (n.length < 3)\n        return go(n); var t = 1, e = n.length, r = n[0], u = r[0], i = r[1], o = [u, u, u, (r = n[1])[0]], a = [i, i, i, r[1]], c = [u, \",\", i, \"L\", No(Cl, o), \",\", No(Cl, a)]; for (n.push(n[e - 1]); ++t <= e;)\n        r = n[t], o.shift(), o.push(r[0]), a.shift(), a.push(r[1]), Co(c, o, a); return n.pop(), c.push(\"L\", r), c.join(\"\"); }\n    function ko(n) { if (n.length < 4)\n        return go(n); for (var t, e = [], r = -1, u = n.length, i = [0], o = [0]; ++r < 3;)\n        t = n[r], i.push(t[0]), o.push(t[1]); for (e.push(No(Cl, i) + \",\" + No(Cl, o)), --r; ++r < u;)\n        t = n[r], i.shift(), i.push(t[0]), o.shift(), o.push(t[1]), Co(e, i, o); return e.join(\"\"); }\n    function Eo(n) { for (var t, e, r = -1, u = n.length, i = u + 4, o = [], a = []; ++r < 4;)\n        e = n[r % u], o.push(e[0]), a.push(e[1]); for (t = [No(Cl, o), \",\", No(Cl, a)], --r; ++r < i;)\n        e = n[r % u], o.shift(), o.push(e[0]), a.shift(), a.push(e[1]), Co(t, o, a); return t.join(\"\"); }\n    function Ao(n, t) { var e = n.length - 1; if (e)\n        for (var r, u, i = n[0][0], o = n[0][1], a = n[e][0] - i, c = n[e][1] - o, l = -1; ++l <= e;)\n            r = n[l], u = l / e, r[0] = t * r[0] + (1 - t) * (i + u * a), r[1] = t * r[1] + (1 - t) * (o + u * c); return So(n); }\n    function No(n, t) { return n[0] * t[0] + n[1] * t[1] + n[2] * t[2] + n[3] * t[3]; }\n    function Co(n, t, e) { n.push(\"C\", No(Al, t), \",\", No(Al, e), \",\", No(Nl, t), \",\", No(Nl, e), \",\", No(Cl, t), \",\", No(Cl, e)); }\n    function zo(n, t) { return (t[1] - n[1]) / (t[0] - n[0]); }\n    function qo(n) { for (var t = 0, e = n.length - 1, r = [], u = n[0], i = n[1], o = r[0] = zo(u, i); ++t < e;)\n        r[t] = (o + (o = zo(u = i, i = n[t + 1]))) / 2; return r[t] = o, r; }\n    function Lo(n) { for (var t, e, r, u, i = [], o = qo(n), a = -1, c = n.length - 1; ++a < c;)\n        t = zo(n[a], n[a + 1]), ga(t) < Ca ? o[a] = o[a + 1] = 0 : (e = o[a] / t, r = o[a + 1] / t, u = e * e + r * r, u > 9 && (u = 3 * t / Math.sqrt(u), o[a] = u * e, o[a + 1] = u * r)); for (a = -1; ++a <= c;)\n        u = (n[Math.min(c, a + 1)][0] - n[Math.max(0, a - 1)][0]) / (6 * (1 + o[a] * o[a])), i.push([u || 0, o[a] * u || 0]); return i; }\n    function To(n) { return n.length < 3 ? go(n) : n[0] + _o(n, Lo(n)); }\n    function Ro(n) { for (var t, e, r, u = -1, i = n.length; ++u < i;)\n        t = n[u], e = t[0], r = t[1] - Ra, t[0] = e * Math.cos(r), t[1] = e * Math.sin(r); return n; }\n    function Do(n) {\n        function t(t) { function c() { v.push(\"M\", a(n(m), f), s, l(n(d.reverse()), f), \"Z\"); } for (var h, g, p, v = [], d = [], m = [], y = -1, M = t.length, x = Et(e), b = Et(u), _ = e === r ? function () { return g; } : Et(r), w = u === i ? function () { return p; } : Et(i); ++y < M;)\n            o.call(this, h = t[y], y) ? (d.push([g = +x.call(this, h, y), p = +b.call(this, h, y)]), m.push([+_.call(this, h, y), +w.call(this, h, y)])) : d.length && (c(), d = [], m = []); return d.length && c(), v.length ? v.join(\"\") : null; }\n        var e = Ar, r = Ar, u = 0, i = Nr, o = Ne, a = go, c = a.key, l = a, s = \"L\", f = .7;\n        return t.x = function (n) { return arguments.length ? (e = r = n, t) : r; }, t.x0 = function (n) { return arguments.length ? (e = n, t) : e; }, t.x1 = function (n) {\n            return arguments.length ? (r = n, t) : r;\n        }, t.y = function (n) { return arguments.length ? (u = i = n, t) : i; }, t.y0 = function (n) { return arguments.length ? (u = n, t) : u; }, t.y1 = function (n) { return arguments.length ? (i = n, t) : i; }, t.defined = function (n) { return arguments.length ? (o = n, t) : o; }, t.interpolate = function (n) { return arguments.length ? (c = \"function\" == typeof n ? a = n : (a = El.get(n) || go).key, l = a.reverse || a, s = a.closed ? \"M\" : \"L\", t) : c; }, t.tension = function (n) { return arguments.length ? (f = n, t) : f; }, t;\n    }\n    function Po(n) { return n.radius; }\n    function Uo(n) { return [n.x, n.y]; }\n    function jo(n) { return function () { var t = n.apply(this, arguments), e = t[0], r = t[1] - Ra; return [e * Math.cos(r), e * Math.sin(r)]; }; }\n    function Fo() { return 64; }\n    function Ho() { return \"circle\"; }\n    function Oo(n) { var t = Math.sqrt(n / qa); return \"M0,\" + t + \"A\" + t + \",\" + t + \" 0 1,1 0,\" + -t + \"A\" + t + \",\" + t + \" 0 1,1 0,\" + t + \"Z\"; }\n    function Io(n) { return function () { var t, e; (t = this[n]) && (e = t[t.active]) && (--t.count ? delete t[t.active] : delete this[n], t.active += .5, e.event && e.event.interrupt.call(this, this.__data__, e.index)); }; }\n    function Yo(n, t, e) { return ya(n, Pl), n.namespace = t, n.id = e, n; }\n    function Zo(n, t, e, r) { var u = n.id, i = n.namespace; return Y(n, \"function\" == typeof e ? function (n, o, a) { n[i][u].tween.set(t, r(e.call(n, n.__data__, o, a))); } : (e = r(e), function (n) { n[i][u].tween.set(t, e); })); }\n    function Vo(n) { return null == n && (n = \"\"), function () { this.textContent = n; }; }\n    function Xo(n) { return null == n ? \"__transition__\" : \"__transition_\" + n + \"__\"; }\n    function $o(n, t, e, r, u) { var i = n[e] || (n[e] = { active: 0, count: 0 }), o = i[r]; if (!o) {\n        var a = u.time;\n        o = i[r] = { tween: new l, time: a, delay: u.delay, duration: u.duration, ease: u.ease, index: t }, u = null, ++i.count, ta.timer(function (u) { function c(e) { if (i.active > r)\n            return s(); var u = i[i.active]; u && (--i.count, delete i[i.active], u.event && u.event.interrupt.call(n, n.__data__, u.index)), i.active = r, o.event && o.event.start.call(n, n.__data__, t), o.tween.forEach(function (e, r) { (r = r.call(n, n.__data__, t)) && v.push(r); }), h = o.ease, f = o.duration, ta.timer(function () { return p.c = l(e || 1) ? Ne : l, 1; }, 0, a); } function l(e) { if (i.active !== r)\n            return 1; for (var u = e / f, a = h(u), c = v.length; c > 0;)\n            v[--c].call(n, a); return u >= 1 ? (o.event && o.event.end.call(n, n.__data__, t), s()) : void 0; } function s() { return --i.count ? delete i[r] : delete n[e], 1; } var f, h, g = o.delay, p = ec, v = []; return p.t = g + a, u >= g ? c(u - g) : void (p.c = c); }, 0, a);\n    } }\n    function Bo(n, t, e) { n.attr(\"transform\", function (n) { var r = t(n); return \"translate(\" + (isFinite(r) ? r : e(n)) + \",0)\"; }); }\n    function Wo(n, t, e) { n.attr(\"transform\", function (n) { var r = t(n); return \"translate(0,\" + (isFinite(r) ? r : e(n)) + \")\"; }); }\n    function Jo(n) { return n.toISOString(); }\n    function Go(n, t, e) { function r(t) { return n(t); } function u(n, e) { var r = n[1] - n[0], u = r / e, i = ta.bisect(Vl, u); return i == Vl.length ? [t.year, Vi(n.map(function (n) { return n / 31536e6; }), e)[2]] : i ? t[u / Vl[i - 1] < Vl[i] / u ? i - 1 : i] : [Bl, Vi(n, e)[2]]; } return r.invert = function (t) { return Ko(n.invert(t)); }, r.domain = function (t) { return arguments.length ? (n.domain(t), r) : n.domain().map(Ko); }, r.nice = function (n, t) { function e(e) { return !isNaN(e) && !n.range(e, Ko(+e + 1), t).length; } var i = r.domain(), o = Pi(i), a = null == n ? u(o, 10) : \"number\" == typeof n && u(o, n); return a && (n = a[0], t = a[1]), r.domain(Fi(i, t > 1 ? { floor: function (t) { for (; e(t = n.floor(t));)\n            t = Ko(t - 1); return t; }, ceil: function (t) { for (; e(t = n.ceil(t));)\n            t = Ko(+t + 1); return t; } } : n)); }, r.ticks = function (n, t) { var e = Pi(r.domain()), i = null == n ? u(e, 10) : \"number\" == typeof n ? u(e, n) : !n.range && [{ range: n }, t]; return i && (n = i[0], t = i[1]), n.range(e[0], Ko(+e[1] + 1), 1 > t ? 1 : t); }, r.tickFormat = function () { return e; }, r.copy = function () { return Go(n.copy(), t, e); }, Yi(r, n); }\n    function Ko(n) { return new Date(n); }\n    function Qo(n) { return JSON.parse(n.responseText); }\n    function na(n) { var t = ua.createRange(); return t.selectNode(ua.body), t.createContextualFragment(n.responseText); }\n    var ta = { version: \"3.5.5\" }, ea = [].slice, ra = function (n) { return ea.call(n); }, ua = this.document;\n    if (ua)\n        try {\n            ra(ua.documentElement.childNodes)[0].nodeType;\n        }\n        catch (ia) {\n            ra = function (n) { for (var t = n.length, e = new Array(t); t--;)\n                e[t] = n[t]; return e; };\n        }\n    if (Date.now || (Date.now = function () { return +new Date; }), ua)\n        try {\n            ua.createElement(\"DIV\").style.setProperty(\"opacity\", 0, \"\");\n        }\n        catch (oa) {\n            var aa = this.Element.prototype, ca = aa.setAttribute, la = aa.setAttributeNS, sa = this.CSSStyleDeclaration.prototype, fa = sa.setProperty;\n            aa.setAttribute = function (n, t) { ca.call(this, n, t + \"\"); }, aa.setAttributeNS = function (n, t, e) { la.call(this, n, t, e + \"\"); }, sa.setProperty = function (n, t, e) { fa.call(this, n, t + \"\", e); };\n        }\n    ta.ascending = e, ta.descending = function (n, t) { return n > t ? -1 : t > n ? 1 : t >= n ? 0 : 0 / 0; }, ta.min = function (n, t) { var e, r, u = -1, i = n.length; if (1 === arguments.length) {\n        for (; ++u < i;)\n            if (null != (r = n[u]) && r >= r) {\n                e = r;\n                break;\n            }\n        for (; ++u < i;)\n            null != (r = n[u]) && e > r && (e = r);\n    }\n    else {\n        for (; ++u < i;)\n            if (null != (r = t.call(n, n[u], u)) && r >= r) {\n                e = r;\n                break;\n            }\n        for (; ++u < i;)\n            null != (r = t.call(n, n[u], u)) && e > r && (e = r);\n    } return e; }, ta.max = function (n, t) { var e, r, u = -1, i = n.length; if (1 === arguments.length) {\n        for (; ++u < i;)\n            if (null != (r = n[u]) && r >= r) {\n                e = r;\n                break;\n            }\n        for (; ++u < i;)\n            null != (r = n[u]) && r > e && (e = r);\n    }\n    else {\n        for (; ++u < i;)\n            if (null != (r = t.call(n, n[u], u)) && r >= r) {\n                e = r;\n                break;\n            }\n        for (; ++u < i;)\n            null != (r = t.call(n, n[u], u)) && r > e && (e = r);\n    } return e; }, ta.extent = function (n, t) { var e, r, u, i = -1, o = n.length; if (1 === arguments.length) {\n        for (; ++i < o;)\n            if (null != (r = n[i]) && r >= r) {\n                e = u = r;\n                break;\n            }\n        for (; ++i < o;)\n            null != (r = n[i]) && (e > r && (e = r), r > u && (u = r));\n    }\n    else {\n        for (; ++i < o;)\n            if (null != (r = t.call(n, n[i], i)) && r >= r) {\n                e = u = r;\n                break;\n            }\n        for (; ++i < o;)\n            null != (r = t.call(n, n[i], i)) && (e > r && (e = r), r > u && (u = r));\n    } return [e, u]; }, ta.sum = function (n, t) { var e, r = 0, i = n.length, o = -1; if (1 === arguments.length)\n        for (; ++o < i;)\n            u(e = +n[o]) && (r += e);\n    else\n        for (; ++o < i;)\n            u(e = +t.call(n, n[o], o)) && (r += e); return r; }, ta.mean = function (n, t) { var e, i = 0, o = n.length, a = -1, c = o; if (1 === arguments.length)\n        for (; ++a < o;)\n            u(e = r(n[a])) ? i += e : --c;\n    else\n        for (; ++a < o;)\n            u(e = r(t.call(n, n[a], a))) ? i += e : --c; return c ? i / c : void 0; }, ta.quantile = function (n, t) { var e = (n.length - 1) * t + 1, r = Math.floor(e), u = +n[r - 1], i = e - r; return i ? u + i * (n[r] - u) : u; }, ta.median = function (n, t) { var i, o = [], a = n.length, c = -1; if (1 === arguments.length)\n        for (; ++c < a;)\n            u(i = r(n[c])) && o.push(i);\n    else\n        for (; ++c < a;)\n            u(i = r(t.call(n, n[c], c))) && o.push(i); return o.length ? ta.quantile(o.sort(e), .5) : void 0; }, ta.variance = function (n, t) { var e, i, o = n.length, a = 0, c = 0, l = -1, s = 0; if (1 === arguments.length)\n        for (; ++l < o;)\n            u(e = r(n[l])) && (i = e - a, a += i / ++s, c += i * (e - a));\n    else\n        for (; ++l < o;)\n            u(e = r(t.call(n, n[l], l))) && (i = e - a, a += i / ++s, c += i * (e - a)); return s > 1 ? c / (s - 1) : void 0; }, ta.deviation = function () { var n = ta.variance.apply(this, arguments); return n ? Math.sqrt(n) : n; };\n    var ha = i(e);\n    ta.bisectLeft = ha.left, ta.bisect = ta.bisectRight = ha.right, ta.bisector = function (n) { return i(1 === n.length ? function (t, r) { return e(n(t), r); } : n); }, ta.shuffle = function (n, t, e) { (i = arguments.length) < 3 && (e = n.length, 2 > i && (t = 0)); for (var r, u, i = e - t; i;)\n        u = Math.random() * i-- | 0, r = n[i + t], n[i + t] = n[u + t], n[u + t] = r; return n; }, ta.permute = function (n, t) { for (var e = t.length, r = new Array(e); e--;)\n        r[e] = n[t[e]]; return r; }, ta.pairs = function (n) { for (var t, e = 0, r = n.length - 1, u = n[0], i = new Array(0 > r ? 0 : r); r > e;)\n        i[e] = [t = u, u = n[++e]]; return i; }, ta.zip = function () { if (!(r = arguments.length))\n        return []; for (var n = -1, t = ta.min(arguments, o), e = new Array(t); ++n < t;)\n        for (var r, u = -1, i = e[n] = new Array(r); ++u < r;)\n            i[u] = arguments[u][n]; return e; }, ta.transpose = function (n) { return ta.zip.apply(ta, n); }, ta.keys = function (n) { var t = []; for (var e in n)\n        t.push(e); return t; }, ta.values = function (n) { var t = []; for (var e in n)\n        t.push(n[e]); return t; }, ta.entries = function (n) { var t = []; for (var e in n)\n        t.push({ key: e, value: n[e] }); return t; }, ta.merge = function (n) { for (var t, e, r, u = n.length, i = -1, o = 0; ++i < u;)\n        o += n[i].length; for (e = new Array(o); --u >= 0;)\n        for (r = n[u], t = r.length; --t >= 0;)\n            e[--o] = r[t]; return e; };\n    var ga = Math.abs;\n    ta.range = function (n, t, e) { if (arguments.length < 3 && (e = 1, arguments.length < 2 && (t = n, n = 0)), (t - n) / e === 1 / 0)\n        throw new Error(\"infinite range\"); var r, u = [], i = a(ga(e)), o = -1; if (n *= i, t *= i, e *= i, 0 > e)\n        for (; (r = n + e * ++o) > t;)\n            u.push(r / i);\n    else\n        for (; (r = n + e * ++o) < t;)\n            u.push(r / i); return u; }, ta.map = function (n, t) { var e = new l; if (n instanceof l)\n        n.forEach(function (n, t) { e.set(n, t); });\n    else if (Array.isArray(n)) {\n        var r, u = -1, i = n.length;\n        if (1 === arguments.length)\n            for (; ++u < i;)\n                e.set(u, n[u]);\n        else\n            for (; ++u < i;)\n                e.set(t.call(n, r = n[u], u), r);\n    }\n    else\n        for (var o in n)\n            e.set(o, n[o]); return e; };\n    var pa = \"__proto__\", va = \"\\x00\";\n    c(l, { has: h, get: function (n) { return this._[s(n)]; }, set: function (n, t) { return this._[s(n)] = t; }, remove: g, keys: p, values: function () { var n = []; for (var t in this._)\n            n.push(this._[t]); return n; }, entries: function () { var n = []; for (var t in this._)\n            n.push({ key: f(t), value: this._[t] }); return n; }, size: v, empty: d, forEach: function (n) { for (var t in this._)\n            n.call(this, f(t), this._[t]); } }), ta.nest = function () { function n(t, o, a) { if (a >= i.length)\n        return r ? r.call(u, o) : e ? o.sort(e) : o; for (var c, s, f, h, g = -1, p = o.length, v = i[a++], d = new l; ++g < p;)\n        (h = d.get(c = v(s = o[g]))) ? h.push(s) : d.set(c, [s]); return t ? (s = t(), f = function (e, r) { s.set(e, n(t, r, a)); }) : (s = {}, f = function (e, r) { s[e] = n(t, r, a); }), d.forEach(f), s; } function t(n, e) { if (e >= i.length)\n        return n; var r = [], u = o[e++]; return n.forEach(function (n, u) { r.push({ key: n, values: t(u, e) }); }), u ? r.sort(function (n, t) { return u(n.key, t.key); }) : r; } var e, r, u = {}, i = [], o = []; return u.map = function (t, e) { return n(e, t, 0); }, u.entries = function (e) { return t(n(ta.map, e, 0), 0); }, u.key = function (n) { return i.push(n), u; }, u.sortKeys = function (n) { return o[i.length - 1] = n, u; }, u.sortValues = function (n) { return e = n, u; }, u.rollup = function (n) { return r = n, u; }, u; }, ta.set = function (n) { var t = new m; if (n)\n        for (var e = 0, r = n.length; r > e; ++e)\n            t.add(n[e]); return t; }, c(m, { has: h, add: function (n) { return this._[s(n += \"\")] = !0, n; }, remove: g, values: p, size: v, empty: d, forEach: function (n) { for (var t in this._)\n            n.call(this, f(t)); } }), ta.behavior = {}, ta.rebind = function (n, t) { for (var e, r = 1, u = arguments.length; ++r < u;)\n        n[e = arguments[r]] = M(n, t, t[e]); return n; };\n    var da = [\"webkit\", \"ms\", \"moz\", \"Moz\", \"o\", \"O\"];\n    ta.dispatch = function () { for (var n = new _, t = -1, e = arguments.length; ++t < e;)\n        n[arguments[t]] = w(n); return n; }, _.prototype.on = function (n, t) { var e = n.indexOf(\".\"), r = \"\"; if (e >= 0 && (r = n.slice(e + 1), n = n.slice(0, e)), n)\n        return arguments.length < 2 ? this[n].on(r) : this[n].on(r, t); if (2 === arguments.length) {\n        if (null == t)\n            for (n in this)\n                this.hasOwnProperty(n) && this[n].on(r, null);\n        return this;\n    } }, ta.event = null, ta.requote = function (n) { return n.replace(ma, \"\\\\$&\"); };\n    var ma = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g, ya = {}.__proto__ ? function (n, t) { n.__proto__ = t; } : function (n, t) { for (var e in t)\n        n[e] = t[e]; }, Ma = function (n, t) { return t.querySelector(n); }, xa = function (n, t) { return t.querySelectorAll(n); }, ba = function (n, t) { var e = n.matches || n[x(n, \"matchesSelector\")]; return (ba = function (n, t) { return e.call(n, t); })(n, t); };\n    \"function\" == typeof Sizzle && (Ma = function (n, t) { return Sizzle(n, t)[0] || null; }, xa = Sizzle, ba = Sizzle.matchesSelector), ta.selection = function () { return ta.select(ua.documentElement); };\n    var _a = ta.selection.prototype = [];\n    _a.select = function (n) { var t, e, r, u, i = []; n = N(n); for (var o = -1, a = this.length; ++o < a;) {\n        i.push(t = []), t.parentNode = (r = this[o]).parentNode;\n        for (var c = -1, l = r.length; ++c < l;)\n            (u = r[c]) ? (t.push(e = n.call(u, u.__data__, c, o)), e && \"__data__\" in u && (e.__data__ = u.__data__)) : t.push(null);\n    } return A(i); }, _a.selectAll = function (n) { var t, e, r = []; n = C(n); for (var u = -1, i = this.length; ++u < i;)\n        for (var o = this[u], a = -1, c = o.length; ++a < c;)\n            (e = o[a]) && (r.push(t = ra(n.call(e, e.__data__, a, u))), t.parentNode = e); return A(r); };\n    var wa = { svg: \"http://www.w3.org/2000/svg\", xhtml: \"http://www.w3.org/1999/xhtml\", xlink: \"http://www.w3.org/1999/xlink\", xml: \"http://www.w3.org/XML/1998/namespace\", xmlns: \"http://www.w3.org/2000/xmlns/\" };\n    ta.ns = { prefix: wa, qualify: function (n) { var t = n.indexOf(\":\"), e = n; return t >= 0 && (e = n.slice(0, t), n = n.slice(t + 1)), wa.hasOwnProperty(e) ? { space: wa[e], local: n } : n; } }, _a.attr = function (n, t) { if (arguments.length < 2) {\n        if (\"string\" == typeof n) {\n            var e = this.node();\n            return n = ta.ns.qualify(n), n.local ? e.getAttributeNS(n.space, n.local) : e.getAttribute(n);\n        }\n        for (t in n)\n            this.each(z(t, n[t]));\n        return this;\n    } return this.each(z(n, t)); }, _a.classed = function (n, t) { if (arguments.length < 2) {\n        if (\"string\" == typeof n) {\n            var e = this.node(), r = (n = T(n)).length, u = -1;\n            if (t = e.classList) {\n                for (; ++u < r;)\n                    if (!t.contains(n[u]))\n                        return !1;\n            }\n            else\n                for (t = e.getAttribute(\"class\"); ++u < r;)\n                    if (!L(n[u]).test(t))\n                        return !1;\n            return !0;\n        }\n        for (t in n)\n            this.each(R(t, n[t]));\n        return this;\n    } return this.each(R(n, t)); }, _a.style = function (n, e, r) { var u = arguments.length; if (3 > u) {\n        if (\"string\" != typeof n) {\n            2 > u && (e = \"\");\n            for (r in n)\n                this.each(P(r, n[r], e));\n            return this;\n        }\n        if (2 > u) {\n            var i = this.node();\n            return t(i).getComputedStyle(i, null).getPropertyValue(n);\n        }\n        r = \"\";\n    } return this.each(P(n, e, r)); }, _a.property = function (n, t) { if (arguments.length < 2) {\n        if (\"string\" == typeof n)\n            return this.node()[n];\n        for (t in n)\n            this.each(U(t, n[t]));\n        return this;\n    } return this.each(U(n, t)); }, _a.text = function (n) { return arguments.length ? this.each(\"function\" == typeof n ? function () { var t = n.apply(this, arguments); this.textContent = null == t ? \"\" : t; } : null == n ? function () { this.textContent = \"\"; } : function () { this.textContent = n; }) : this.node().textContent; }, _a.html = function (n) { return arguments.length ? this.each(\"function\" == typeof n ? function () { var t = n.apply(this, arguments); this.innerHTML = null == t ? \"\" : t; } : null == n ? function () { this.innerHTML = \"\"; } : function () { this.innerHTML = n; }) : this.node().innerHTML; }, _a.append = function (n) { return n = j(n), this.select(function () { return this.appendChild(n.apply(this, arguments)); }); }, _a.insert = function (n, t) { return n = j(n), t = N(t), this.select(function () { return this.insertBefore(n.apply(this, arguments), t.apply(this, arguments) || null); }); }, _a.remove = function () { return this.each(F); }, _a.data = function (n, t) { function e(n, e) { var r, u, i, o = n.length, f = e.length, h = Math.min(o, f), g = new Array(f), p = new Array(f), v = new Array(o); if (t) {\n        var d, m = new l, y = new Array(o);\n        for (r = -1; ++r < o;)\n            m.has(d = t.call(u = n[r], u.__data__, r)) ? v[r] = u : m.set(d, u), y[r] = d;\n        for (r = -1; ++r < f;)\n            (u = m.get(d = t.call(e, i = e[r], r))) ? u !== !0 && (g[r] = u, u.__data__ = i) : p[r] = H(i), m.set(d, !0);\n        for (r = -1; ++r < o;)\n            m.get(y[r]) !== !0 && (v[r] = n[r]);\n    }\n    else {\n        for (r = -1; ++r < h;)\n            u = n[r], i = e[r], u ? (u.__data__ = i, g[r] = u) : p[r] = H(i);\n        for (; f > r; ++r)\n            p[r] = H(e[r]);\n        for (; o > r; ++r)\n            v[r] = n[r];\n    } p.update = g, p.parentNode = g.parentNode = v.parentNode = n.parentNode, a.push(p), c.push(g), s.push(v); } var r, u, i = -1, o = this.length; if (!arguments.length) {\n        for (n = new Array(o = (r = this[0]).length); ++i < o;)\n            (u = r[i]) && (n[i] = u.__data__);\n        return n;\n    } var a = Z([]), c = A([]), s = A([]); if (\"function\" == typeof n)\n        for (; ++i < o;)\n            e(r = this[i], n.call(r, r.parentNode.__data__, i));\n    else\n        for (; ++i < o;)\n            e(r = this[i], n); return c.enter = function () { return a; }, c.exit = function () { return s; }, c; }, _a.datum = function (n) { return arguments.length ? this.property(\"__data__\", n) : this.property(\"__data__\"); }, _a.filter = function (n) { var t, e, r, u = []; \"function\" != typeof n && (n = O(n)); for (var i = 0, o = this.length; o > i; i++) {\n        u.push(t = []), t.parentNode = (e = this[i]).parentNode;\n        for (var a = 0, c = e.length; c > a; a++)\n            (r = e[a]) && n.call(r, r.__data__, a, i) && t.push(r);\n    } return A(u); }, _a.order = function () { for (var n = -1, t = this.length; ++n < t;)\n        for (var e, r = this[n], u = r.length - 1, i = r[u]; --u >= 0;)\n            (e = r[u]) && (i && i !== e.nextSibling && i.parentNode.insertBefore(e, i), i = e); return this; }, _a.sort = function (n) { n = I.apply(this, arguments); for (var t = -1, e = this.length; ++t < e;)\n        this[t].sort(n); return this.order(); }, _a.each = function (n) { return Y(this, function (t, e, r) { n.call(t, t.__data__, e, r); }); }, _a.call = function (n) { var t = ra(arguments); return n.apply(t[0] = this, t), this; }, _a.empty = function () { return !this.node(); }, _a.node = function () { for (var n = 0, t = this.length; t > n; n++)\n        for (var e = this[n], r = 0, u = e.length; u > r; r++) {\n            var i = e[r];\n            if (i)\n                return i;\n        } return null; }, _a.size = function () { var n = 0; return Y(this, function () { ++n; }), n; };\n    var Sa = [];\n    ta.selection.enter = Z, ta.selection.enter.prototype = Sa, Sa.append = _a.append, Sa.empty = _a.empty, Sa.node = _a.node, Sa.call = _a.call, Sa.size = _a.size, Sa.select = function (n) { for (var t, e, r, u, i, o = [], a = -1, c = this.length; ++a < c;) {\n        r = (u = this[a]).update, o.push(t = []), t.parentNode = u.parentNode;\n        for (var l = -1, s = u.length; ++l < s;)\n            (i = u[l]) ? (t.push(r[l] = e = n.call(u.parentNode, i.__data__, l, a)), e.__data__ = i.__data__) : t.push(null);\n    } return A(o); }, Sa.insert = function (n, t) { return arguments.length < 2 && (t = V(this)), _a.insert.call(this, n, t); }, ta.select = function (t) { var e; return \"string\" == typeof t ? (e = [Ma(t, ua)], e.parentNode = ua.documentElement) : (e = [t], e.parentNode = n(t)), A([e]); }, ta.selectAll = function (n) { var t; return \"string\" == typeof n ? (t = ra(xa(n, ua)), t.parentNode = ua.documentElement) : (t = n, t.parentNode = null), A([t]); }, _a.on = function (n, t, e) { var r = arguments.length; if (3 > r) {\n        if (\"string\" != typeof n) {\n            2 > r && (t = !1);\n            for (e in n)\n                this.each(X(e, n[e], t));\n            return this;\n        }\n        if (2 > r)\n            return (r = this.node()[\"__on\" + n]) && r._;\n        e = !1;\n    } return this.each(X(n, t, e)); };\n    var ka = ta.map({ mouseenter: \"mouseover\", mouseleave: \"mouseout\" });\n    ua && ka.forEach(function (n) { \"on\" + n in ua && ka.remove(n); });\n    var Ea, Aa = 0;\n    ta.mouse = function (n) { return J(n, k()); };\n    var Na = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\n    ta.touch = function (n, t, e) { if (arguments.length < 3 && (e = t, t = k().changedTouches), t)\n        for (var r, u = 0, i = t.length; i > u; ++u)\n            if ((r = t[u]).identifier === e)\n                return J(n, r); }, ta.behavior.drag = function () { function n() { this.on(\"mousedown.drag\", i).on(\"touchstart.drag\", o); } function e(n, t, e, i, o) { return function () { function a() { var n, e, r = t(h, v); r && (n = r[0] - M[0], e = r[1] - M[1], p |= n | e, M = r, g({ type: \"drag\", x: r[0] + l[0], y: r[1] + l[1], dx: n, dy: e })); } function c() { t(h, v) && (m.on(i + d, null).on(o + d, null), y(p && ta.event.target === f), g({ type: \"dragend\" })); } var l, s = this, f = ta.event.target, h = s.parentNode, g = r.of(s, arguments), p = 0, v = n(), d = \".drag\" + (null == v ? \"\" : \"-\" + v), m = ta.select(e(f)).on(i + d, a).on(o + d, c), y = W(f), M = t(h, v); u ? (l = u.apply(s, arguments), l = [l.x - M[0], l.y - M[1]]) : l = [0, 0], g({ type: \"dragstart\" }); }; } var r = E(n, \"drag\", \"dragstart\", \"dragend\"), u = null, i = e(b, ta.mouse, t, \"mousemove\", \"mouseup\"), o = e(G, ta.touch, y, \"touchmove\", \"touchend\"); return n.origin = function (t) { return arguments.length ? (u = t, n) : u; }, ta.rebind(n, r, \"on\"); }, ta.touches = function (n, t) { return arguments.length < 2 && (t = k().touches), t ? ra(t).map(function (t) { var e = J(n, t); return e.identifier = t.identifier, e; }) : []; };\n    var Ca = 1e-6, za = Ca * Ca, qa = Math.PI, La = 2 * qa, Ta = La - Ca, Ra = qa / 2, Da = qa / 180, Pa = 180 / qa, Ua = Math.SQRT2, ja = 2, Fa = 4;\n    ta.interpolateZoom = function (n, t) { function e(n) { var t = n * y; if (m) {\n        var e = rt(v), o = i / (ja * h) * (e * ut(Ua * t + v) - et(v));\n        return [r + o * l, u + o * s, i * e / rt(Ua * t + v)];\n    } return [r + n * l, u + n * s, i * Math.exp(Ua * t)]; } var r = n[0], u = n[1], i = n[2], o = t[0], a = t[1], c = t[2], l = o - r, s = a - u, f = l * l + s * s, h = Math.sqrt(f), g = (c * c - i * i + Fa * f) / (2 * i * ja * h), p = (c * c - i * i - Fa * f) / (2 * c * ja * h), v = Math.log(Math.sqrt(g * g + 1) - g), d = Math.log(Math.sqrt(p * p + 1) - p), m = d - v, y = (m || Math.log(c / i)) / Ua; return e.duration = 1e3 * y, e; }, ta.behavior.zoom = function () { function n(n) { n.on(q, f).on(Oa + \".zoom\", g).on(\"dblclick.zoom\", p).on(R, h); } function e(n) { return [(n[0] - k.x) / k.k, (n[1] - k.y) / k.k]; } function r(n) { return [n[0] * k.k + k.x, n[1] * k.k + k.y]; } function u(n) { k.k = Math.max(N[0], Math.min(N[1], n)); } function i(n, t) { t = r(t), k.x += n[0] - t[0], k.y += n[1] - t[1]; } function o(t, e, r, o) { t.__chart__ = { x: k.x, y: k.y, k: k.k }, u(Math.pow(2, o)), i(d = e, r), t = ta.select(t), C > 0 && (t = t.transition().duration(C)), t.call(n.event); } function a() { b && b.domain(x.range().map(function (n) { return (n - k.x) / k.k; }).map(x.invert)), w && w.domain(_.range().map(function (n) { return (n - k.y) / k.k; }).map(_.invert)); } function c(n) { z++ || n({ type: \"zoomstart\" }); } function l(n) { a(), n({ type: \"zoom\", scale: k.k, translate: [k.x, k.y] }); } function s(n) { --z || n({ type: \"zoomend\" }), d = null; } function f() { function n() { f = 1, i(ta.mouse(u), g), l(a); } function r() { h.on(L, null).on(T, null), p(f && ta.event.target === o), s(a); } var u = this, o = ta.event.target, a = D.of(u, arguments), f = 0, h = ta.select(t(u)).on(L, n).on(T, r), g = e(ta.mouse(u)), p = W(u); Dl.call(u), c(a); } function h() { function n() { var n = ta.touches(p); return g = k.k, n.forEach(function (n) { n.identifier in d && (d[n.identifier] = e(n)); }), n; } function t() { var t = ta.event.target; ta.select(t).on(x, r).on(b, a), _.push(t); for (var e = ta.event.changedTouches, u = 0, i = e.length; i > u; ++u)\n        d[e[u].identifier] = null; var c = n(), l = Date.now(); if (1 === c.length) {\n        if (500 > l - M) {\n            var s = c[0];\n            o(p, s, d[s.identifier], Math.floor(Math.log(k.k) / Math.LN2) + 1), S();\n        }\n        M = l;\n    }\n    else if (c.length > 1) {\n        var s = c[0], f = c[1], h = s[0] - f[0], g = s[1] - f[1];\n        m = h * h + g * g;\n    } } function r() { var n, t, e, r, o = ta.touches(p); Dl.call(p); for (var a = 0, c = o.length; c > a; ++a, r = null)\n        if (e = o[a], r = d[e.identifier]) {\n            if (t)\n                break;\n            n = e, t = r;\n        } if (r) {\n        var s = (s = e[0] - n[0]) * s + (s = e[1] - n[1]) * s, f = m && Math.sqrt(s / m);\n        n = [(n[0] + e[0]) / 2, (n[1] + e[1]) / 2], t = [(t[0] + r[0]) / 2, (t[1] + r[1]) / 2], u(f * g);\n    } M = null, i(n, t), l(v); } function a() { if (ta.event.touches.length) {\n        for (var t = ta.event.changedTouches, e = 0, r = t.length; r > e; ++e)\n            delete d[t[e].identifier];\n        for (var u in d)\n            return void n();\n    } ta.selectAll(_).on(y, null), w.on(q, f).on(R, h), E(), s(v); } var g, p = this, v = D.of(p, arguments), d = {}, m = 0, y = \".zoom-\" + ta.event.changedTouches[0].identifier, x = \"touchmove\" + y, b = \"touchend\" + y, _ = [], w = ta.select(p), E = W(p); t(), c(v), w.on(q, null).on(R, t); } function g() { var n = D.of(this, arguments); y ? clearTimeout(y) : (v = e(d = m || ta.mouse(this)), Dl.call(this), c(n)), y = setTimeout(function () { y = null, s(n); }, 50), S(), u(Math.pow(2, .002 * Ha()) * k.k), i(d, v), l(n); } function p() { var n = ta.mouse(this), t = Math.log(k.k) / Math.LN2; o(this, n, e(n), ta.event.shiftKey ? Math.ceil(t) - 1 : Math.floor(t) + 1); } var v, d, m, y, M, x, b, _, w, k = { x: 0, y: 0, k: 1 }, A = [960, 500], N = Ia, C = 250, z = 0, q = \"mousedown.zoom\", L = \"mousemove.zoom\", T = \"mouseup.zoom\", R = \"touchstart.zoom\", D = E(n, \"zoomstart\", \"zoom\", \"zoomend\"); return Oa || (Oa = \"onwheel\" in ua ? (Ha = function () { return -ta.event.deltaY * (ta.event.deltaMode ? 120 : 1); }, \"wheel\") : \"onmousewheel\" in ua ? (Ha = function () { return ta.event.wheelDelta; }, \"mousewheel\") : (Ha = function () { return -ta.event.detail; }, \"MozMousePixelScroll\")), n.event = function (n) { n.each(function () { var n = D.of(this, arguments), t = k; Tl ? ta.select(this).transition().each(\"start.zoom\", function () { k = this.__chart__ || { x: 0, y: 0, k: 1 }, c(n); }).tween(\"zoom:zoom\", function () { var e = A[0], r = A[1], u = d ? d[0] : e / 2, i = d ? d[1] : r / 2, o = ta.interpolateZoom([(u - k.x) / k.k, (i - k.y) / k.k, e / k.k], [(u - t.x) / t.k, (i - t.y) / t.k, e / t.k]); return function (t) { var r = o(t), a = e / r[2]; this.__chart__ = k = { x: u - r[0] * a, y: i - r[1] * a, k: a }, l(n); }; }).each(\"interrupt.zoom\", function () { s(n); }).each(\"end.zoom\", function () { s(n); }) : (this.__chart__ = k, c(n), l(n), s(n)); }); }, n.translate = function (t) { return arguments.length ? (k = { x: +t[0], y: +t[1], k: k.k }, a(), n) : [k.x, k.y]; }, n.scale = function (t) { return arguments.length ? (k = { x: k.x, y: k.y, k: +t }, a(), n) : k.k; }, n.scaleExtent = function (t) { return arguments.length ? (N = null == t ? Ia : [+t[0], +t[1]], n) : N; }, n.center = function (t) { return arguments.length ? (m = t && [+t[0], +t[1]], n) : m; }, n.size = function (t) { return arguments.length ? (A = t && [+t[0], +t[1]], n) : A; }, n.duration = function (t) { return arguments.length ? (C = +t, n) : C; }, n.x = function (t) { return arguments.length ? (b = t, x = t.copy(), k = { x: 0, y: 0, k: 1 }, n) : b; }, n.y = function (t) { return arguments.length ? (w = t, _ = t.copy(), k = { x: 0, y: 0, k: 1 }, n) : w; }, ta.rebind(n, D, \"on\"); };\n    var Ha, Oa, Ia = [0, 1 / 0];\n    ta.color = ot, ot.prototype.toString = function () { return this.rgb() + \"\"; }, ta.hsl = at;\n    var Ya = at.prototype = new ot;\n    Ya.brighter = function (n) { return n = Math.pow(.7, arguments.length ? n : 1), new at(this.h, this.s, this.l / n); }, Ya.darker = function (n) { return n = Math.pow(.7, arguments.length ? n : 1), new at(this.h, this.s, n * this.l); }, Ya.rgb = function () { return ct(this.h, this.s, this.l); }, ta.hcl = lt;\n    var Za = lt.prototype = new ot;\n    Za.brighter = function (n) { return new lt(this.h, this.c, Math.min(100, this.l + Va * (arguments.length ? n : 1))); }, Za.darker = function (n) { return new lt(this.h, this.c, Math.max(0, this.l - Va * (arguments.length ? n : 1))); }, Za.rgb = function () { return st(this.h, this.c, this.l).rgb(); }, ta.lab = ft;\n    var Va = 18, Xa = .95047, $a = 1, Ba = 1.08883, Wa = ft.prototype = new ot;\n    Wa.brighter = function (n) { return new ft(Math.min(100, this.l + Va * (arguments.length ? n : 1)), this.a, this.b); }, Wa.darker = function (n) { return new ft(Math.max(0, this.l - Va * (arguments.length ? n : 1)), this.a, this.b); }, Wa.rgb = function () { return ht(this.l, this.a, this.b); }, ta.rgb = mt;\n    var Ja = mt.prototype = new ot;\n    Ja.brighter = function (n) { n = Math.pow(.7, arguments.length ? n : 1); var t = this.r, e = this.g, r = this.b, u = 30; return t || e || r ? (t && u > t && (t = u), e && u > e && (e = u), r && u > r && (r = u), new mt(Math.min(255, t / n), Math.min(255, e / n), Math.min(255, r / n))) : new mt(u, u, u); }, Ja.darker = function (n) { return n = Math.pow(.7, arguments.length ? n : 1), new mt(n * this.r, n * this.g, n * this.b); }, Ja.hsl = function () { return _t(this.r, this.g, this.b); }, Ja.toString = function () { return \"#\" + xt(this.r) + xt(this.g) + xt(this.b); };\n    var Ga = ta.map({ aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 });\n    Ga.forEach(function (n, t) { Ga.set(n, yt(t)); }), ta.functor = Et, ta.xhr = At(y), ta.dsv = function (n, t) { function e(n, e, i) { arguments.length < 3 && (i = e, e = null); var o = Nt(n, t, null == e ? r : u(e), i); return o.row = function (n) { return arguments.length ? o.response(null == (e = n) ? r : u(n)) : e; }, o; } function r(n) { return e.parse(n.responseText); } function u(n) { return function (t) { return e.parse(t.responseText, n); }; } function i(t) { return t.map(o).join(n); } function o(n) { return a.test(n) ? '\"' + n.replace(/\\\"/g, '\"\"') + '\"' : n; } var a = new RegExp('[\"' + n + \"\\n]\"), c = n.charCodeAt(0); return e.parse = function (n, t) { var r; return e.parseRows(n, function (n, e) { if (r)\n        return r(n, e - 1); var u = new Function(\"d\", \"return {\" + n.map(function (n, t) { return JSON.stringify(n) + \": d[\" + t + \"]\"; }).join(\",\") + \"}\"); r = t ? function (n, e) { return t(u(n), e); } : u; }); }, e.parseRows = function (n, t) { function e() { if (s >= l)\n        return o; if (u)\n        return u = !1, i; var t = s; if (34 === n.charCodeAt(t)) {\n        for (var e = t; e++ < l;)\n            if (34 === n.charCodeAt(e)) {\n                if (34 !== n.charCodeAt(e + 1))\n                    break;\n                ++e;\n            }\n        s = e + 2;\n        var r = n.charCodeAt(e + 1);\n        return 13 === r ? (u = !0, 10 === n.charCodeAt(e + 2) && ++s) : 10 === r && (u = !0), n.slice(t + 1, e).replace(/\"\"/g, '\"');\n    } for (; l > s;) {\n        var r = n.charCodeAt(s++), a = 1;\n        if (10 === r)\n            u = !0;\n        else if (13 === r)\n            u = !0, 10 === n.charCodeAt(s) && (++s, ++a);\n        else if (r !== c)\n            continue;\n        return n.slice(t, s - a);\n    } return n.slice(t); } for (var r, u, i = {}, o = {}, a = [], l = n.length, s = 0, f = 0; (r = e()) !== o;) {\n        for (var h = []; r !== i && r !== o;)\n            h.push(r), r = e();\n        t && null == (h = t(h, f++)) || a.push(h);\n    } return a; }, e.format = function (t) { if (Array.isArray(t[0]))\n        return e.formatRows(t); var r = new m, u = []; return t.forEach(function (n) { for (var t in n)\n        r.has(t) || u.push(r.add(t)); }), [u.map(o).join(n)].concat(t.map(function (t) { return u.map(function (n) { return o(t[n]); }).join(n); })).join(\"\\n\"); }, e.formatRows = function (n) { return n.map(i).join(\"\\n\"); }, e; }, ta.csv = ta.dsv(\",\", \"text/csv\"), ta.tsv = ta.dsv(\"\t\", \"text/tab-separated-values\");\n    var Ka, Qa, nc, tc, ec, rc = this[x(this, \"requestAnimationFrame\")] || function (n) { setTimeout(n, 17); };\n    ta.timer = function (n, t, e) { var r = arguments.length; 2 > r && (t = 0), 3 > r && (e = Date.now()); var u = e + t, i = { c: n, t: u, f: !1, n: null }; Qa ? Qa.n = i : Ka = i, Qa = i, nc || (tc = clearTimeout(tc), nc = 1, rc(qt)); }, ta.timer.flush = function () { Lt(), Tt(); }, ta.round = function (n, t) { return t ? Math.round(n * (t = Math.pow(10, t))) / t : Math.round(n); };\n    var uc = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"\\xb5\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\", \"Z\", \"Y\"].map(Dt);\n    ta.formatPrefix = function (n, t) { var e = 0; return n && (0 > n && (n *= -1), t && (n = ta.round(n, Rt(n, t))), e = 1 + Math.floor(1e-12 + Math.log(n) / Math.LN10), e = Math.max(-24, Math.min(24, 3 * Math.floor((e - 1) / 3)))), uc[8 + e / 3]; };\n    var ic = /(?:([^{])?([<>=^]))?([+\\- ])?([$#])?(0)?(\\d+)?(,)?(\\.-?\\d+)?([a-z%])?/i, oc = ta.map({ b: function (n) { return n.toString(2); }, c: function (n) { return String.fromCharCode(n); }, o: function (n) { return n.toString(8); }, x: function (n) { return n.toString(16); }, X: function (n) { return n.toString(16).toUpperCase(); }, g: function (n, t) { return n.toPrecision(t); }, e: function (n, t) { return n.toExponential(t); }, f: function (n, t) { return n.toFixed(t); }, r: function (n, t) { return (n = ta.round(n, Rt(n, t))).toFixed(Math.max(0, Math.min(20, Rt(n * (1 + 1e-15), t)))); } }), ac = ta.time = {}, cc = Date;\n    jt.prototype = { getDate: function () { return this._.getUTCDate(); }, getDay: function () { return this._.getUTCDay(); }, getFullYear: function () { return this._.getUTCFullYear(); }, getHours: function () { return this._.getUTCHours(); }, getMilliseconds: function () { return this._.getUTCMilliseconds(); }, getMinutes: function () { return this._.getUTCMinutes(); }, getMonth: function () { return this._.getUTCMonth(); }, getSeconds: function () { return this._.getUTCSeconds(); }, getTime: function () { return this._.getTime(); }, getTimezoneOffset: function () { return 0; }, valueOf: function () { return this._.valueOf(); }, setDate: function () { lc.setUTCDate.apply(this._, arguments); }, setDay: function () { lc.setUTCDay.apply(this._, arguments); }, setFullYear: function () { lc.setUTCFullYear.apply(this._, arguments); }, setHours: function () { lc.setUTCHours.apply(this._, arguments); }, setMilliseconds: function () { lc.setUTCMilliseconds.apply(this._, arguments); }, setMinutes: function () { lc.setUTCMinutes.apply(this._, arguments); }, setMonth: function () { lc.setUTCMonth.apply(this._, arguments); }, setSeconds: function () { lc.setUTCSeconds.apply(this._, arguments); }, setTime: function () { lc.setTime.apply(this._, arguments); } };\n    var lc = Date.prototype;\n    ac.year = Ft(function (n) { return n = ac.day(n), n.setMonth(0, 1), n; }, function (n, t) { n.setFullYear(n.getFullYear() + t); }, function (n) { return n.getFullYear(); }), ac.years = ac.year.range, ac.years.utc = ac.year.utc.range, ac.day = Ft(function (n) { var t = new cc(2e3, 0); return t.setFullYear(n.getFullYear(), n.getMonth(), n.getDate()), t; }, function (n, t) { n.setDate(n.getDate() + t); }, function (n) { return n.getDate() - 1; }), ac.days = ac.day.range, ac.days.utc = ac.day.utc.range, ac.dayOfYear = function (n) { var t = ac.year(n); return Math.floor((n - t - 6e4 * (n.getTimezoneOffset() - t.getTimezoneOffset())) / 864e5); }, [\"sunday\", \"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\"].forEach(function (n, t) { t = 7 - t; var e = ac[n] = Ft(function (n) { return (n = ac.day(n)).setDate(n.getDate() - (n.getDay() + t) % 7), n; }, function (n, t) { n.setDate(n.getDate() + 7 * Math.floor(t)); }, function (n) { var e = ac.year(n).getDay(); return Math.floor((ac.dayOfYear(n) + (e + t) % 7) / 7) - (e !== t); }); ac[n + \"s\"] = e.range, ac[n + \"s\"].utc = e.utc.range, ac[n + \"OfYear\"] = function (n) { var e = ac.year(n).getDay(); return Math.floor((ac.dayOfYear(n) + (e + t) % 7) / 7); }; }), ac.week = ac.sunday, ac.weeks = ac.sunday.range, ac.weeks.utc = ac.sunday.utc.range, ac.weekOfYear = ac.sundayOfYear;\n    var sc = { \"-\": \"\", _: \" \", 0: \"0\" }, fc = /^\\s*\\d+/, hc = /^%/;\n    ta.locale = function (n) { return { numberFormat: Pt(n), timeFormat: Ot(n) }; };\n    var gc = ta.locale({ decimal: \".\", thousands: \",\", grouping: [3], currency: [\"$\", \"\"], dateTime: \"%a %b %e %X %Y\", date: \"%m/%d/%Y\", time: \"%H:%M:%S\", periods: [\"AM\", \"PM\"], days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"], shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"] });\n    ta.format = gc.numberFormat, ta.geo = {}, ce.prototype = { s: 0, t: 0, add: function (n) {\n            le(n, this.t, pc), le(pc.s, this.s, this), this.s ? this.t += pc.t : this.s = pc.t;\n        }, reset: function () { this.s = this.t = 0; }, valueOf: function () { return this.s; } };\n    var pc = new ce;\n    ta.geo.stream = function (n, t) { n && vc.hasOwnProperty(n.type) ? vc[n.type](n, t) : se(n, t); };\n    var vc = { Feature: function (n, t) { se(n.geometry, t); }, FeatureCollection: function (n, t) { for (var e = n.features, r = -1, u = e.length; ++r < u;)\n            se(e[r].geometry, t); } }, dc = { Sphere: function (n, t) { t.sphere(); }, Point: function (n, t) { n = n.coordinates, t.point(n[0], n[1], n[2]); }, MultiPoint: function (n, t) { for (var e = n.coordinates, r = -1, u = e.length; ++r < u;)\n            n = e[r], t.point(n[0], n[1], n[2]); }, LineString: function (n, t) { fe(n.coordinates, t, 0); }, MultiLineString: function (n, t) { for (var e = n.coordinates, r = -1, u = e.length; ++r < u;)\n            fe(e[r], t, 0); }, Polygon: function (n, t) { he(n.coordinates, t); }, MultiPolygon: function (n, t) { for (var e = n.coordinates, r = -1, u = e.length; ++r < u;)\n            he(e[r], t); }, GeometryCollection: function (n, t) { for (var e = n.geometries, r = -1, u = e.length; ++r < u;)\n            se(e[r], t); } };\n    ta.geo.area = function (n) { return mc = 0, ta.geo.stream(n, Mc), mc; };\n    var mc, yc = new ce, Mc = { sphere: function () { mc += 4 * qa; }, point: b, lineStart: b, lineEnd: b, polygonStart: function () { yc.reset(), Mc.lineStart = ge; }, polygonEnd: function () { var n = 2 * yc; mc += 0 > n ? 4 * qa + n : n, Mc.lineStart = Mc.lineEnd = Mc.point = b; } };\n    ta.geo.bounds = function () { function n(n, t) { M.push(x = [s = n, h = n]), f > t && (f = t), t > g && (g = t); } function t(t, e) { var r = pe([t * Da, e * Da]); if (m) {\n        var u = de(m, r), i = [u[1], -u[0], 0], o = de(i, u);\n        Me(o), o = xe(o);\n        var c = t - p, l = c > 0 ? 1 : -1, v = o[0] * Pa * l, d = ga(c) > 180;\n        if (d ^ (v > l * p && l * t > v)) {\n            var y = o[1] * Pa;\n            y > g && (g = y);\n        }\n        else if (v = (v + 360) % 360 - 180, d ^ (v > l * p && l * t > v)) {\n            var y = -o[1] * Pa;\n            f > y && (f = y);\n        }\n        else\n            f > e && (f = e), e > g && (g = e);\n        d ? p > t ? a(s, t) > a(s, h) && (h = t) : a(t, h) > a(s, h) && (s = t) : h >= s ? (s > t && (s = t), t > h && (h = t)) : t > p ? a(s, t) > a(s, h) && (h = t) : a(t, h) > a(s, h) && (s = t);\n    }\n    else\n        n(t, e); m = r, p = t; } function e() { b.point = t; } function r() { x[0] = s, x[1] = h, b.point = n, m = null; } function u(n, e) { if (m) {\n        var r = n - p;\n        y += ga(r) > 180 ? r + (r > 0 ? 360 : -360) : r;\n    }\n    else\n        v = n, d = e; Mc.point(n, e), t(n, e); } function i() { Mc.lineStart(); } function o() { u(v, d), Mc.lineEnd(), ga(y) > Ca && (s = -(h = 180)), x[0] = s, x[1] = h, m = null; } function a(n, t) { return (t -= n) < 0 ? t + 360 : t; } function c(n, t) { return n[0] - t[0]; } function l(n, t) { return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n; } var s, f, h, g, p, v, d, m, y, M, x, b = { point: n, lineStart: e, lineEnd: r, polygonStart: function () { b.point = u, b.lineStart = i, b.lineEnd = o, y = 0, Mc.polygonStart(); }, polygonEnd: function () { Mc.polygonEnd(), b.point = n, b.lineStart = e, b.lineEnd = r, 0 > yc ? (s = -(h = 180), f = -(g = 90)) : y > Ca ? g = 90 : -Ca > y && (f = -90), x[0] = s, x[1] = h; } }; return function (n) { g = h = -(s = f = 1 / 0), M = [], ta.geo.stream(n, b); var t = M.length; if (t) {\n        M.sort(c);\n        for (var e, r = 1, u = M[0], i = [u]; t > r; ++r)\n            e = M[r], l(e[0], u) || l(e[1], u) ? (a(u[0], e[1]) > a(u[0], u[1]) && (u[1] = e[1]), a(e[0], u[1]) > a(u[0], u[1]) && (u[0] = e[0])) : i.push(u = e);\n        for (var o, e, p = -1 / 0, t = i.length - 1, r = 0, u = i[t]; t >= r; u = e, ++r)\n            e = i[r], (o = a(u[1], e[0])) > p && (p = o, s = e[0], h = u[1]);\n    } return M = x = null, 1 / 0 === s || 1 / 0 === f ? [[0 / 0, 0 / 0], [0 / 0, 0 / 0]] : [[s, f], [h, g]]; }; }(), ta.geo.centroid = function (n) { xc = bc = _c = wc = Sc = kc = Ec = Ac = Nc = Cc = zc = 0, ta.geo.stream(n, qc); var t = Nc, e = Cc, r = zc, u = t * t + e * e + r * r; return za > u && (t = kc, e = Ec, r = Ac, Ca > bc && (t = _c, e = wc, r = Sc), u = t * t + e * e + r * r, za > u) ? [0 / 0, 0 / 0] : [Math.atan2(e, t) * Pa, tt(r / Math.sqrt(u)) * Pa]; };\n    var xc, bc, _c, wc, Sc, kc, Ec, Ac, Nc, Cc, zc, qc = { sphere: b, point: _e, lineStart: Se, lineEnd: ke, polygonStart: function () { qc.lineStart = Ee; }, polygonEnd: function () { qc.lineStart = Se; } }, Lc = Le(Ne, Pe, je, [-qa, -qa / 2]), Tc = 1e9;\n    ta.geo.clipExtent = function () { var n, t, e, r, u, i, o = { stream: function (n) { return u && (u.valid = !1), u = i(n), u.valid = !0, u; }, extent: function (a) { return arguments.length ? (i = Ie(n = +a[0][0], t = +a[0][1], e = +a[1][0], r = +a[1][1]), u && (u.valid = !1, u = null), o) : [[n, t], [e, r]]; } }; return o.extent([[0, 0], [960, 500]]); }, (ta.geo.conicEqualArea = function () { return Ye(Ze); }).raw = Ze, ta.geo.albers = function () { return ta.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070); }, ta.geo.albersUsa = function () { function n(n) { var i = n[0], o = n[1]; return t = null, e(i, o), t || (r(i, o), t) || u(i, o), t; } var t, e, r, u, i = ta.geo.albers(), o = ta.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), a = ta.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), c = { point: function (n, e) { t = [n, e]; } }; return n.invert = function (n) { var t = i.scale(), e = i.translate(), r = (n[0] - e[0]) / t, u = (n[1] - e[1]) / t; return (u >= .12 && .234 > u && r >= -.425 && -.214 > r ? o : u >= .166 && .234 > u && r >= -.214 && -.115 > r ? a : i).invert(n); }, n.stream = function (n) { var t = i.stream(n), e = o.stream(n), r = a.stream(n); return { point: function (n, u) { t.point(n, u), e.point(n, u), r.point(n, u); }, sphere: function () { t.sphere(), e.sphere(), r.sphere(); }, lineStart: function () { t.lineStart(), e.lineStart(), r.lineStart(); }, lineEnd: function () { t.lineEnd(), e.lineEnd(), r.lineEnd(); }, polygonStart: function () { t.polygonStart(), e.polygonStart(), r.polygonStart(); }, polygonEnd: function () { t.polygonEnd(), e.polygonEnd(), r.polygonEnd(); } }; }, n.precision = function (t) { return arguments.length ? (i.precision(t), o.precision(t), a.precision(t), n) : i.precision(); }, n.scale = function (t) { return arguments.length ? (i.scale(t), o.scale(.35 * t), a.scale(t), n.translate(i.translate())) : i.scale(); }, n.translate = function (t) { if (!arguments.length)\n        return i.translate(); var l = i.scale(), s = +t[0], f = +t[1]; return e = i.translate(t).clipExtent([[s - .455 * l, f - .238 * l], [s + .455 * l, f + .238 * l]]).stream(c).point, r = o.translate([s - .307 * l, f + .201 * l]).clipExtent([[s - .425 * l + Ca, f + .12 * l + Ca], [s - .214 * l - Ca, f + .234 * l - Ca]]).stream(c).point, u = a.translate([s - .205 * l, f + .212 * l]).clipExtent([[s - .214 * l + Ca, f + .166 * l + Ca], [s - .115 * l - Ca, f + .234 * l - Ca]]).stream(c).point, n; }, n.scale(1070); };\n    var Rc, Dc, Pc, Uc, jc, Fc, Hc = { point: b, lineStart: b, lineEnd: b, polygonStart: function () { Dc = 0, Hc.lineStart = Ve; }, polygonEnd: function () { Hc.lineStart = Hc.lineEnd = Hc.point = b, Rc += ga(Dc / 2); } }, Oc = { point: Xe, lineStart: b, lineEnd: b, polygonStart: b, polygonEnd: b }, Ic = { point: We, lineStart: Je, lineEnd: Ge, polygonStart: function () { Ic.lineStart = Ke; }, polygonEnd: function () { Ic.point = We, Ic.lineStart = Je, Ic.lineEnd = Ge; } };\n    ta.geo.path = function () { function n(n) { return n && (\"function\" == typeof a && i.pointRadius(+a.apply(this, arguments)), o && o.valid || (o = u(i)), ta.geo.stream(n, o)), i.result(); } function t() { return o = null, n; } var e, r, u, i, o, a = 4.5; return n.area = function (n) { return Rc = 0, ta.geo.stream(n, u(Hc)), Rc; }, n.centroid = function (n) { return _c = wc = Sc = kc = Ec = Ac = Nc = Cc = zc = 0, ta.geo.stream(n, u(Ic)), zc ? [Nc / zc, Cc / zc] : Ac ? [kc / Ac, Ec / Ac] : Sc ? [_c / Sc, wc / Sc] : [0 / 0, 0 / 0]; }, n.bounds = function (n) { return jc = Fc = -(Pc = Uc = 1 / 0), ta.geo.stream(n, u(Oc)), [[Pc, Uc], [jc, Fc]]; }, n.projection = function (n) { return arguments.length ? (u = (e = n) ? n.stream || tr(n) : y, t()) : e; }, n.context = function (n) { return arguments.length ? (i = null == (r = n) ? new $e : new Qe(n), \"function\" != typeof a && i.pointRadius(a), t()) : r; }, n.pointRadius = function (t) { return arguments.length ? (a = \"function\" == typeof t ? t : (i.pointRadius(+t), +t), n) : a; }, n.projection(ta.geo.albersUsa()).context(null); }, ta.geo.transform = function (n) { return { stream: function (t) { var e = new er(t); for (var r in n)\n            e[r] = n[r]; return e; } }; }, er.prototype = { point: function (n, t) { this.stream.point(n, t); }, sphere: function () { this.stream.sphere(); }, lineStart: function () { this.stream.lineStart(); }, lineEnd: function () { this.stream.lineEnd(); }, polygonStart: function () { this.stream.polygonStart(); }, polygonEnd: function () { this.stream.polygonEnd(); } }, ta.geo.projection = ur, ta.geo.projectionMutator = ir, (ta.geo.equirectangular = function () { return ur(ar); }).raw = ar.invert = ar, ta.geo.rotation = function (n) { function t(t) { return t = n(t[0] * Da, t[1] * Da), t[0] *= Pa, t[1] *= Pa, t; } return n = lr(n[0] % 360 * Da, n[1] * Da, n.length > 2 ? n[2] * Da : 0), t.invert = function (t) { return t = n.invert(t[0] * Da, t[1] * Da), t[0] *= Pa, t[1] *= Pa, t; }, t; }, cr.invert = ar, ta.geo.circle = function () { function n() { var n = \"function\" == typeof r ? r.apply(this, arguments) : r, t = lr(-n[0] * Da, -n[1] * Da, 0).invert, u = []; return e(null, null, 1, { point: function (n, e) { u.push(n = t(n, e)), n[0] *= Pa, n[1] *= Pa; } }), { type: \"Polygon\", coordinates: [u] }; } var t, e, r = [0, 0], u = 6; return n.origin = function (t) { return arguments.length ? (r = t, n) : r; }, n.angle = function (r) { return arguments.length ? (e = gr((t = +r) * Da, u * Da), n) : t; }, n.precision = function (r) { return arguments.length ? (e = gr(t * Da, (u = +r) * Da), n) : u; }, n.angle(90); }, ta.geo.distance = function (n, t) { var e, r = (t[0] - n[0]) * Da, u = n[1] * Da, i = t[1] * Da, o = Math.sin(r), a = Math.cos(r), c = Math.sin(u), l = Math.cos(u), s = Math.sin(i), f = Math.cos(i); return Math.atan2(Math.sqrt((e = f * o) * e + (e = l * s - c * f * a) * e), c * s + l * f * a); }, ta.geo.graticule = function () { function n() { return { type: \"MultiLineString\", coordinates: t() }; } function t() { return ta.range(Math.ceil(i / d) * d, u, d).map(h).concat(ta.range(Math.ceil(l / m) * m, c, m).map(g)).concat(ta.range(Math.ceil(r / p) * p, e, p).filter(function (n) { return ga(n % d) > Ca; }).map(s)).concat(ta.range(Math.ceil(a / v) * v, o, v).filter(function (n) { return ga(n % m) > Ca; }).map(f)); } var e, r, u, i, o, a, c, l, s, f, h, g, p = 10, v = p, d = 90, m = 360, y = 2.5; return n.lines = function () { return t().map(function (n) { return { type: \"LineString\", coordinates: n }; }); }, n.outline = function () { return { type: \"Polygon\", coordinates: [h(i).concat(g(c).slice(1), h(u).reverse().slice(1), g(l).reverse().slice(1))] }; }, n.extent = function (t) { return arguments.length ? n.majorExtent(t).minorExtent(t) : n.minorExtent(); }, n.majorExtent = function (t) { return arguments.length ? (i = +t[0][0], u = +t[1][0], l = +t[0][1], c = +t[1][1], i > u && (t = i, i = u, u = t), l > c && (t = l, l = c, c = t), n.precision(y)) : [[i, l], [u, c]]; }, n.minorExtent = function (t) { return arguments.length ? (r = +t[0][0], e = +t[1][0], a = +t[0][1], o = +t[1][1], r > e && (t = r, r = e, e = t), a > o && (t = a, a = o, o = t), n.precision(y)) : [[r, a], [e, o]]; }, n.step = function (t) { return arguments.length ? n.majorStep(t).minorStep(t) : n.minorStep(); }, n.majorStep = function (t) { return arguments.length ? (d = +t[0], m = +t[1], n) : [d, m]; }, n.minorStep = function (t) { return arguments.length ? (p = +t[0], v = +t[1], n) : [p, v]; }, n.precision = function (t) { return arguments.length ? (y = +t, s = vr(a, o, 90), f = dr(r, e, y), h = vr(l, c, 90), g = dr(i, u, y), n) : y; }, n.majorExtent([[-180, -90 + Ca], [180, 90 - Ca]]).minorExtent([[-180, -80 - Ca], [180, 80 + Ca]]); }, ta.geo.greatArc = function () { function n() { return { type: \"LineString\", coordinates: [t || r.apply(this, arguments), e || u.apply(this, arguments)] }; } var t, e, r = mr, u = yr; return n.distance = function () { return ta.geo.distance(t || r.apply(this, arguments), e || u.apply(this, arguments)); }, n.source = function (e) { return arguments.length ? (r = e, t = \"function\" == typeof e ? null : e, n) : r; }, n.target = function (t) { return arguments.length ? (u = t, e = \"function\" == typeof t ? null : t, n) : u; }, n.precision = function () { return arguments.length ? n : 0; }, n; }, ta.geo.interpolate = function (n, t) { return Mr(n[0] * Da, n[1] * Da, t[0] * Da, t[1] * Da); }, ta.geo.length = function (n) { return Yc = 0, ta.geo.stream(n, Zc), Yc; };\n    var Yc, Zc = { sphere: b, point: b, lineStart: xr, lineEnd: b, polygonStart: b, polygonEnd: b }, Vc = br(function (n) { return Math.sqrt(2 / (1 + n)); }, function (n) { return 2 * Math.asin(n / 2); });\n    (ta.geo.azimuthalEqualArea = function () { return ur(Vc); }).raw = Vc;\n    var Xc = br(function (n) { var t = Math.acos(n); return t && t / Math.sin(t); }, y);\n    (ta.geo.azimuthalEquidistant = function () { return ur(Xc); }).raw = Xc, (ta.geo.conicConformal = function () { return Ye(_r); }).raw = _r, (ta.geo.conicEquidistant = function () { return Ye(wr); }).raw = wr;\n    var $c = br(function (n) { return 1 / n; }, Math.atan);\n    (ta.geo.gnomonic = function () { return ur($c); }).raw = $c, Sr.invert = function (n, t) { return [n, 2 * Math.atan(Math.exp(t)) - Ra]; }, (ta.geo.mercator = function () { return kr(Sr); }).raw = Sr;\n    var Bc = br(function () { return 1; }, Math.asin);\n    (ta.geo.orthographic = function () { return ur(Bc); }).raw = Bc;\n    var Wc = br(function (n) { return 1 / (1 + n); }, function (n) { return 2 * Math.atan(n); });\n    (ta.geo.stereographic = function () { return ur(Wc); }).raw = Wc, Er.invert = function (n, t) { return [-t, 2 * Math.atan(Math.exp(n)) - Ra]; }, (ta.geo.transverseMercator = function () { var n = kr(Er), t = n.center, e = n.rotate; return n.center = function (n) { return n ? t([-n[1], n[0]]) : (n = t(), [n[1], -n[0]]); }, n.rotate = function (n) { return n ? e([n[0], n[1], n.length > 2 ? n[2] + 90 : 90]) : (n = e(), [n[0], n[1], n[2] - 90]); }, e([0, 0, 90]); }).raw = Er, ta.geom = {}, ta.geom.hull = function (n) { function t(n) { if (n.length < 3)\n        return []; var t, u = Et(e), i = Et(r), o = n.length, a = [], c = []; for (t = 0; o > t; t++)\n        a.push([+u.call(this, n[t], t), +i.call(this, n[t], t), t]); for (a.sort(zr), t = 0; o > t; t++)\n        c.push([a[t][0], -a[t][1]]); var l = Cr(a), s = Cr(c), f = s[0] === l[0], h = s[s.length - 1] === l[l.length - 1], g = []; for (t = l.length - 1; t >= 0; --t)\n        g.push(n[a[l[t]][2]]); for (t = +f; t < s.length - h; ++t)\n        g.push(n[a[s[t]][2]]); return g; } var e = Ar, r = Nr; return arguments.length ? t(n) : (t.x = function (n) { return arguments.length ? (e = n, t) : e; }, t.y = function (n) { return arguments.length ? (r = n, t) : r; }, t); }, ta.geom.polygon = function (n) { return ya(n, Jc), n; };\n    var Jc = ta.geom.polygon.prototype = [];\n    Jc.area = function () { for (var n, t = -1, e = this.length, r = this[e - 1], u = 0; ++t < e;)\n        n = r, r = this[t], u += n[1] * r[0] - n[0] * r[1]; return .5 * u; }, Jc.centroid = function (n) { var t, e, r = -1, u = this.length, i = 0, o = 0, a = this[u - 1]; for (arguments.length || (n = -1 / (6 * this.area())); ++r < u;)\n        t = a, a = this[r], e = t[0] * a[1] - a[0] * t[1], i += (t[0] + a[0]) * e, o += (t[1] + a[1]) * e; return [i * n, o * n]; }, Jc.clip = function (n) { for (var t, e, r, u, i, o, a = Tr(n), c = -1, l = this.length - Tr(this), s = this[l - 1]; ++c < l;) {\n        for (t = n.slice(), n.length = 0, u = this[c], i = t[(r = t.length - a) - 1], e = -1; ++e < r;)\n            o = t[e], qr(o, s, u) ? (qr(i, s, u) || n.push(Lr(i, o, s, u)), n.push(o)) : qr(i, s, u) && n.push(Lr(i, o, s, u)), i = o;\n        a && n.push(n[0]), s = u;\n    } return n; };\n    var Gc, Kc, Qc, nl, tl, el = [], rl = [];\n    Or.prototype.prepare = function () { for (var n, t = this.edges, e = t.length; e--;)\n        n = t[e].edge, n.b && n.a || t.splice(e, 1); return t.sort(Yr), t.length; }, Qr.prototype = { start: function () { return this.edge.l === this.site ? this.edge.a : this.edge.b; }, end: function () { return this.edge.l === this.site ? this.edge.b : this.edge.a; } }, nu.prototype = { insert: function (n, t) { var e, r, u; if (n) {\n            if (t.P = n, t.N = n.N, n.N && (n.N.P = t), n.N = t, n.R) {\n                for (n = n.R; n.L;)\n                    n = n.L;\n                n.L = t;\n            }\n            else\n                n.R = t;\n            e = n;\n        }\n        else\n            this._ ? (n = uu(this._), t.P = null, t.N = n, n.P = n.L = t, e = n) : (t.P = t.N = null, this._ = t, e = null); for (t.L = t.R = null, t.U = e, t.C = !0, n = t; e && e.C;)\n            r = e.U, e === r.L ? (u = r.R, u && u.C ? (e.C = u.C = !1, r.C = !0, n = r) : (n === e.R && (eu(this, e), n = e, e = n.U), e.C = !1, r.C = !0, ru(this, r))) : (u = r.L, u && u.C ? (e.C = u.C = !1, r.C = !0, n = r) : (n === e.L && (ru(this, e), n = e, e = n.U), e.C = !1, r.C = !0, eu(this, r))), e = n.U; this._.C = !1; }, remove: function (n) { n.N && (n.N.P = n.P), n.P && (n.P.N = n.N), n.N = n.P = null; var t, e, r, u = n.U, i = n.L, o = n.R; if (e = i ? o ? uu(o) : i : o, u ? u.L === n ? u.L = e : u.R = e : this._ = e, i && o ? (r = e.C, e.C = n.C, e.L = i, i.U = e, e !== o ? (u = e.U, e.U = n.U, n = e.R, u.L = n, e.R = o, o.U = e) : (e.U = u, u = e, n = e.R)) : (r = n.C, n = e), n && (n.U = u), !r) {\n            if (n && n.C)\n                return void (n.C = !1);\n            do {\n                if (n === this._)\n                    break;\n                if (n === u.L) {\n                    if (t = u.R, t.C && (t.C = !1, u.C = !0, eu(this, u), t = u.R), t.L && t.L.C || t.R && t.R.C) {\n                        t.R && t.R.C || (t.L.C = !1, t.C = !0, ru(this, t), t = u.R), t.C = u.C, u.C = t.R.C = !1, eu(this, u), n = this._;\n                        break;\n                    }\n                }\n                else if (t = u.L, t.C && (t.C = !1, u.C = !0, ru(this, u), t = u.L), t.L && t.L.C || t.R && t.R.C) {\n                    t.L && t.L.C || (t.R.C = !1, t.C = !0, eu(this, t), t = u.L), t.C = u.C, u.C = t.L.C = !1, ru(this, u), n = this._;\n                    break;\n                }\n                t.C = !0, n = u, u = u.U;\n            } while (!n.C);\n            n && (n.C = !1);\n        } } }, ta.geom.voronoi = function (n) { function t(n) { var t = new Array(n.length), r = a[0][0], u = a[0][1], i = a[1][0], o = a[1][1]; return iu(e(n), a).cells.forEach(function (e, a) { var c = e.edges, l = e.site, s = t[a] = c.length ? c.map(function (n) { var t = n.start(); return [t.x, t.y]; }) : l.x >= r && l.x <= i && l.y >= u && l.y <= o ? [[r, o], [i, o], [i, u], [r, u]] : []; s.point = n[a]; }), t; } function e(n) { return n.map(function (n, t) { return { x: Math.round(i(n, t) / Ca) * Ca, y: Math.round(o(n, t) / Ca) * Ca, i: t }; }); } var r = Ar, u = Nr, i = r, o = u, a = ul; return n ? t(n) : (t.links = function (n) { return iu(e(n)).edges.filter(function (n) { return n.l && n.r; }).map(function (t) { return { source: n[t.l.i], target: n[t.r.i] }; }); }, t.triangles = function (n) { var t = []; return iu(e(n)).cells.forEach(function (e, r) { for (var u, i, o = e.site, a = e.edges.sort(Yr), c = -1, l = a.length, s = a[l - 1].edge, f = s.l === o ? s.r : s.l; ++c < l;)\n        u = s, i = f, s = a[c].edge, f = s.l === o ? s.r : s.l, r < i.i && r < f.i && au(o, i, f) < 0 && t.push([n[r], n[i.i], n[f.i]]); }), t; }, t.x = function (n) { return arguments.length ? (i = Et(r = n), t) : r; }, t.y = function (n) { return arguments.length ? (o = Et(u = n), t) : u; }, t.clipExtent = function (n) { return arguments.length ? (a = null == n ? ul : n, t) : a === ul ? null : a; }, t.size = function (n) { return arguments.length ? t.clipExtent(n && [[0, 0], n]) : a === ul ? null : a && a[1]; }, t); };\n    var ul = [[-1e6, -1e6], [1e6, 1e6]];\n    ta.geom.delaunay = function (n) { return ta.geom.voronoi().triangles(n); }, ta.geom.quadtree = function (n, t, e, r, u) { function i(n) { function i(n, t, e, r, u, i, o, a) { if (!isNaN(e) && !isNaN(r))\n        if (n.leaf) {\n            var c = n.x, s = n.y;\n            if (null != c)\n                if (ga(c - e) + ga(s - r) < .01)\n                    l(n, t, e, r, u, i, o, a);\n                else {\n                    var f = n.point;\n                    n.x = n.y = n.point = null, l(n, f, c, s, u, i, o, a), l(n, t, e, r, u, i, o, a);\n                }\n            else\n                n.x = e, n.y = r, n.point = t;\n        }\n        else\n            l(n, t, e, r, u, i, o, a); } function l(n, t, e, r, u, o, a, c) { var l = .5 * (u + a), s = .5 * (o + c), f = e >= l, h = r >= s, g = h << 1 | f; n.leaf = !1, n = n.nodes[g] || (n.nodes[g] = su()), f ? u = l : a = l, h ? o = s : c = s, i(n, t, e, r, u, o, a, c); } var s, f, h, g, p, v, d, m, y, M = Et(a), x = Et(c); if (null != t)\n        v = t, d = e, m = r, y = u;\n    else if (m = y = -(v = d = 1 / 0), f = [], h = [], p = n.length, o)\n        for (g = 0; p > g; ++g)\n            s = n[g], s.x < v && (v = s.x), s.y < d && (d = s.y), s.x > m && (m = s.x), s.y > y && (y = s.y), f.push(s.x), h.push(s.y);\n    else\n        for (g = 0; p > g; ++g) {\n            var b = +M(s = n[g], g), _ = +x(s, g);\n            v > b && (v = b), d > _ && (d = _), b > m && (m = b), _ > y && (y = _), f.push(b), h.push(_);\n        } var w = m - v, S = y - d; w > S ? y = d + w : m = v + S; var k = su(); if (k.add = function (n) { i(k, n, +M(n, ++g), +x(n, g), v, d, m, y); }, k.visit = function (n) { fu(n, k, v, d, m, y); }, k.find = function (n) { return hu(k, n[0], n[1], v, d, m, y); }, g = -1, null == t) {\n        for (; ++g < p;)\n            i(k, n[g], f[g], h[g], v, d, m, y);\n        --g;\n    }\n    else\n        n.forEach(k.add); return f = h = n = s = null, k; } var o, a = Ar, c = Nr; return (o = arguments.length) ? (a = cu, c = lu, 3 === o && (u = e, r = t, e = t = 0), i(n)) : (i.x = function (n) { return arguments.length ? (a = n, i) : a; }, i.y = function (n) { return arguments.length ? (c = n, i) : c; }, i.extent = function (n) { return arguments.length ? (null == n ? t = e = r = u = null : (t = +n[0][0], e = +n[0][1], r = +n[1][0], u = +n[1][1]), i) : null == t ? null : [[t, e], [r, u]]; }, i.size = function (n) { return arguments.length ? (null == n ? t = e = r = u = null : (t = e = 0, r = +n[0], u = +n[1]), i) : null == t ? null : [r - t, u - e]; }, i); }, ta.interpolateRgb = gu, ta.interpolateObject = pu, ta.interpolateNumber = vu, ta.interpolateString = du;\n    var il = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g, ol = new RegExp(il.source, \"g\");\n    ta.interpolate = mu, ta.interpolators = [function (n, t) { var e = typeof t; return (\"string\" === e ? Ga.has(t) || /^(#|rgb\\(|hsl\\()/.test(t) ? gu : du : t instanceof ot ? gu : Array.isArray(t) ? yu : \"object\" === e && isNaN(t) ? pu : vu)(n, t); }], ta.interpolateArray = yu;\n    var al = function () { return y; }, cl = ta.map({ linear: al, poly: ku, quad: function () { return _u; }, cubic: function () { return wu; }, sin: function () { return Eu; }, exp: function () { return Au; }, circle: function () { return Nu; }, elastic: Cu, back: zu, bounce: function () { return qu; } }), ll = ta.map({ \"in\": y, out: xu, \"in-out\": bu, \"out-in\": function (n) { return bu(xu(n)); } });\n    ta.ease = function (n) { var t = n.indexOf(\"-\"), e = t >= 0 ? n.slice(0, t) : n, r = t >= 0 ? n.slice(t + 1) : \"in\"; return e = cl.get(e) || al, r = ll.get(r) || y, Mu(r(e.apply(null, ea.call(arguments, 1)))); }, ta.interpolateHcl = Lu, ta.interpolateHsl = Tu, ta.interpolateLab = Ru, ta.interpolateRound = Du, ta.transform = function (n) { var t = ua.createElementNS(ta.ns.prefix.svg, \"g\"); return (ta.transform = function (n) { if (null != n) {\n        t.setAttribute(\"transform\", n);\n        var e = t.transform.baseVal.consolidate();\n    } return new Pu(e ? e.matrix : sl); })(n); }, Pu.prototype.toString = function () { return \"translate(\" + this.translate + \")rotate(\" + this.rotate + \")skewX(\" + this.skew + \")scale(\" + this.scale + \")\"; };\n    var sl = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };\n    ta.interpolateTransform = Hu, ta.layout = {}, ta.layout.bundle = function () { return function (n) { for (var t = [], e = -1, r = n.length; ++e < r;)\n        t.push(Yu(n[e])); return t; }; }, ta.layout.chord = function () { function n() { var n, l, f, h, g, p = {}, v = [], d = ta.range(i), m = []; for (e = [], r = [], n = 0, h = -1; ++h < i;) {\n        for (l = 0, g = -1; ++g < i;)\n            l += u[h][g];\n        v.push(l), m.push(ta.range(i)), n += l;\n    } for (o && d.sort(function (n, t) { return o(v[n], v[t]); }), a && m.forEach(function (n, t) { n.sort(function (n, e) { return a(u[t][n], u[t][e]); }); }), n = (La - s * i) / n, l = 0, h = -1; ++h < i;) {\n        for (f = l, g = -1; ++g < i;) {\n            var y = d[h], M = m[y][g], x = u[y][M], b = l, _ = l += x * n;\n            p[y + \"-\" + M] = { index: y, subindex: M, startAngle: b, endAngle: _, value: x };\n        }\n        r[y] = { index: y, startAngle: f, endAngle: l, value: (l - f) / n }, l += s;\n    } for (h = -1; ++h < i;)\n        for (g = h - 1; ++g < i;) {\n            var w = p[h + \"-\" + g], S = p[g + \"-\" + h];\n            (w.value || S.value) && e.push(w.value < S.value ? { source: S, target: w } : { source: w, target: S });\n        } c && t(); } function t() { e.sort(function (n, t) { return c((n.source.value + n.target.value) / 2, (t.source.value + t.target.value) / 2); }); } var e, r, u, i, o, a, c, l = {}, s = 0; return l.matrix = function (n) { return arguments.length ? (i = (u = n) && u.length, e = r = null, l) : u; }, l.padding = function (n) { return arguments.length ? (s = n, e = r = null, l) : s; }, l.sortGroups = function (n) { return arguments.length ? (o = n, e = r = null, l) : o; }, l.sortSubgroups = function (n) { return arguments.length ? (a = n, e = null, l) : a; }, l.sortChords = function (n) { return arguments.length ? (c = n, e && t(), l) : c; }, l.chords = function () { return e || n(), e; }, l.groups = function () { return r || n(), r; }, l; }, ta.layout.force = function () { function n(n) { return function (t, e, r, u) { if (t.point !== n) {\n        var i = t.cx - n.x, o = t.cy - n.y, a = u - e, c = i * i + o * o;\n        if (c > a * a / d) {\n            if (p > c) {\n                var l = t.charge / c;\n                n.px -= i * l, n.py -= o * l;\n            }\n            return !0;\n        }\n        if (t.point && c && p > c) {\n            var l = t.pointCharge / c;\n            n.px -= i * l, n.py -= o * l;\n        }\n    } return !t.charge; }; } function t(n) { n.px = ta.event.x, n.py = ta.event.y, a.resume(); } var e, r, u, i, o, a = {}, c = ta.dispatch(\"start\", \"tick\", \"end\"), l = [1, 1], s = .9, f = fl, h = hl, g = -30, p = gl, v = .1, d = .64, m = [], M = []; return a.tick = function () { if ((r *= .99) < .005)\n        return c.end({ type: \"end\", alpha: r = 0 }), !0; var t, e, a, f, h, p, d, y, x, b = m.length, _ = M.length; for (e = 0; _ > e; ++e)\n        a = M[e], f = a.source, h = a.target, y = h.x - f.x, x = h.y - f.y, (p = y * y + x * x) && (p = r * i[e] * ((p = Math.sqrt(p)) - u[e]) / p, y *= p, x *= p, h.x -= y * (d = f.weight / (h.weight + f.weight)), h.y -= x * d, f.x += y * (d = 1 - d), f.y += x * d); if ((d = r * v) && (y = l[0] / 2, x = l[1] / 2, e = -1, d))\n        for (; ++e < b;)\n            a = m[e], a.x += (y - a.x) * d, a.y += (x - a.y) * d; if (g)\n        for (Ju(t = ta.geom.quadtree(m), r, o), e = -1; ++e < b;)\n            (a = m[e]).fixed || t.visit(n(a)); for (e = -1; ++e < b;)\n        a = m[e], a.fixed ? (a.x = a.px, a.y = a.py) : (a.x -= (a.px - (a.px = a.x)) * s, a.y -= (a.py - (a.py = a.y)) * s); c.tick({ type: \"tick\", alpha: r }); }, a.nodes = function (n) { return arguments.length ? (m = n, a) : m; }, a.links = function (n) { return arguments.length ? (M = n, a) : M; }, a.size = function (n) { return arguments.length ? (l = n, a) : l; }, a.linkDistance = function (n) { return arguments.length ? (f = \"function\" == typeof n ? n : +n, a) : f; }, a.distance = a.linkDistance, a.linkStrength = function (n) { return arguments.length ? (h = \"function\" == typeof n ? n : +n, a) : h; }, a.friction = function (n) { return arguments.length ? (s = +n, a) : s; }, a.charge = function (n) { return arguments.length ? (g = \"function\" == typeof n ? n : +n, a) : g; }, a.chargeDistance = function (n) { return arguments.length ? (p = n * n, a) : Math.sqrt(p); }, a.gravity = function (n) { return arguments.length ? (v = +n, a) : v; }, a.theta = function (n) { return arguments.length ? (d = n * n, a) : Math.sqrt(d); }, a.alpha = function (n) { return arguments.length ? (n = +n, r ? r = n > 0 ? n : 0 : n > 0 && (c.start({ type: \"start\", alpha: r = n }), ta.timer(a.tick)), a) : r; }, a.start = function () { function n(n, r) { if (!e) {\n        for (e = new Array(c), a = 0; c > a; ++a)\n            e[a] = [];\n        for (a = 0; s > a; ++a) {\n            var u = M[a];\n            e[u.source.index].push(u.target), e[u.target.index].push(u.source);\n        }\n    } for (var i, o = e[t], a = -1, l = o.length; ++a < l;)\n        if (!isNaN(i = o[a][n]))\n            return i; return Math.random() * r; } var t, e, r, c = m.length, s = M.length, p = l[0], v = l[1]; for (t = 0; c > t; ++t)\n        (r = m[t]).index = t, r.weight = 0; for (t = 0; s > t; ++t)\n        r = M[t], \"number\" == typeof r.source && (r.source = m[r.source]), \"number\" == typeof r.target && (r.target = m[r.target]), ++r.source.weight, ++r.target.weight; for (t = 0; c > t; ++t)\n        r = m[t], isNaN(r.x) && (r.x = n(\"x\", p)), isNaN(r.y) && (r.y = n(\"y\", v)), isNaN(r.px) && (r.px = r.x), isNaN(r.py) && (r.py = r.y); if (u = [], \"function\" == typeof f)\n        for (t = 0; s > t; ++t)\n            u[t] = +f.call(this, M[t], t);\n    else\n        for (t = 0; s > t; ++t)\n            u[t] = f; if (i = [], \"function\" == typeof h)\n        for (t = 0; s > t; ++t)\n            i[t] = +h.call(this, M[t], t);\n    else\n        for (t = 0; s > t; ++t)\n            i[t] = h; if (o = [], \"function\" == typeof g)\n        for (t = 0; c > t; ++t)\n            o[t] = +g.call(this, m[t], t);\n    else\n        for (t = 0; c > t; ++t)\n            o[t] = g; return a.resume(); }, a.resume = function () { return a.alpha(.1); }, a.stop = function () { return a.alpha(0); }, a.drag = function () { return e || (e = ta.behavior.drag().origin(y).on(\"dragstart.force\", Xu).on(\"drag.force\", t).on(\"dragend.force\", $u)), arguments.length ? void this.on(\"mouseover.force\", Bu).on(\"mouseout.force\", Wu).call(e) : e; }, ta.rebind(a, c, \"on\"); };\n    var fl = 20, hl = 1, gl = 1 / 0;\n    ta.layout.hierarchy = function () { function n(u) { var i, o = [u], a = []; for (u.depth = 0; null != (i = o.pop());)\n        if (a.push(i), (l = e.call(n, i, i.depth)) && (c = l.length)) {\n            for (var c, l, s; --c >= 0;)\n                o.push(s = l[c]), s.parent = i, s.depth = i.depth + 1;\n            r && (i.value = 0), i.children = l;\n        }\n        else\n            r && (i.value = +r.call(n, i, i.depth) || 0), delete i.children; return Qu(u, function (n) { var e, u; t && (e = n.children) && e.sort(t), r && (u = n.parent) && (u.value += n.value); }), a; } var t = ei, e = ni, r = ti; return n.sort = function (e) { return arguments.length ? (t = e, n) : t; }, n.children = function (t) { return arguments.length ? (e = t, n) : e; }, n.value = function (t) { return arguments.length ? (r = t, n) : r; }, n.revalue = function (t) { return r && (Ku(t, function (n) { n.children && (n.value = 0); }), Qu(t, function (t) { var e; t.children || (t.value = +r.call(n, t, t.depth) || 0), (e = t.parent) && (e.value += t.value); })), t; }, n; }, ta.layout.partition = function () { function n(t, e, r, u) { var i = t.children; if (t.x = e, t.y = t.depth * u, t.dx = r, t.dy = u, i && (o = i.length)) {\n        var o, a, c, l = -1;\n        for (r = t.value ? r / t.value : 0; ++l < o;)\n            n(a = i[l], e, c = a.value * r, u), e += c;\n    } } function t(n) { var e = n.children, r = 0; if (e && (u = e.length))\n        for (var u, i = -1; ++i < u;)\n            r = Math.max(r, t(e[i])); return 1 + r; } function e(e, i) { var o = r.call(this, e, i); return n(o[0], 0, u[0], u[1] / t(o[0])), o; } var r = ta.layout.hierarchy(), u = [1, 1]; return e.size = function (n) { return arguments.length ? (u = n, e) : u; }, Gu(e, r); }, ta.layout.pie = function () { function n(o) { var a, c = o.length, l = o.map(function (e, r) { return +t.call(n, e, r); }), s = +(\"function\" == typeof r ? r.apply(this, arguments) : r), f = (\"function\" == typeof u ? u.apply(this, arguments) : u) - s, h = Math.min(Math.abs(f) / c, +(\"function\" == typeof i ? i.apply(this, arguments) : i)), g = h * (0 > f ? -1 : 1), p = (f - c * g) / ta.sum(l), v = ta.range(c), d = []; return null != e && v.sort(e === pl ? function (n, t) { return l[t] - l[n]; } : function (n, t) { return e(o[n], o[t]); }), v.forEach(function (n) { d[n] = { data: o[n], value: a = l[n], startAngle: s, endAngle: s += a * p + g, padAngle: h }; }), d; } var t = Number, e = pl, r = 0, u = La, i = 0; return n.value = function (e) { return arguments.length ? (t = e, n) : t; }, n.sort = function (t) { return arguments.length ? (e = t, n) : e; }, n.startAngle = function (t) { return arguments.length ? (r = t, n) : r; }, n.endAngle = function (t) { return arguments.length ? (u = t, n) : u; }, n.padAngle = function (t) { return arguments.length ? (i = t, n) : i; }, n; };\n    var pl = {};\n    ta.layout.stack = function () { function n(a, c) { if (!(h = a.length))\n        return a; var l = a.map(function (e, r) { return t.call(n, e, r); }), s = l.map(function (t) { return t.map(function (t, e) { return [i.call(n, t, e), o.call(n, t, e)]; }); }), f = e.call(n, s, c); l = ta.permute(l, f), s = ta.permute(s, f); var h, g, p, v, d = r.call(n, s, c), m = l[0].length; for (p = 0; m > p; ++p)\n        for (u.call(n, l[0][p], v = d[p], s[0][p][1]), g = 1; h > g; ++g)\n            u.call(n, l[g][p], v += s[g - 1][p][1], s[g][p][1]); return a; } var t = y, e = ai, r = ci, u = oi, i = ui, o = ii; return n.values = function (e) { return arguments.length ? (t = e, n) : t; }, n.order = function (t) { return arguments.length ? (e = \"function\" == typeof t ? t : vl.get(t) || ai, n) : e; }, n.offset = function (t) { return arguments.length ? (r = \"function\" == typeof t ? t : dl.get(t) || ci, n) : r; }, n.x = function (t) { return arguments.length ? (i = t, n) : i; }, n.y = function (t) { return arguments.length ? (o = t, n) : o; }, n.out = function (t) { return arguments.length ? (u = t, n) : u; }, n; };\n    var vl = ta.map({ \"inside-out\": function (n) { var t, e, r = n.length, u = n.map(li), i = n.map(si), o = ta.range(r).sort(function (n, t) { return u[n] - u[t]; }), a = 0, c = 0, l = [], s = []; for (t = 0; r > t; ++t)\n            e = o[t], c > a ? (a += i[e], l.push(e)) : (c += i[e], s.push(e)); return s.reverse().concat(l); }, reverse: function (n) { return ta.range(n.length).reverse(); }, \"default\": ai }), dl = ta.map({ silhouette: function (n) { var t, e, r, u = n.length, i = n[0].length, o = [], a = 0, c = []; for (e = 0; i > e; ++e) {\n            for (t = 0, r = 0; u > t; t++)\n                r += n[t][e][1];\n            r > a && (a = r), o.push(r);\n        } for (e = 0; i > e; ++e)\n            c[e] = (a - o[e]) / 2; return c; }, wiggle: function (n) { var t, e, r, u, i, o, a, c, l, s = n.length, f = n[0], h = f.length, g = []; for (g[0] = c = l = 0, e = 1; h > e; ++e) {\n            for (t = 0, u = 0; s > t; ++t)\n                u += n[t][e][1];\n            for (t = 0, i = 0, a = f[e][0] - f[e - 1][0]; s > t; ++t) {\n                for (r = 0, o = (n[t][e][1] - n[t][e - 1][1]) / (2 * a); t > r; ++r)\n                    o += (n[r][e][1] - n[r][e - 1][1]) / a;\n                i += o * n[t][e][1];\n            }\n            g[e] = c -= u ? i / u * a : 0, l > c && (l = c);\n        } for (e = 0; h > e; ++e)\n            g[e] -= l; return g; }, expand: function (n) { var t, e, r, u = n.length, i = n[0].length, o = 1 / u, a = []; for (e = 0; i > e; ++e) {\n            for (t = 0, r = 0; u > t; t++)\n                r += n[t][e][1];\n            if (r)\n                for (t = 0; u > t; t++)\n                    n[t][e][1] /= r;\n            else\n                for (t = 0; u > t; t++)\n                    n[t][e][1] = o;\n        } for (e = 0; i > e; ++e)\n            a[e] = 0; return a; }, zero: ci });\n    ta.layout.histogram = function () { function n(n, i) { for (var o, a, c = [], l = n.map(e, this), s = r.call(this, l, i), f = u.call(this, s, l, i), i = -1, h = l.length, g = f.length - 1, p = t ? 1 : 1 / h; ++i < g;)\n        o = c[i] = [], o.dx = f[i + 1] - (o.x = f[i]), o.y = 0; if (g > 0)\n        for (i = -1; ++i < h;)\n            a = l[i], a >= s[0] && a <= s[1] && (o = c[ta.bisect(f, a, 1, g) - 1], o.y += p, o.push(n[i])); return c; } var t = !0, e = Number, r = pi, u = hi; return n.value = function (t) { return arguments.length ? (e = t, n) : e; }, n.range = function (t) { return arguments.length ? (r = Et(t), n) : r; }, n.bins = function (t) { return arguments.length ? (u = \"number\" == typeof t ? function (n) { return gi(n, t); } : Et(t), n) : u; }, n.frequency = function (e) { return arguments.length ? (t = !!e, n) : t; }, n; }, ta.layout.pack = function () { function n(n, i) { var o = e.call(this, n, i), a = o[0], c = u[0], l = u[1], s = null == t ? Math.sqrt : \"function\" == typeof t ? t : function () { return t; }; if (a.x = a.y = 0, Qu(a, function (n) { n.r = +s(n.value); }), Qu(a, Mi), r) {\n        var f = r * (t ? 1 : Math.max(2 * a.r / c, 2 * a.r / l)) / 2;\n        Qu(a, function (n) { n.r += f; }), Qu(a, Mi), Qu(a, function (n) { n.r -= f; });\n    } return _i(a, c / 2, l / 2, t ? 1 : 1 / Math.max(2 * a.r / c, 2 * a.r / l)), o; } var t, e = ta.layout.hierarchy().sort(vi), r = 0, u = [1, 1]; return n.size = function (t) { return arguments.length ? (u = t, n) : u; }, n.radius = function (e) { return arguments.length ? (t = null == e || \"function\" == typeof e ? e : +e, n) : t; }, n.padding = function (t) { return arguments.length ? (r = +t, n) : r; }, Gu(n, e); }, ta.layout.tree = function () { function n(n, u) { var s = o.call(this, n, u), f = s[0], h = t(f); if (Qu(h, e), h.parent.m = -h.z, Ku(h, r), l)\n        Ku(f, i);\n    else {\n        var g = f, p = f, v = f;\n        Ku(f, function (n) { n.x < g.x && (g = n), n.x > p.x && (p = n), n.depth > v.depth && (v = n); });\n        var d = a(g, p) / 2 - g.x, m = c[0] / (p.x + a(p, g) / 2 + d), y = c[1] / (v.depth || 1);\n        Ku(f, function (n) { n.x = (n.x + d) * m, n.y = n.depth * y; });\n    } return s; } function t(n) { for (var t, e = { A: null, children: [n] }, r = [e]; null != (t = r.pop());)\n        for (var u, i = t.children, o = 0, a = i.length; a > o; ++o)\n            r.push((i[o] = u = { _: i[o], parent: t, children: (u = i[o].children) && u.slice() || [], A: null, a: null, z: 0, m: 0, c: 0, s: 0, t: null, i: o }).a = u); return e.children[0]; } function e(n) { var t = n.children, e = n.parent.children, r = n.i ? e[n.i - 1] : null; if (t.length) {\n        Ni(n);\n        var i = (t[0].z + t[t.length - 1].z) / 2;\n        r ? (n.z = r.z + a(n._, r._), n.m = n.z - i) : n.z = i;\n    }\n    else\n        r && (n.z = r.z + a(n._, r._)); n.parent.A = u(n, r, n.parent.A || e[0]); } function r(n) { n._.x = n.z + n.parent.m, n.m += n.parent.m; } function u(n, t, e) { if (t) {\n        for (var r, u = n, i = n, o = t, c = u.parent.children[0], l = u.m, s = i.m, f = o.m, h = c.m; o = Ei(o), u = ki(u), o && u;)\n            c = ki(c), i = Ei(i), i.a = n, r = o.z + f - u.z - l + a(o._, u._), r > 0 && (Ai(Ci(o, n, e), n, r), l += r, s += r), f += o.m, l += u.m, h += c.m, s += i.m;\n        o && !Ei(i) && (i.t = o, i.m += f - s), u && !ki(c) && (c.t = u, c.m += l - h, e = n);\n    } return e; } function i(n) { n.x *= c[0], n.y = n.depth * c[1]; } var o = ta.layout.hierarchy().sort(null).value(null), a = Si, c = [1, 1], l = null; return n.separation = function (t) { return arguments.length ? (a = t, n) : a; }, n.size = function (t) { return arguments.length ? (l = null == (c = t) ? i : null, n) : l ? null : c; }, n.nodeSize = function (t) { return arguments.length ? (l = null == (c = t) ? null : i, n) : l ? c : null; }, Gu(n, o); }, ta.layout.cluster = function () { function n(n, i) { var o, a = t.call(this, n, i), c = a[0], l = 0; Qu(c, function (n) { var t = n.children; t && t.length ? (n.x = qi(t), n.y = zi(t)) : (n.x = o ? l += e(n, o) : 0, n.y = 0, o = n); }); var s = Li(c), f = Ti(c), h = s.x - e(s, f) / 2, g = f.x + e(f, s) / 2; return Qu(c, u ? function (n) { n.x = (n.x - c.x) * r[0], n.y = (c.y - n.y) * r[1]; } : function (n) { n.x = (n.x - h) / (g - h) * r[0], n.y = (1 - (c.y ? n.y / c.y : 1)) * r[1]; }), a; } var t = ta.layout.hierarchy().sort(null).value(null), e = Si, r = [1, 1], u = !1; return n.separation = function (t) { return arguments.length ? (e = t, n) : e; }, n.size = function (t) { return arguments.length ? (u = null == (r = t), n) : u ? null : r; }, n.nodeSize = function (t) { return arguments.length ? (u = null != (r = t), n) : u ? r : null; }, Gu(n, t); }, ta.layout.treemap = function () {\n        function n(n, t) { for (var e, r, u = -1, i = n.length; ++u < i;)\n            r = (e = n[u]).value * (0 > t ? 0 : t), e.area = isNaN(r) || 0 >= r ? 0 : r; }\n        function t(e) { var i = e.children; if (i && i.length) {\n            var o, a, c, l = f(e), s = [], h = i.slice(), p = 1 / 0, v = \"slice\" === g ? l.dx : \"dice\" === g ? l.dy : \"slice-dice\" === g ? 1 & e.depth ? l.dy : l.dx : Math.min(l.dx, l.dy);\n            for (n(h, l.dx * l.dy / e.value), s.area = 0; (c = h.length) > 0;)\n                s.push(o = h[c - 1]), s.area += o.area, \"squarify\" !== g || (a = r(s, v)) <= p ? (h.pop(), p = a) : (s.area -= s.pop().area, u(s, v, l, !1), v = Math.min(l.dx, l.dy), s.length = s.area = 0, p = 1 / 0);\n            s.length && (u(s, v, l, !0), s.length = s.area = 0), i.forEach(t);\n        } }\n        function e(t) { var r = t.children; if (r && r.length) {\n            var i, o = f(t), a = r.slice(), c = [];\n            for (n(a, o.dx * o.dy / t.value), c.area = 0; i = a.pop();)\n                c.push(i), c.area += i.area, null != i.z && (u(c, i.z ? o.dx : o.dy, o, !a.length), c.length = c.area = 0);\n            r.forEach(e);\n        } }\n        function r(n, t) { for (var e, r = n.area, u = 0, i = 1 / 0, o = -1, a = n.length; ++o < a;)\n            (e = n[o].area) && (i > e && (i = e), e > u && (u = e)); return r *= r, t *= t, r ? Math.max(t * u * p / r, r / (t * i * p)) : 1 / 0; }\n        function u(n, t, e, r) { var u, i = -1, o = n.length, a = e.x, l = e.y, s = t ? c(n.area / t) : 0; if (t == e.dx) {\n            for ((r || s > e.dy) && (s = e.dy); ++i < o;)\n                u = n[i], u.x = a, u.y = l, u.dy = s, a += u.dx = Math.min(e.x + e.dx - a, s ? c(u.area / s) : 0);\n            u.z = !0, u.dx += e.x + e.dx - a, e.y += s, e.dy -= s;\n        }\n        else {\n            for ((r || s > e.dx) && (s = e.dx); ++i < o;)\n                u = n[i], u.x = a, u.y = l, u.dx = s, l += u.dy = Math.min(e.y + e.dy - l, s ? c(u.area / s) : 0);\n            u.z = !1, u.dy += e.y + e.dy - l, e.x += s, e.dx -= s;\n        } }\n        function i(r) { var u = o || a(r), i = u[0]; return i.x = 0, i.y = 0, i.dx = l[0], i.dy = l[1], o && a.revalue(i), n([i], i.dx * i.dy / i.value), (o ? e : t)(i), h && (o = u), u; }\n        var o, a = ta.layout.hierarchy(), c = Math.round, l = [1, 1], s = null, f = Ri, h = !1, g = \"squarify\", p = .5 * (1 + Math.sqrt(5));\n        return i.size = function (n) { return arguments.length ? (l = n, i) : l; }, i.padding = function (n) { function t(t) { var e = n.call(i, t, t.depth); return null == e ? Ri(t) : Di(t, \"number\" == typeof e ? [e, e, e, e] : e); } function e(t) { return Di(t, n); } if (!arguments.length)\n            return s; var r; return f = null == (s = n) ? Ri : \"function\" == (r = typeof n) ? t : \"number\" === r ? (n = [n, n, n, n], e) : e, i; }, i.round = function (n) { return arguments.length ? (c = n ? Math.round : Number, i) : c != Number; }, i.sticky = function (n) { return arguments.length ? (h = n, o = null, i) : h; }, i.ratio = function (n) { return arguments.length ? (p = n, i) : p; }, i.mode = function (n) { return arguments.length ? (g = n + \"\", i) : g; }, Gu(i, a);\n    }, ta.random = { normal: function (n, t) { var e = arguments.length; return 2 > e && (t = 1), 1 > e && (n = 0), function () { var e, r, u; do\n            e = 2 * Math.random() - 1, r = 2 * Math.random() - 1, u = e * e + r * r;\n        while (!u || u > 1); return n + t * e * Math.sqrt(-2 * Math.log(u) / u); }; }, logNormal: function () { var n = ta.random.normal.apply(ta, arguments); return function () { return Math.exp(n()); }; }, bates: function (n) { var t = ta.random.irwinHall(n); return function () { return t() / n; }; }, irwinHall: function (n) { return function () { for (var t = 0, e = 0; n > e; e++)\n            t += Math.random(); return t; }; } }, ta.scale = {};\n    var ml = { floor: y, ceil: y };\n    ta.scale.linear = function () { return Ii([0, 1], [0, 1], mu, !1); };\n    var yl = { s: 1, g: 1, p: 1, r: 1, e: 1 };\n    ta.scale.log = function () { return Ji(ta.scale.linear().domain([0, 1]), 10, !0, [1, 10]); };\n    var Ml = ta.format(\".0e\"), xl = { floor: function (n) { return -Math.ceil(-n); }, ceil: function (n) { return -Math.floor(-n); } };\n    ta.scale.pow = function () { return Gi(ta.scale.linear(), 1, [0, 1]); }, ta.scale.sqrt = function () { return ta.scale.pow().exponent(.5); }, ta.scale.ordinal = function () { return Qi([], { t: \"range\", a: [[]] }); }, ta.scale.category10 = function () { return ta.scale.ordinal().range(bl); }, ta.scale.category20 = function () { return ta.scale.ordinal().range(_l); }, ta.scale.category20b = function () { return ta.scale.ordinal().range(wl); }, ta.scale.category20c = function () { return ta.scale.ordinal().range(Sl); };\n    var bl = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(Mt), _l = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(Mt), wl = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(Mt), Sl = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(Mt);\n    ta.scale.quantile = function () { return no([], []); }, ta.scale.quantize = function () { return to(0, 1, [0, 1]); }, ta.scale.threshold = function () { return eo([.5], [0, 1]); }, ta.scale.identity = function () { return ro([0, 1]); }, ta.svg = {}, ta.svg.arc = function () { function n() { var n = Math.max(0, +e.apply(this, arguments)), l = Math.max(0, +r.apply(this, arguments)), s = o.apply(this, arguments) - Ra, f = a.apply(this, arguments) - Ra, h = Math.abs(f - s), g = s > f ? 0 : 1; if (n > l && (p = l, l = n, n = p), h >= Ta)\n        return t(l, g) + (n ? t(n, 1 - g) : \"\") + \"Z\"; var p, v, d, m, y, M, x, b, _, w, S, k, E = 0, A = 0, N = []; if ((m = (+c.apply(this, arguments) || 0) / 2) && (d = i === kl ? Math.sqrt(n * n + l * l) : +i.apply(this, arguments), g || (A *= -1), l && (A = tt(d / l * Math.sin(m))), n && (E = tt(d / n * Math.sin(m)))), l) {\n        y = l * Math.cos(s + A), M = l * Math.sin(s + A), x = l * Math.cos(f - A), b = l * Math.sin(f - A);\n        var C = Math.abs(f - s - 2 * A) <= qa ? 0 : 1;\n        if (A && so(y, M, x, b) === g ^ C) {\n            var z = (s + f) / 2;\n            y = l * Math.cos(z), M = l * Math.sin(z), x = b = null;\n        }\n    }\n    else\n        y = M = 0; if (n) {\n        _ = n * Math.cos(f - E), w = n * Math.sin(f - E), S = n * Math.cos(s + E), k = n * Math.sin(s + E);\n        var q = Math.abs(s - f + 2 * E) <= qa ? 0 : 1;\n        if (E && so(_, w, S, k) === 1 - g ^ q) {\n            var L = (s + f) / 2;\n            _ = n * Math.cos(L), w = n * Math.sin(L), S = k = null;\n        }\n    }\n    else\n        _ = w = 0; if ((p = Math.min(Math.abs(l - n) / 2, +u.apply(this, arguments))) > .001) {\n        v = l > n ^ g ? 0 : 1;\n        var T = null == S ? [_, w] : null == x ? [y, M] : Lr([y, M], [S, k], [x, b], [_, w]), R = y - T[0], D = M - T[1], P = x - T[0], U = b - T[1], j = 1 / Math.sin(Math.acos((R * P + D * U) / (Math.sqrt(R * R + D * D) * Math.sqrt(P * P + U * U))) / 2), F = Math.sqrt(T[0] * T[0] + T[1] * T[1]);\n        if (null != x) {\n            var H = Math.min(p, (l - F) / (j + 1)), O = fo(null == S ? [_, w] : [S, k], [y, M], l, H, g), I = fo([x, b], [_, w], l, H, g);\n            p === H ? N.push(\"M\", O[0], \"A\", H, \",\", H, \" 0 0,\", v, \" \", O[1], \"A\", l, \",\", l, \" 0 \", 1 - g ^ so(O[1][0], O[1][1], I[1][0], I[1][1]), \",\", g, \" \", I[1], \"A\", H, \",\", H, \" 0 0,\", v, \" \", I[0]) : N.push(\"M\", O[0], \"A\", H, \",\", H, \" 0 1,\", v, \" \", I[0]);\n        }\n        else\n            N.push(\"M\", y, \",\", M);\n        if (null != S) {\n            var Y = Math.min(p, (n - F) / (j - 1)), Z = fo([y, M], [S, k], n, -Y, g), V = fo([_, w], null == x ? [y, M] : [x, b], n, -Y, g);\n            p === Y ? N.push(\"L\", V[0], \"A\", Y, \",\", Y, \" 0 0,\", v, \" \", V[1], \"A\", n, \",\", n, \" 0 \", g ^ so(V[1][0], V[1][1], Z[1][0], Z[1][1]), \",\", 1 - g, \" \", Z[1], \"A\", Y, \",\", Y, \" 0 0,\", v, \" \", Z[0]) : N.push(\"L\", V[0], \"A\", Y, \",\", Y, \" 0 0,\", v, \" \", Z[0]);\n        }\n        else\n            N.push(\"L\", _, \",\", w);\n    }\n    else\n        N.push(\"M\", y, \",\", M), null != x && N.push(\"A\", l, \",\", l, \" 0 \", C, \",\", g, \" \", x, \",\", b), N.push(\"L\", _, \",\", w), null != S && N.push(\"A\", n, \",\", n, \" 0 \", q, \",\", 1 - g, \" \", S, \",\", k); return N.push(\"Z\"), N.join(\"\"); } function t(n, t) { return \"M0,\" + n + \"A\" + n + \",\" + n + \" 0 1,\" + t + \" 0,\" + -n + \"A\" + n + \",\" + n + \" 0 1,\" + t + \" 0,\" + n; } var e = io, r = oo, u = uo, i = kl, o = ao, a = co, c = lo; return n.innerRadius = function (t) { return arguments.length ? (e = Et(t), n) : e; }, n.outerRadius = function (t) { return arguments.length ? (r = Et(t), n) : r; }, n.cornerRadius = function (t) { return arguments.length ? (u = Et(t), n) : u; }, n.padRadius = function (t) { return arguments.length ? (i = t == kl ? kl : Et(t), n) : i; }, n.startAngle = function (t) { return arguments.length ? (o = Et(t), n) : o; }, n.endAngle = function (t) { return arguments.length ? (a = Et(t), n) : a; }, n.padAngle = function (t) { return arguments.length ? (c = Et(t), n) : c; }, n.centroid = function () { var n = (+e.apply(this, arguments) + +r.apply(this, arguments)) / 2, t = (+o.apply(this, arguments) + +a.apply(this, arguments)) / 2 - Ra; return [Math.cos(t) * n, Math.sin(t) * n]; }, n; };\n    var kl = \"auto\";\n    ta.svg.line = function () { return ho(y); };\n    var El = ta.map({ linear: go, \"linear-closed\": po, step: vo, \"step-before\": mo, \"step-after\": yo, basis: So, \"basis-open\": ko, \"basis-closed\": Eo, bundle: Ao, cardinal: bo, \"cardinal-open\": Mo, \"cardinal-closed\": xo, monotone: To });\n    El.forEach(function (n, t) { t.key = n, t.closed = /-closed$/.test(n); });\n    var Al = [0, 2 / 3, 1 / 3, 0], Nl = [0, 1 / 3, 2 / 3, 0], Cl = [0, 1 / 6, 2 / 3, 1 / 6];\n    ta.svg.line.radial = function () { var n = ho(Ro); return n.radius = n.x, delete n.x, n.angle = n.y, delete n.y, n; }, mo.reverse = yo, yo.reverse = mo, ta.svg.area = function () { return Do(y); }, ta.svg.area.radial = function () { var n = Do(Ro); return n.radius = n.x, delete n.x, n.innerRadius = n.x0, delete n.x0, n.outerRadius = n.x1, delete n.x1, n.angle = n.y, delete n.y, n.startAngle = n.y0, delete n.y0, n.endAngle = n.y1, delete n.y1, n; }, ta.svg.chord = function () { function n(n, a) { var c = t(this, i, n, a), l = t(this, o, n, a); return \"M\" + c.p0 + r(c.r, c.p1, c.a1 - c.a0) + (e(c, l) ? u(c.r, c.p1, c.r, c.p0) : u(c.r, c.p1, l.r, l.p0) + r(l.r, l.p1, l.a1 - l.a0) + u(l.r, l.p1, c.r, c.p0)) + \"Z\"; } function t(n, t, e, r) { var u = t.call(n, e, r), i = a.call(n, u, r), o = c.call(n, u, r) - Ra, s = l.call(n, u, r) - Ra; return { r: i, a0: o, a1: s, p0: [i * Math.cos(o), i * Math.sin(o)], p1: [i * Math.cos(s), i * Math.sin(s)] }; } function e(n, t) { return n.a0 == t.a0 && n.a1 == t.a1; } function r(n, t, e) { return \"A\" + n + \",\" + n + \" 0 \" + +(e > qa) + \",1 \" + t; } function u(n, t, e, r) { return \"Q 0,0 \" + r; } var i = mr, o = yr, a = Po, c = ao, l = co; return n.radius = function (t) { return arguments.length ? (a = Et(t), n) : a; }, n.source = function (t) { return arguments.length ? (i = Et(t), n) : i; }, n.target = function (t) { return arguments.length ? (o = Et(t), n) : o; }, n.startAngle = function (t) { return arguments.length ? (c = Et(t), n) : c; }, n.endAngle = function (t) { return arguments.length ? (l = Et(t), n) : l; }, n; }, ta.svg.diagonal = function () { function n(n, u) { var i = t.call(this, n, u), o = e.call(this, n, u), a = (i.y + o.y) / 2, c = [i, { x: i.x, y: a }, { x: o.x, y: a }, o]; return c = c.map(r), \"M\" + c[0] + \"C\" + c[1] + \" \" + c[2] + \" \" + c[3]; } var t = mr, e = yr, r = Uo; return n.source = function (e) { return arguments.length ? (t = Et(e), n) : t; }, n.target = function (t) { return arguments.length ? (e = Et(t), n) : e; }, n.projection = function (t) { return arguments.length ? (r = t, n) : r; }, n; }, ta.svg.diagonal.radial = function () { var n = ta.svg.diagonal(), t = Uo, e = n.projection; return n.projection = function (n) { return arguments.length ? e(jo(t = n)) : t; }, n; }, ta.svg.symbol = function () { function n(n, r) { return (zl.get(t.call(this, n, r)) || Oo)(e.call(this, n, r)); } var t = Ho, e = Fo; return n.type = function (e) { return arguments.length ? (t = Et(e), n) : t; }, n.size = function (t) { return arguments.length ? (e = Et(t), n) : e; }, n; };\n    var zl = ta.map({ circle: Oo, cross: function (n) { var t = Math.sqrt(n / 5) / 2; return \"M\" + -3 * t + \",\" + -t + \"H\" + -t + \"V\" + -3 * t + \"H\" + t + \"V\" + -t + \"H\" + 3 * t + \"V\" + t + \"H\" + t + \"V\" + 3 * t + \"H\" + -t + \"V\" + t + \"H\" + -3 * t + \"Z\"; }, diamond: function (n) { var t = Math.sqrt(n / (2 * Ll)), e = t * Ll; return \"M0,\" + -t + \"L\" + e + \",0 0,\" + t + \" \" + -e + \",0Z\"; }, square: function (n) { var t = Math.sqrt(n) / 2; return \"M\" + -t + \",\" + -t + \"L\" + t + \",\" + -t + \" \" + t + \",\" + t + \" \" + -t + \",\" + t + \"Z\"; }, \"triangle-down\": function (n) { var t = Math.sqrt(n / ql), e = t * ql / 2; return \"M0,\" + e + \"L\" + t + \",\" + -e + \" \" + -t + \",\" + -e + \"Z\"; }, \"triangle-up\": function (n) { var t = Math.sqrt(n / ql), e = t * ql / 2; return \"M0,\" + -e + \"L\" + t + \",\" + e + \" \" + -t + \",\" + e + \"Z\"; } });\n    ta.svg.symbolTypes = zl.keys();\n    var ql = Math.sqrt(3), Ll = Math.tan(30 * Da);\n    _a.transition = function (n) { for (var t, e, r = Tl || ++Ul, u = Xo(n), i = [], o = Rl || { time: Date.now(), ease: Su, delay: 0, duration: 250 }, a = -1, c = this.length; ++a < c;) {\n        i.push(t = []);\n        for (var l = this[a], s = -1, f = l.length; ++s < f;)\n            (e = l[s]) && $o(e, s, u, r, o), t.push(e);\n    } return Yo(i, u, r); }, _a.interrupt = function (n) { return this.each(null == n ? Dl : Io(Xo(n))); };\n    var Tl, Rl, Dl = Io(Xo()), Pl = [], Ul = 0;\n    Pl.call = _a.call, Pl.empty = _a.empty, Pl.node = _a.node, Pl.size = _a.size, ta.transition = function (n, t) { return n && n.transition ? Tl ? n.transition(t) : n : ta.selection().transition(n); }, ta.transition.prototype = Pl, Pl.select = function (n) { var t, e, r, u = this.id, i = this.namespace, o = []; n = N(n); for (var a = -1, c = this.length; ++a < c;) {\n        o.push(t = []);\n        for (var l = this[a], s = -1, f = l.length; ++s < f;)\n            (r = l[s]) && (e = n.call(r, r.__data__, s, a)) ? (\"__data__\" in r && (e.__data__ = r.__data__), $o(e, s, i, u, r[i][u]), t.push(e)) : t.push(null);\n    } return Yo(o, i, u); }, Pl.selectAll = function (n) { var t, e, r, u, i, o = this.id, a = this.namespace, c = []; n = C(n); for (var l = -1, s = this.length; ++l < s;)\n        for (var f = this[l], h = -1, g = f.length; ++h < g;)\n            if (r = f[h]) {\n                i = r[a][o], e = n.call(r, r.__data__, h, l), c.push(t = []);\n                for (var p = -1, v = e.length; ++p < v;)\n                    (u = e[p]) && $o(u, p, a, o, i), t.push(u);\n            } return Yo(c, a, o); }, Pl.filter = function (n) { var t, e, r, u = []; \"function\" != typeof n && (n = O(n)); for (var i = 0, o = this.length; o > i; i++) {\n        u.push(t = []);\n        for (var e = this[i], a = 0, c = e.length; c > a; a++)\n            (r = e[a]) && n.call(r, r.__data__, a, i) && t.push(r);\n    } return Yo(u, this.namespace, this.id); }, Pl.tween = function (n, t) { var e = this.id, r = this.namespace; return arguments.length < 2 ? this.node()[r][e].tween.get(n) : Y(this, null == t ? function (t) { t[r][e].tween.remove(n); } : function (u) { u[r][e].tween.set(n, t); }); }, Pl.attr = function (n, t) { function e() { this.removeAttribute(a); } function r() { this.removeAttributeNS(a.space, a.local); } function u(n) { return null == n ? e : (n += \"\", function () { var t, e = this.getAttribute(a); return e !== n && (t = o(e, n), function (n) { this.setAttribute(a, t(n)); }); }); } function i(n) { return null == n ? r : (n += \"\", function () { var t, e = this.getAttributeNS(a.space, a.local); return e !== n && (t = o(e, n), function (n) { this.setAttributeNS(a.space, a.local, t(n)); }); }); } if (arguments.length < 2) {\n        for (t in n)\n            this.attr(t, n[t]);\n        return this;\n    } var o = \"transform\" == n ? Hu : mu, a = ta.ns.qualify(n); return Zo(this, \"attr.\" + n, t, a.local ? i : u); }, Pl.attrTween = function (n, t) { function e(n, e) { var r = t.call(this, n, e, this.getAttribute(u)); return r && function (n) { this.setAttribute(u, r(n)); }; } function r(n, e) { var r = t.call(this, n, e, this.getAttributeNS(u.space, u.local)); return r && function (n) { this.setAttributeNS(u.space, u.local, r(n)); }; } var u = ta.ns.qualify(n); return this.tween(\"attr.\" + n, u.local ? r : e); }, Pl.style = function (n, e, r) { function u() { this.style.removeProperty(n); } function i(e) { return null == e ? u : (e += \"\", function () { var u, i = t(this).getComputedStyle(this, null).getPropertyValue(n); return i !== e && (u = mu(i, e), function (t) { this.style.setProperty(n, u(t), r); }); }); } var o = arguments.length; if (3 > o) {\n        if (\"string\" != typeof n) {\n            2 > o && (e = \"\");\n            for (r in n)\n                this.style(r, n[r], e);\n            return this;\n        }\n        r = \"\";\n    } return Zo(this, \"style.\" + n, e, i); }, Pl.styleTween = function (n, e, r) { function u(u, i) { var o = e.call(this, u, i, t(this).getComputedStyle(this, null).getPropertyValue(n)); return o && function (t) { this.style.setProperty(n, o(t), r); }; } return arguments.length < 3 && (r = \"\"), this.tween(\"style.\" + n, u); }, Pl.text = function (n) { return Zo(this, \"text\", n, Vo); }, Pl.remove = function () { var n = this.namespace; return this.each(\"end.transition\", function () { var t; this[n].count < 2 && (t = this.parentNode) && t.removeChild(this); }); }, Pl.ease = function (n) { var t = this.id, e = this.namespace; return arguments.length < 1 ? this.node()[e][t].ease : (\"function\" != typeof n && (n = ta.ease.apply(ta, arguments)), Y(this, function (r) { r[e][t].ease = n; })); }, Pl.delay = function (n) { var t = this.id, e = this.namespace; return arguments.length < 1 ? this.node()[e][t].delay : Y(this, \"function\" == typeof n ? function (r, u, i) { r[e][t].delay = +n.call(r, r.__data__, u, i); } : (n = +n, function (r) { r[e][t].delay = n; })); }, Pl.duration = function (n) { var t = this.id, e = this.namespace; return arguments.length < 1 ? this.node()[e][t].duration : Y(this, \"function\" == typeof n ? function (r, u, i) { r[e][t].duration = Math.max(1, n.call(r, r.__data__, u, i)); } : (n = Math.max(1, n), function (r) { r[e][t].duration = n; })); }, Pl.each = function (n, t) { var e = this.id, r = this.namespace; if (arguments.length < 2) {\n        var u = Rl, i = Tl;\n        try {\n            Tl = e, Y(this, function (t, u, i) { Rl = t[r][e], n.call(t, t.__data__, u, i); });\n        }\n        finally {\n            Rl = u, Tl = i;\n        }\n    }\n    else\n        Y(this, function (u) { var i = u[r][e]; (i.event || (i.event = ta.dispatch(\"start\", \"end\", \"interrupt\"))).on(n, t); }); return this; }, Pl.transition = function () { for (var n, t, e, r, u = this.id, i = ++Ul, o = this.namespace, a = [], c = 0, l = this.length; l > c; c++) {\n        a.push(n = []);\n        for (var t = this[c], s = 0, f = t.length; f > s; s++)\n            (e = t[s]) && (r = e[o][u], $o(e, s, o, i, { time: r.time, ease: r.ease, delay: r.delay + r.duration, duration: r.duration })), n.push(e);\n    } return Yo(a, o, i); }, ta.svg.axis = function () { function n(n) { n.each(function () { var n, l = ta.select(this), s = this.__chart__ || e, f = this.__chart__ = e.copy(), h = null == c ? f.ticks ? f.ticks.apply(f, a) : f.domain() : c, g = null == t ? f.tickFormat ? f.tickFormat.apply(f, a) : y : t, p = l.selectAll(\".tick\").data(h, f), v = p.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", Ca), d = ta.transition(p.exit()).style(\"opacity\", Ca).remove(), m = ta.transition(p.order()).style(\"opacity\", 1), M = Math.max(u, 0) + o, x = Ui(f), b = l.selectAll(\".domain\").data([0]), _ = (b.enter().append(\"path\").attr(\"class\", \"domain\"), ta.transition(b)); v.append(\"line\"), v.append(\"text\"); var w, S, k, E, A = v.select(\"line\"), N = m.select(\"line\"), C = p.select(\"text\").text(g), z = v.select(\"text\"), q = m.select(\"text\"), L = \"top\" === r || \"left\" === r ? -1 : 1; if (\"bottom\" === r || \"top\" === r ? (n = Bo, w = \"x\", k = \"y\", S = \"x2\", E = \"y2\", C.attr(\"dy\", 0 > L ? \"0em\" : \".71em\").style(\"text-anchor\", \"middle\"), _.attr(\"d\", \"M\" + x[0] + \",\" + L * i + \"V0H\" + x[1] + \"V\" + L * i)) : (n = Wo, w = \"y\", k = \"x\", S = \"y2\", E = \"x2\", C.attr(\"dy\", \".32em\").style(\"text-anchor\", 0 > L ? \"end\" : \"start\"), _.attr(\"d\", \"M\" + L * i + \",\" + x[0] + \"H0V\" + x[1] + \"H\" + L * i)), A.attr(E, L * u), z.attr(k, L * M), N.attr(S, 0).attr(E, L * u), q.attr(w, 0).attr(k, L * M), f.rangeBand) {\n        var T = f, R = T.rangeBand() / 2;\n        s = f = function (n) { return T(n) + R; };\n    }\n    else\n        s.rangeBand ? s = f : d.call(n, f, s); v.call(n, s, f), m.call(n, f, f); }); } var t, e = ta.scale.linear(), r = jl, u = 6, i = 6, o = 3, a = [10], c = null; return n.scale = function (t) { return arguments.length ? (e = t, n) : e; }, n.orient = function (t) { return arguments.length ? (r = t in Fl ? t + \"\" : jl, n) : r; }, n.ticks = function () { return arguments.length ? (a = arguments, n) : a; }, n.tickValues = function (t) { return arguments.length ? (c = t, n) : c; }, n.tickFormat = function (e) { return arguments.length ? (t = e, n) : t; }, n.tickSize = function (t) { var e = arguments.length; return e ? (u = +t, i = +arguments[e - 1], n) : u; }, n.innerTickSize = function (t) { return arguments.length ? (u = +t, n) : u; }, n.outerTickSize = function (t) { return arguments.length ? (i = +t, n) : i; }, n.tickPadding = function (t) { return arguments.length ? (o = +t, n) : o; }, n.tickSubdivide = function () { return arguments.length && n; }, n; };\n    var jl = \"bottom\", Fl = { top: 1, right: 1, bottom: 1, left: 1 };\n    ta.svg.brush = function () { function n(t) { t.each(function () { var t = ta.select(this).style(\"pointer-events\", \"all\").style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\").on(\"mousedown.brush\", i).on(\"touchstart.brush\", i), o = t.selectAll(\".background\").data([0]); o.enter().append(\"rect\").attr(\"class\", \"background\").style(\"visibility\", \"hidden\").style(\"cursor\", \"crosshair\"), t.selectAll(\".extent\").data([0]).enter().append(\"rect\").attr(\"class\", \"extent\").style(\"cursor\", \"move\"); var a = t.selectAll(\".resize\").data(v, y); a.exit().remove(), a.enter().append(\"g\").attr(\"class\", function (n) { return \"resize \" + n; }).style(\"cursor\", function (n) { return Hl[n]; }).append(\"rect\").attr(\"x\", function (n) { return /[ew]$/.test(n) ? -3 : null; }).attr(\"y\", function (n) { return /^[ns]/.test(n) ? -3 : null; }).attr(\"width\", 6).attr(\"height\", 6).style(\"visibility\", \"hidden\"), a.style(\"display\", n.empty() ? \"none\" : null); var c, f = ta.transition(t), h = ta.transition(o); l && (c = Ui(l), h.attr(\"x\", c[0]).attr(\"width\", c[1] - c[0]), r(f)), s && (c = Ui(s), h.attr(\"y\", c[0]).attr(\"height\", c[1] - c[0]), u(f)), e(f); }); } function e(n) { n.selectAll(\".resize\").attr(\"transform\", function (n) { return \"translate(\" + f[+/e$/.test(n)] + \",\" + h[+/^s/.test(n)] + \")\"; }); } function r(n) { n.select(\".extent\").attr(\"x\", f[0]), n.selectAll(\".extent,.n>rect,.s>rect\").attr(\"width\", f[1] - f[0]); } function u(n) { n.select(\".extent\").attr(\"y\", h[0]), n.selectAll(\".extent,.e>rect,.w>rect\").attr(\"height\", h[1] - h[0]); } function i() { function i() { 32 == ta.event.keyCode && (C || (M = null, q[0] -= f[1], q[1] -= h[1], C = 2), S()); } function v() { 32 == ta.event.keyCode && 2 == C && (q[0] += f[1], q[1] += h[1], C = 0, S()); } function d() { var n = ta.mouse(b), t = !1; x && (n[0] += x[0], n[1] += x[1]), C || (ta.event.altKey ? (M || (M = [(f[0] + f[1]) / 2, (h[0] + h[1]) / 2]), q[0] = f[+(n[0] < M[0])], q[1] = h[+(n[1] < M[1])]) : M = null), A && m(n, l, 0) && (r(k), t = !0), N && m(n, s, 1) && (u(k), t = !0), t && (e(k), w({ type: \"brush\", mode: C ? \"move\" : \"resize\" })); } function m(n, t, e) { var r, u, i = Ui(t), c = i[0], l = i[1], s = q[e], v = e ? h : f, d = v[1] - v[0]; return C && (c -= s, l -= d + s), r = (e ? p : g) ? Math.max(c, Math.min(l, n[e])) : n[e], C ? u = (r += s) + d : (M && (s = Math.max(c, Math.min(l, 2 * M[e] - r))), r > s ? (u = r, r = s) : u = s), v[0] != r || v[1] != u ? (e ? a = null : o = null, v[0] = r, v[1] = u, !0) : void 0; } function y() { d(), k.style(\"pointer-events\", \"all\").selectAll(\".resize\").style(\"display\", n.empty() ? \"none\" : null), ta.select(\"body\").style(\"cursor\", null), L.on(\"mousemove.brush\", null).on(\"mouseup.brush\", null).on(\"touchmove.brush\", null).on(\"touchend.brush\", null).on(\"keydown.brush\", null).on(\"keyup.brush\", null), z(), w({ type: \"brushend\" }); } var M, x, b = this, _ = ta.select(ta.event.target), w = c.of(b, arguments), k = ta.select(b), E = _.datum(), A = !/^(n|s)$/.test(E) && l, N = !/^(e|w)$/.test(E) && s, C = _.classed(\"extent\"), z = W(b), q = ta.mouse(b), L = ta.select(t(b)).on(\"keydown.brush\", i).on(\"keyup.brush\", v); if (ta.event.changedTouches ? L.on(\"touchmove.brush\", d).on(\"touchend.brush\", y) : L.on(\"mousemove.brush\", d).on(\"mouseup.brush\", y), k.interrupt().selectAll(\"*\").interrupt(), C)\n        q[0] = f[0] - q[0], q[1] = h[0] - q[1];\n    else if (E) {\n        var T = +/w$/.test(E), R = +/^n/.test(E);\n        x = [f[1 - T] - q[0], h[1 - R] - q[1]], q[0] = f[T], q[1] = h[R];\n    }\n    else\n        ta.event.altKey && (M = q.slice()); k.style(\"pointer-events\", \"none\").selectAll(\".resize\").style(\"display\", null), ta.select(\"body\").style(\"cursor\", _.style(\"cursor\")), w({ type: \"brushstart\" }), d(); } var o, a, c = E(n, \"brushstart\", \"brush\", \"brushend\"), l = null, s = null, f = [0, 0], h = [0, 0], g = !0, p = !0, v = Ol[0]; return n.event = function (n) { n.each(function () { var n = c.of(this, arguments), t = { x: f, y: h, i: o, j: a }, e = this.__chart__ || t; this.__chart__ = t, Tl ? ta.select(this).transition().each(\"start.brush\", function () { o = e.i, a = e.j, f = e.x, h = e.y, n({ type: \"brushstart\" }); }).tween(\"brush:brush\", function () { var e = yu(f, t.x), r = yu(h, t.y); return o = a = null, function (u) { f = t.x = e(u), h = t.y = r(u), n({ type: \"brush\", mode: \"resize\" }); }; }).each(\"end.brush\", function () { o = t.i, a = t.j, n({ type: \"brush\", mode: \"resize\" }), n({ type: \"brushend\" }); }) : (n({ type: \"brushstart\" }), n({ type: \"brush\", mode: \"resize\" }), n({ type: \"brushend\" })); }); }, n.x = function (t) { return arguments.length ? (l = t, v = Ol[!l << 1 | !s], n) : l; }, n.y = function (t) { return arguments.length ? (s = t, v = Ol[!l << 1 | !s], n) : s; }, n.clamp = function (t) { return arguments.length ? (l && s ? (g = !!t[0], p = !!t[1]) : l ? g = !!t : s && (p = !!t), n) : l && s ? [g, p] : l ? g : s ? p : null; }, n.extent = function (t) { var e, r, u, i, c; return arguments.length ? (l && (e = t[0], r = t[1], s && (e = e[0], r = r[0]), o = [e, r], l.invert && (e = l(e), r = l(r)), e > r && (c = e, e = r, r = c), (e != f[0] || r != f[1]) && (f = [e, r])), s && (u = t[0], i = t[1], l && (u = u[1], i = i[1]), a = [u, i], s.invert && (u = s(u), i = s(i)), u > i && (c = u, u = i, i = c), (u != h[0] || i != h[1]) && (h = [u, i])), n) : (l && (o ? (e = o[0], r = o[1]) : (e = f[0], r = f[1], l.invert && (e = l.invert(e), r = l.invert(r)), e > r && (c = e, e = r, r = c))), s && (a ? (u = a[0], i = a[1]) : (u = h[0], i = h[1], s.invert && (u = s.invert(u), i = s.invert(i)), u > i && (c = u, u = i, i = c))), l && s ? [[e, u], [r, i]] : l ? [e, r] : s && [u, i]); }, n.clear = function () { return n.empty() || (f = [0, 0], h = [0, 0], o = a = null), n; }, n.empty = function () { return !!l && f[0] == f[1] || !!s && h[0] == h[1]; }, ta.rebind(n, c, \"on\"); };\n    var Hl = { n: \"ns-resize\", e: \"ew-resize\", s: \"ns-resize\", w: \"ew-resize\", nw: \"nwse-resize\", ne: \"nesw-resize\", se: \"nwse-resize\", sw: \"nesw-resize\" }, Ol = [[\"n\", \"e\", \"s\", \"w\", \"nw\", \"ne\", \"se\", \"sw\"], [\"e\", \"w\"], [\"n\", \"s\"], []], Il = ac.format = gc.timeFormat, Yl = Il.utc, Zl = Yl(\"%Y-%m-%dT%H:%M:%S.%LZ\");\n    Il.iso = Date.prototype.toISOString && +new Date(\"2000-01-01T00:00:00.000Z\") ? Jo : Zl, Jo.parse = function (n) { var t = new Date(n); return isNaN(t) ? null : t; }, Jo.toString = Zl.toString, ac.second = Ft(function (n) { return new cc(1e3 * Math.floor(n / 1e3)); }, function (n, t) { n.setTime(n.getTime() + 1e3 * Math.floor(t)); }, function (n) { return n.getSeconds(); }), ac.seconds = ac.second.range, ac.seconds.utc = ac.second.utc.range, ac.minute = Ft(function (n) { return new cc(6e4 * Math.floor(n / 6e4)); }, function (n, t) { n.setTime(n.getTime() + 6e4 * Math.floor(t)); }, function (n) { return n.getMinutes(); }), ac.minutes = ac.minute.range, ac.minutes.utc = ac.minute.utc.range, ac.hour = Ft(function (n) { var t = n.getTimezoneOffset() / 60; return new cc(36e5 * (Math.floor(n / 36e5 - t) + t)); }, function (n, t) { n.setTime(n.getTime() + 36e5 * Math.floor(t)); }, function (n) { return n.getHours(); }), ac.hours = ac.hour.range, ac.hours.utc = ac.hour.utc.range, ac.month = Ft(function (n) { return n = ac.day(n), n.setDate(1), n; }, function (n, t) { n.setMonth(n.getMonth() + t); }, function (n) { return n.getMonth(); }), ac.months = ac.month.range, ac.months.utc = ac.month.utc.range;\n    var Vl = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6], Xl = [[ac.second, 1], [ac.second, 5], [ac.second, 15], [ac.second, 30], [ac.minute, 1], [ac.minute, 5], [ac.minute, 15], [ac.minute, 30], [ac.hour, 1], [ac.hour, 3], [ac.hour, 6], [ac.hour, 12], [ac.day, 1], [ac.day, 2], [ac.week, 1], [ac.month, 1], [ac.month, 3], [ac.year, 1]], $l = Il.multi([[\".%L\", function (n) { return n.getMilliseconds(); }], [\":%S\", function (n) { return n.getSeconds(); }], [\"%I:%M\", function (n) { return n.getMinutes(); }], [\"%I %p\", function (n) { return n.getHours(); }], [\"%a %d\", function (n) { return n.getDay() && 1 != n.getDate(); }], [\"%b %d\", function (n) { return 1 != n.getDate(); }], [\"%B\", function (n) { return n.getMonth(); }], [\"%Y\", Ne]]), Bl = { range: function (n, t, e) { return ta.range(Math.ceil(n / e) * e, +t, e).map(Ko); }, floor: y, ceil: y };\n    Xl.year = ac.year, ac.scale = function () { return Go(ta.scale.linear(), Xl, $l); };\n    var Wl = Xl.map(function (n) { return [n[0].utc, n[1]]; }), Jl = Yl.multi([[\".%L\", function (n) { return n.getUTCMilliseconds(); }], [\":%S\", function (n) { return n.getUTCSeconds(); }], [\"%I:%M\", function (n) { return n.getUTCMinutes(); }], [\"%I %p\", function (n) { return n.getUTCHours(); }], [\"%a %d\", function (n) { return n.getUTCDay() && 1 != n.getUTCDate(); }], [\"%b %d\", function (n) { return 1 != n.getUTCDate(); }], [\"%B\", function (n) { return n.getUTCMonth(); }], [\"%Y\", Ne]]);\n    Wl.year = ac.year.utc, ac.scale.utc = function () { return Go(ta.scale.linear(), Wl, Jl); }, ta.text = At(function (n) { return n.responseText; }), ta.json = function (n, t) { return Nt(n, \"application/json\", Qo, t); }, ta.html = function (n, t) { return Nt(n, \"text/html\", na, t); }, ta.xml = At(function (n) { return n.responseXML; }), \"function\" == typeof define && define.amd ? define(ta) : \"object\" == typeof module && module.exports && (module.exports = ta), this.d3 = ta;\n}();\n/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;\n(function () {\n    /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n    var undefined;\n    /** Used as the semantic version number. */\n    var VERSION = '4.17.2';\n    /** Used as the size to enable large array optimizations. */\n    var LARGE_ARRAY_SIZE = 200;\n    /** Error message constants. */\n    var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.', FUNC_ERROR_TEXT = 'Expected a function';\n    /** Used to stand-in for `undefined` hash values. */\n    var HASH_UNDEFINED = '__lodash_hash_undefined__';\n    /** Used as the maximum memoize cache size. */\n    var MAX_MEMOIZE_SIZE = 500;\n    /** Used as the internal argument placeholder. */\n    var PLACEHOLDER = '__lodash_placeholder__';\n    /** Used to compose bitmasks for cloning. */\n    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;\n    /** Used to compose bitmasks for value comparisons. */\n    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\n    /** Used to compose bitmasks for function metadata. */\n    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;\n    /** Used as default options for `_.truncate`. */\n    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = '...';\n    /** Used to detect hot functions by number of calls within a span of milliseconds. */\n    var HOT_COUNT = 800, HOT_SPAN = 16;\n    /** Used to indicate the type of lazy iteratees. */\n    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;\n    /** Used as references for various `Number` constants. */\n    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;\n    /** Used as references for the maximum length and index of an array. */\n    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n    /** Used to associate wrap methods with their bit flags. */\n    var wrapFlags = [\n        ['ary', WRAP_ARY_FLAG],\n        ['bind', WRAP_BIND_FLAG],\n        ['bindKey', WRAP_BIND_KEY_FLAG],\n        ['curry', WRAP_CURRY_FLAG],\n        ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n        ['flip', WRAP_FLIP_FLAG],\n        ['partial', WRAP_PARTIAL_FLAG],\n        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n        ['rearg', WRAP_REARG_FLAG]\n    ];\n    /** `Object#toString` result references. */\n    var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', domExcTag = '[object DOMException]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]', weakSetTag = '[object WeakSet]';\n    var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';\n    /** Used to match empty string literals in compiled template source. */\n    var reEmptyStringLeading = /\\b__p \\+= '';/g, reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g, reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n    /** Used to match HTML entities and HTML characters. */\n    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>\"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n    /** Used to match template delimiters. */\n    var reEscape = /<%-([\\s\\S]+?)%>/g, reEvaluate = /<%([\\s\\S]+?)%>/g, reInterpolate = /<%=([\\s\\S]+?)%>/g;\n    /** Used to match property names within property paths. */\n    var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/, reLeadingDot = /^\\./, rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    /**\n     * Used to match `RegExp`\n     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n     */\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);\n    /** Used to match leading and trailing whitespace. */\n    var reTrim = /^\\s+|\\s+$/g, reTrimStart = /^\\s+/, reTrimEnd = /\\s+$/;\n    /** Used to match wrap detail comments. */\n    var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/, reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/, reSplitDetails = /,? & /;\n    /** Used to match words composed of alphanumeric characters. */\n    var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n    /** Used to match backslashes in property paths. */\n    var reEscapeChar = /\\\\(\\\\)?/g;\n    /**\n     * Used to match\n     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n     */\n    var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n    /** Used to match `RegExp` flags from their coerced string values. */\n    var reFlags = /\\w*$/;\n    /** Used to detect bad signed hexadecimal string values. */\n    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n    /** Used to detect binary string values. */\n    var reIsBinary = /^0b[01]+$/i;\n    /** Used to detect host constructors (Safari). */\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    /** Used to detect octal string values. */\n    var reIsOctal = /^0o[0-7]+$/i;\n    /** Used to detect unsigned integer values. */\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    /** Used to match Latin Unicode letters (excluding mathematical operators). */\n    var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n    /** Used to ensure capturing order of template delimiters. */\n    var reNoMatch = /($^)/;\n    /** Used to match unescaped characters in compiled string literals. */\n    var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n    /** Used to compose unicode character classes. */\n    var rsAstralRange = '\\\\ud800-\\\\udfff', rsComboMarksRange = '\\\\u0300-\\\\u036f', reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f', rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = '\\\\u2700-\\\\u27bf', rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff', rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7', rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf', rsPunctuationRange = '\\\\u2000-\\\\u206f', rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000', rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde', rsVarRange = '\\\\ufe0e\\\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n    /** Used to compose unicode capture groups. */\n    var rsApos = \"['\\u2019]\", rsAstral = '[' + rsAstralRange + ']', rsBreak = '[' + rsBreakRange + ']', rsCombo = '[' + rsComboRange + ']', rsDigits = '\\\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange + ']', rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}', rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ = '\\\\u200d';\n    /** Used to compose unicode regexes. */\n    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange + ']?', rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsOrdLower = '\\\\d*(?:(?:1st|2nd|3rd|(?![123])\\\\dth)\\\\b)', rsOrdUpper = '\\\\d*(?:(?:1ST|2ND|3RD|(?![123])\\\\dTH)\\\\b)', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq, rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n    /** Used to match apostrophes. */\n    var reApos = RegExp(rsApos, 'g');\n    /**\n     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n     */\n    var reComboMark = RegExp(rsCombo, 'g');\n    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n    /** Used to match complex or compound words. */\n    var reUnicodeWord = RegExp([\n        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n        rsUpper + '+' + rsOptContrUpper,\n        rsOrdUpper,\n        rsOrdLower,\n        rsDigits,\n        rsEmoji\n    ].join('|'), 'g');\n    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');\n    /** Used to detect strings that need a more robust regexp to match words. */\n    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n    /** Used to assign default `context` object properties. */\n    var contextProps = [\n        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n    ];\n    /** Used to make template sourceURLs easier to identify. */\n    var templateCounter = -1;\n    /** Used to identify `toStringTag` values of typed arrays. */\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n                typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n                    typedArrayTags[uint32Tag] = true;\n    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n            typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n                typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n                    typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n                        typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n                            typedArrayTags[setTag] = typedArrayTags[stringTag] =\n                                typedArrayTags[weakMapTag] = false;\n    /** Used to identify `toStringTag` values supported by `_.clone`. */\n    var cloneableTags = {};\n    cloneableTags[argsTag] = cloneableTags[arrayTag] =\n        cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n            cloneableTags[boolTag] = cloneableTags[dateTag] =\n                cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n                    cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n                        cloneableTags[int32Tag] = cloneableTags[mapTag] =\n                            cloneableTags[numberTag] = cloneableTags[objectTag] =\n                                cloneableTags[regexpTag] = cloneableTags[setTag] =\n                                    cloneableTags[stringTag] = cloneableTags[symbolTag] =\n                                        cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n                                            cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n    cloneableTags[errorTag] = cloneableTags[funcTag] =\n        cloneableTags[weakMapTag] = false;\n    /** Used to map Latin Unicode letters to basic Latin letters. */\n    var deburredLetters = {\n        // Latin-1 Supplement block.\n        '\\xc0': 'A', '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n        '\\xe0': 'a', '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n        '\\xc7': 'C', '\\xe7': 'c',\n        '\\xd0': 'D', '\\xf0': 'd',\n        '\\xc8': 'E', '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n        '\\xe8': 'e', '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n        '\\xcc': 'I', '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n        '\\xec': 'i', '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n        '\\xd1': 'N', '\\xf1': 'n',\n        '\\xd2': 'O', '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n        '\\xf2': 'o', '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n        '\\xd9': 'U', '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n        '\\xf9': 'u', '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n        '\\xdd': 'Y', '\\xfd': 'y', '\\xff': 'y',\n        '\\xc6': 'Ae', '\\xe6': 'ae',\n        '\\xde': 'Th', '\\xfe': 'th',\n        '\\xdf': 'ss',\n        // Latin Extended-A block.\n        '\\u0100': 'A', '\\u0102': 'A', '\\u0104': 'A',\n        '\\u0101': 'a', '\\u0103': 'a', '\\u0105': 'a',\n        '\\u0106': 'C', '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n        '\\u0107': 'c', '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n        '\\u010e': 'D', '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n        '\\u0112': 'E', '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n        '\\u0113': 'e', '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n        '\\u011c': 'G', '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n        '\\u011d': 'g', '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n        '\\u0124': 'H', '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n        '\\u0128': 'I', '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n        '\\u0129': 'i', '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n        '\\u0134': 'J', '\\u0135': 'j',\n        '\\u0136': 'K', '\\u0137': 'k', '\\u0138': 'k',\n        '\\u0139': 'L', '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n        '\\u013a': 'l', '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n        '\\u0143': 'N', '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n        '\\u0144': 'n', '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n        '\\u014c': 'O', '\\u014e': 'O', '\\u0150': 'O',\n        '\\u014d': 'o', '\\u014f': 'o', '\\u0151': 'o',\n        '\\u0154': 'R', '\\u0156': 'R', '\\u0158': 'R',\n        '\\u0155': 'r', '\\u0157': 'r', '\\u0159': 'r',\n        '\\u015a': 'S', '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n        '\\u015b': 's', '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n        '\\u0162': 'T', '\\u0164': 'T', '\\u0166': 'T',\n        '\\u0163': 't', '\\u0165': 't', '\\u0167': 't',\n        '\\u0168': 'U', '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n        '\\u0169': 'u', '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n        '\\u0174': 'W', '\\u0175': 'w',\n        '\\u0176': 'Y', '\\u0177': 'y', '\\u0178': 'Y',\n        '\\u0179': 'Z', '\\u017b': 'Z', '\\u017d': 'Z',\n        '\\u017a': 'z', '\\u017c': 'z', '\\u017e': 'z',\n        '\\u0132': 'IJ', '\\u0133': 'ij',\n        '\\u0152': 'Oe', '\\u0153': 'oe',\n        '\\u0149': \"'n\", '\\u017f': 's'\n    };\n    /** Used to map characters to HTML entities. */\n    var htmlEscapes = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#39;'\n    };\n    /** Used to map HTML entities to characters. */\n    var htmlUnescapes = {\n        '&amp;': '&',\n        '&lt;': '<',\n        '&gt;': '>',\n        '&quot;': '\"',\n        '&#39;': \"'\"\n    };\n    /** Used to escape characters for inclusion in compiled string literals. */\n    var stringEscapes = {\n        '\\\\': '\\\\',\n        \"'\": \"'\",\n        '\\n': 'n',\n        '\\r': 'r',\n        '\\u2028': 'u2028',\n        '\\u2029': 'u2029'\n    };\n    /** Built-in method references without a dependency on `root`. */\n    var freeParseFloat = parseFloat, freeParseInt = parseInt;\n    /** Detect free variable `global` from Node.js. */\n    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n    /** Detect free variable `self`. */\n    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n    /** Used as a reference to the global object. */\n    var root = freeGlobal || freeSelf || Function('return this')();\n    /** Detect free variable `exports`. */\n    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n    /** Detect free variable `module`. */\n    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Detect free variable `process` from Node.js. */\n    var freeProcess = moduleExports && freeGlobal.process;\n    /** Used to access faster Node.js helpers. */\n    var nodeUtil = (function () {\n        try {\n            return freeProcess && freeProcess.binding && freeProcess.binding('util');\n        }\n        catch (e) { }\n    }());\n    /* Node.js helper references. */\n    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n    /*--------------------------------------------------------------------------*/\n    /**\n     * Adds the key-value `pair` to `map`.\n     *\n     * @private\n     * @param {Object} map The map to modify.\n     * @param {Array} pair The key-value pair to add.\n     * @returns {Object} Returns `map`.\n     */\n    function addMapEntry(map, pair) {\n        // Don't return `map.set` because it's not chainable in IE 11.\n        map.set(pair[0], pair[1]);\n        return map;\n    }\n    /**\n     * Adds `value` to `set`.\n     *\n     * @private\n     * @param {Object} set The set to modify.\n     * @param {*} value The value to add.\n     * @returns {Object} Returns `set`.\n     */\n    function addSetEntry(set, value) {\n        // Don't return `set.add` because it's not chainable in IE 11.\n        set.add(value);\n        return set;\n    }\n    /**\n     * A faster alternative to `Function#apply`, this function invokes `func`\n     * with the `this` binding of `thisArg` and the arguments of `args`.\n     *\n     * @private\n     * @param {Function} func The function to invoke.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} args The arguments to invoke `func` with.\n     * @returns {*} Returns the result of `func`.\n     */\n    function apply(func, thisArg, args) {\n        switch (args.length) {\n            case 0: return func.call(thisArg);\n            case 1: return func.call(thisArg, args[0]);\n            case 2: return func.call(thisArg, args[0], args[1]);\n            case 3: return func.call(thisArg, args[0], args[1], args[2]);\n        }\n        return func.apply(thisArg, args);\n    }\n    /**\n     * A specialized version of `baseAggregator` for arrays.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function arrayAggregator(array, setter, iteratee, accumulator) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n            var value = array[index];\n            setter(accumulator, value, iteratee(value), array);\n        }\n        return accumulator;\n    }\n    /**\n     * A specialized version of `_.forEach` for arrays without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEach(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n            if (iteratee(array[index], index, array) === false) {\n                break;\n            }\n        }\n        return array;\n    }\n    /**\n     * A specialized version of `_.forEachRight` for arrays without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayEachRight(array, iteratee) {\n        var length = array == null ? 0 : array.length;\n        while (length--) {\n            if (iteratee(array[length], length, array) === false) {\n                break;\n            }\n        }\n        return array;\n    }\n    /**\n     * A specialized version of `_.every` for arrays without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     */\n    function arrayEvery(array, predicate) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n            if (!predicate(array[index], index, array)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * A specialized version of `_.filter` for arrays without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function arrayFilter(array, predicate) {\n        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n        while (++index < length) {\n            var value = array[index];\n            if (predicate(value, index, array)) {\n                result[resIndex++] = value;\n            }\n        }\n        return result;\n    }\n    /**\n     * A specialized version of `_.includes` for arrays without support for\n     * specifying an index to search from.\n     *\n     * @private\n     * @param {Array} [array] The array to inspect.\n     * @param {*} target The value to search for.\n     * @returns {boolean} Returns `true` if `target` is found, else `false`.\n     */\n    function arrayIncludes(array, value) {\n        var length = array == null ? 0 : array.length;\n        return !!length && baseIndexOf(array, value, 0) > -1;\n    }\n    /**\n     * This function is like `arrayIncludes` except that it accepts a comparator.\n     *\n     * @private\n     * @param {Array} [array] The array to inspect.\n     * @param {*} target The value to search for.\n     * @param {Function} comparator The comparator invoked per element.\n     * @returns {boolean} Returns `true` if `target` is found, else `false`.\n     */\n    function arrayIncludesWith(array, value, comparator) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n            if (comparator(value, array[index])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * A specialized version of `_.map` for arrays without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function arrayMap(array, iteratee) {\n        var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n        while (++index < length) {\n            result[index] = iteratee(array[index], index, array);\n        }\n        return result;\n    }\n    /**\n     * Appends the elements of `values` to `array`.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to append.\n     * @returns {Array} Returns `array`.\n     */\n    function arrayPush(array, values) {\n        var index = -1, length = values.length, offset = array.length;\n        while (++index < length) {\n            array[offset + index] = values[index];\n        }\n        return array;\n    }\n    /**\n     * A specialized version of `_.reduce` for arrays without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initAccum] Specify using the first element of `array` as\n     *  the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduce(array, iteratee, accumulator, initAccum) {\n        var index = -1, length = array == null ? 0 : array.length;\n        if (initAccum && length) {\n            accumulator = array[++index];\n        }\n        while (++index < length) {\n            accumulator = iteratee(accumulator, array[index], index, array);\n        }\n        return accumulator;\n    }\n    /**\n     * A specialized version of `_.reduceRight` for arrays without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @param {boolean} [initAccum] Specify using the last element of `array` as\n     *  the initial value.\n     * @returns {*} Returns the accumulated value.\n     */\n    function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n        var length = array == null ? 0 : array.length;\n        if (initAccum && length) {\n            accumulator = array[--length];\n        }\n        while (length--) {\n            accumulator = iteratee(accumulator, array[length], length, array);\n        }\n        return accumulator;\n    }\n    /**\n     * A specialized version of `_.some` for arrays without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function arraySome(array, predicate) {\n        var index = -1, length = array == null ? 0 : array.length;\n        while (++index < length) {\n            if (predicate(array[index], index, array)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Gets the size of an ASCII `string`.\n     *\n     * @private\n     * @param {string} string The string inspect.\n     * @returns {number} Returns the string size.\n     */\n    var asciiSize = baseProperty('length');\n    /**\n     * Converts an ASCII `string` to an array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the converted array.\n     */\n    function asciiToArray(string) {\n        return string.split('');\n    }\n    /**\n     * Splits an ASCII `string` into an array of its words.\n     *\n     * @private\n     * @param {string} The string to inspect.\n     * @returns {Array} Returns the words of `string`.\n     */\n    function asciiWords(string) {\n        return string.match(reAsciiWord) || [];\n    }\n    /**\n     * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n     * without support for iteratee shorthands, which iterates over `collection`\n     * using `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @returns {*} Returns the found element or its key, else `undefined`.\n     */\n    function baseFindKey(collection, predicate, eachFunc) {\n        var result;\n        eachFunc(collection, function (value, key, collection) {\n            if (predicate(value, key, collection)) {\n                result = key;\n                return false;\n            }\n        });\n        return result;\n    }\n    /**\n     * The base implementation of `_.findIndex` and `_.findLastIndex` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {number} fromIndex The index to search from.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function baseFindIndex(array, predicate, fromIndex, fromRight) {\n        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);\n        while ((fromRight ? index-- : ++index < length)) {\n            if (predicate(array[index], index, array)) {\n                return index;\n            }\n        }\n        return -1;\n    }\n    /**\n     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} fromIndex The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function baseIndexOf(array, value, fromIndex) {\n        return value === value\n            ? strictIndexOf(array, value, fromIndex)\n            : baseFindIndex(array, baseIsNaN, fromIndex);\n    }\n    /**\n     * This function is like `baseIndexOf` except that it accepts a comparator.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} fromIndex The index to search from.\n     * @param {Function} comparator The comparator invoked per element.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function baseIndexOfWith(array, value, fromIndex, comparator) {\n        var index = fromIndex - 1, length = array.length;\n        while (++index < length) {\n            if (comparator(array[index], value)) {\n                return index;\n            }\n        }\n        return -1;\n    }\n    /**\n     * The base implementation of `_.isNaN` without support for number objects.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     */\n    function baseIsNaN(value) {\n        return value !== value;\n    }\n    /**\n     * The base implementation of `_.mean` and `_.meanBy` without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {number} Returns the mean.\n     */\n    function baseMean(array, iteratee) {\n        var length = array == null ? 0 : array.length;\n        return length ? (baseSum(array, iteratee) / length) : NAN;\n    }\n    /**\n     * The base implementation of `_.property` without support for deep paths.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function baseProperty(key) {\n        return function (object) {\n            return object == null ? undefined : object[key];\n        };\n    }\n    /**\n     * The base implementation of `_.propertyOf` without support for deep paths.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyOf(object) {\n        return function (key) {\n            return object == null ? undefined : object[key];\n        };\n    }\n    /**\n     * The base implementation of `_.reduce` and `_.reduceRight`, without support\n     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {*} accumulator The initial value.\n     * @param {boolean} initAccum Specify using the first or last element of\n     *  `collection` as the initial value.\n     * @param {Function} eachFunc The function to iterate over `collection`.\n     * @returns {*} Returns the accumulated value.\n     */\n    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n        eachFunc(collection, function (value, index, collection) {\n            accumulator = initAccum\n                ? (initAccum = false, value)\n                : iteratee(accumulator, value, index, collection);\n        });\n        return accumulator;\n    }\n    /**\n     * The base implementation of `_.sortBy` which uses `comparer` to define the\n     * sort order of `array` and replaces criteria objects with their corresponding\n     * values.\n     *\n     * @private\n     * @param {Array} array The array to sort.\n     * @param {Function} comparer The function to define sort order.\n     * @returns {Array} Returns `array`.\n     */\n    function baseSortBy(array, comparer) {\n        var length = array.length;\n        array.sort(comparer);\n        while (length--) {\n            array[length] = array[length].value;\n        }\n        return array;\n    }\n    /**\n     * The base implementation of `_.sum` and `_.sumBy` without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {number} Returns the sum.\n     */\n    function baseSum(array, iteratee) {\n        var result, index = -1, length = array.length;\n        while (++index < length) {\n            var current = iteratee(array[index]);\n            if (current !== undefined) {\n                result = result === undefined ? current : (result + current);\n            }\n        }\n        return result;\n    }\n    /**\n     * The base implementation of `_.times` without support for iteratee shorthands\n     * or max array length checks.\n     *\n     * @private\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     */\n    function baseTimes(n, iteratee) {\n        var index = -1, result = Array(n);\n        while (++index < n) {\n            result[index] = iteratee(index);\n        }\n        return result;\n    }\n    /**\n     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n     * of key-value pairs for `object` corresponding to the property names of `props`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} props The property names to get values for.\n     * @returns {Object} Returns the key-value pairs.\n     */\n    function baseToPairs(object, props) {\n        return arrayMap(props, function (key) {\n            return [key, object[key]];\n        });\n    }\n    /**\n     * The base implementation of `_.unary` without support for storing metadata.\n     *\n     * @private\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     */\n    function baseUnary(func) {\n        return function (value) {\n            return func(value);\n        };\n    }\n    /**\n     * The base implementation of `_.values` and `_.valuesIn` which creates an\n     * array of `object` property values corresponding to the property names\n     * of `props`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} props The property names to get values for.\n     * @returns {Object} Returns the array of property values.\n     */\n    function baseValues(object, props) {\n        return arrayMap(props, function (key) {\n            return object[key];\n        });\n    }\n    /**\n     * Checks if a `cache` value for `key` exists.\n     *\n     * @private\n     * @param {Object} cache The cache to query.\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function cacheHas(cache, key) {\n        return cache.has(key);\n    }\n    /**\n     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n     * that is not found in the character symbols.\n     *\n     * @private\n     * @param {Array} strSymbols The string symbols to inspect.\n     * @param {Array} chrSymbols The character symbols to find.\n     * @returns {number} Returns the index of the first unmatched string symbol.\n     */\n    function charsStartIndex(strSymbols, chrSymbols) {\n        var index = -1, length = strSymbols.length;\n        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }\n        return index;\n    }\n    /**\n     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n     * that is not found in the character symbols.\n     *\n     * @private\n     * @param {Array} strSymbols The string symbols to inspect.\n     * @param {Array} chrSymbols The character symbols to find.\n     * @returns {number} Returns the index of the last unmatched string symbol.\n     */\n    function charsEndIndex(strSymbols, chrSymbols) {\n        var index = strSymbols.length;\n        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) { }\n        return index;\n    }\n    /**\n     * Gets the number of `placeholder` occurrences in `array`.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} placeholder The placeholder to search for.\n     * @returns {number} Returns the placeholder count.\n     */\n    function countHolders(array, placeholder) {\n        var length = array.length, result = 0;\n        while (length--) {\n            if (array[length] === placeholder) {\n                ++result;\n            }\n        }\n        return result;\n    }\n    /**\n     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n     * letters to basic Latin letters.\n     *\n     * @private\n     * @param {string} letter The matched letter to deburr.\n     * @returns {string} Returns the deburred letter.\n     */\n    var deburrLetter = basePropertyOf(deburredLetters);\n    /**\n     * Used by `_.escape` to convert characters to HTML entities.\n     *\n     * @private\n     * @param {string} chr The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    var escapeHtmlChar = basePropertyOf(htmlEscapes);\n    /**\n     * Used by `_.template` to escape characters for inclusion in compiled string literals.\n     *\n     * @private\n     * @param {string} chr The matched character to escape.\n     * @returns {string} Returns the escaped character.\n     */\n    function escapeStringChar(chr) {\n        return '\\\\' + stringEscapes[chr];\n    }\n    /**\n     * Gets the value at `key` of `object`.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function getValue(object, key) {\n        return object == null ? undefined : object[key];\n    }\n    /**\n     * Checks if `string` contains Unicode symbols.\n     *\n     * @private\n     * @param {string} string The string to inspect.\n     * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n     */\n    function hasUnicode(string) {\n        return reHasUnicode.test(string);\n    }\n    /**\n     * Checks if `string` contains a word composed of Unicode symbols.\n     *\n     * @private\n     * @param {string} string The string to inspect.\n     * @returns {boolean} Returns `true` if a word is found, else `false`.\n     */\n    function hasUnicodeWord(string) {\n        return reHasUnicodeWord.test(string);\n    }\n    /**\n     * Converts `iterator` to an array.\n     *\n     * @private\n     * @param {Object} iterator The iterator to convert.\n     * @returns {Array} Returns the converted array.\n     */\n    function iteratorToArray(iterator) {\n        var data, result = [];\n        while (!(data = iterator.next()).done) {\n            result.push(data.value);\n        }\n        return result;\n    }\n    /**\n     * Converts `map` to its key-value pairs.\n     *\n     * @private\n     * @param {Object} map The map to convert.\n     * @returns {Array} Returns the key-value pairs.\n     */\n    function mapToArray(map) {\n        var index = -1, result = Array(map.size);\n        map.forEach(function (value, key) {\n            result[++index] = [key, value];\n        });\n        return result;\n    }\n    /**\n     * Creates a unary function that invokes `func` with its argument transformed.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {Function} transform The argument transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overArg(func, transform) {\n        return function (arg) {\n            return func(transform(arg));\n        };\n    }\n    /**\n     * Replaces all `placeholder` elements in `array` with an internal placeholder\n     * and returns an array of their indexes.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {*} placeholder The placeholder to replace.\n     * @returns {Array} Returns the new array of placeholder indexes.\n     */\n    function replaceHolders(array, placeholder) {\n        var index = -1, length = array.length, resIndex = 0, result = [];\n        while (++index < length) {\n            var value = array[index];\n            if (value === placeholder || value === PLACEHOLDER) {\n                array[index] = PLACEHOLDER;\n                result[resIndex++] = index;\n            }\n        }\n        return result;\n    }\n    /**\n     * Converts `set` to an array of its values.\n     *\n     * @private\n     * @param {Object} set The set to convert.\n     * @returns {Array} Returns the values.\n     */\n    function setToArray(set) {\n        var index = -1, result = Array(set.size);\n        set.forEach(function (value) {\n            result[++index] = value;\n        });\n        return result;\n    }\n    /**\n     * Converts `set` to its value-value pairs.\n     *\n     * @private\n     * @param {Object} set The set to convert.\n     * @returns {Array} Returns the value-value pairs.\n     */\n    function setToPairs(set) {\n        var index = -1, result = Array(set.size);\n        set.forEach(function (value) {\n            result[++index] = [value, value];\n        });\n        return result;\n    }\n    /**\n     * A specialized version of `_.indexOf` which performs strict equality\n     * comparisons of values, i.e. `===`.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} fromIndex The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function strictIndexOf(array, value, fromIndex) {\n        var index = fromIndex - 1, length = array.length;\n        while (++index < length) {\n            if (array[index] === value) {\n                return index;\n            }\n        }\n        return -1;\n    }\n    /**\n     * A specialized version of `_.lastIndexOf` which performs strict equality\n     * comparisons of values, i.e. `===`.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} fromIndex The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function strictLastIndexOf(array, value, fromIndex) {\n        var index = fromIndex + 1;\n        while (index--) {\n            if (array[index] === value) {\n                return index;\n            }\n        }\n        return index;\n    }\n    /**\n     * Gets the number of symbols in `string`.\n     *\n     * @private\n     * @param {string} string The string to inspect.\n     * @returns {number} Returns the string size.\n     */\n    function stringSize(string) {\n        return hasUnicode(string)\n            ? unicodeSize(string)\n            : asciiSize(string);\n    }\n    /**\n     * Converts `string` to an array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the converted array.\n     */\n    function stringToArray(string) {\n        return hasUnicode(string)\n            ? unicodeToArray(string)\n            : asciiToArray(string);\n    }\n    /**\n     * Used by `_.unescape` to convert HTML entities to characters.\n     *\n     * @private\n     * @param {string} chr The matched character to unescape.\n     * @returns {string} Returns the unescaped character.\n     */\n    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n    /**\n     * Gets the size of a Unicode `string`.\n     *\n     * @private\n     * @param {string} string The string inspect.\n     * @returns {number} Returns the string size.\n     */\n    function unicodeSize(string) {\n        var result = reUnicode.lastIndex = 0;\n        while (reUnicode.test(string)) {\n            ++result;\n        }\n        return result;\n    }\n    /**\n     * Converts a Unicode `string` to an array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the converted array.\n     */\n    function unicodeToArray(string) {\n        return string.match(reUnicode) || [];\n    }\n    /**\n     * Splits a Unicode `string` into an array of its words.\n     *\n     * @private\n     * @param {string} The string to inspect.\n     * @returns {Array} Returns the words of `string`.\n     */\n    function unicodeWords(string) {\n        return string.match(reUnicodeWord) || [];\n    }\n    /*--------------------------------------------------------------------------*/\n    /**\n     * Create a new pristine `lodash` function using the `context` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Util\n     * @param {Object} [context=root] The context object.\n     * @returns {Function} Returns a new `lodash` function.\n     * @example\n     *\n     * _.mixin({ 'foo': _.constant('foo') });\n     *\n     * var lodash = _.runInContext();\n     * lodash.mixin({ 'bar': lodash.constant('bar') });\n     *\n     * _.isFunction(_.foo);\n     * // => true\n     * _.isFunction(_.bar);\n     * // => false\n     *\n     * lodash.isFunction(lodash.foo);\n     * // => false\n     * lodash.isFunction(lodash.bar);\n     * // => true\n     *\n     * // Create a suped-up `defer` in Node.js.\n     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n     */\n    var runInContext = (function runInContext(context) {\n        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n        /** Built-in constructor references. */\n        var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;\n        /** Used for built-in method references. */\n        var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;\n        /** Used to detect overreaching core-js shims. */\n        var coreJsData = context['__core-js_shared__'];\n        /** Used to resolve the decompiled source of functions. */\n        var funcToString = funcProto.toString;\n        /** Used to check objects for own properties. */\n        var hasOwnProperty = objectProto.hasOwnProperty;\n        /** Used to generate unique IDs. */\n        var idCounter = 0;\n        /** Used to detect methods masquerading as native. */\n        var maskSrcKey = (function () {\n            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n            return uid ? ('Symbol(src)_1.' + uid) : '';\n        }());\n        /**\n         * Used to resolve the\n         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n         * of values.\n         */\n        var nativeObjectToString = objectProto.toString;\n        /** Used to infer the `Object` constructor. */\n        var objectCtorString = funcToString.call(Object);\n        /** Used to restore the original `_` reference in `_.noConflict`. */\n        var oldDash = root._;\n        /** Used to detect if a method is native. */\n        var reIsNative = RegExp('^' +\n            funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n                .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n        /** Built-in value references. */\n        var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n        var defineProperty = (function () {\n            try {\n                var func = getNative(Object, 'defineProperty');\n                func({}, '', {});\n                return func;\n            }\n            catch (e) { }\n        }());\n        /** Mocked built-ins. */\n        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n        /* Built-in method references for those with the same name as other `lodash` methods. */\n        var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;\n        /* Built-in method references that are verified to be native. */\n        var DataView = getNative(context, 'DataView'), Map = getNative(context, 'Map'), Promise = getNative(context, 'Promise'), Set = getNative(context, 'Set'), WeakMap = getNative(context, 'WeakMap'), nativeCreate = getNative(Object, 'create');\n        /** Used to store function metadata. */\n        var metaMap = WeakMap && new WeakMap;\n        /** Used to lookup unminified function names. */\n        var realNames = {};\n        /** Used to detect maps, sets, and weakmaps. */\n        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);\n        /** Used to convert symbols to primitives and strings. */\n        var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates a `lodash` object which wraps `value` to enable implicit method\n         * chain sequences. Methods that operate on and return arrays, collections,\n         * and functions can be chained together. Methods that retrieve a single value\n         * or may return a primitive value will automatically end the chain sequence\n         * and return the unwrapped value. Otherwise, the value must be unwrapped\n         * with `_#value`.\n         *\n         * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n         * enabled using `_.chain`.\n         *\n         * The execution of chained methods is lazy, that is, it's deferred until\n         * `_#value` is implicitly or explicitly called.\n         *\n         * Lazy evaluation allows several methods to support shortcut fusion.\n         * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n         * the creation of intermediate arrays and can greatly reduce the number of\n         * iteratee executions. Sections of a chain sequence qualify for shortcut\n         * fusion if the section is applied to an array of at least `200` elements\n         * and any iteratees accept only one argument. The heuristic for whether a\n         * section qualifies for shortcut fusion is subject to change.\n         *\n         * Chaining is supported in custom builds as long as the `_#value` method is\n         * directly or indirectly included in the build.\n         *\n         * In addition to lodash methods, wrappers have `Array` and `String` methods.\n         *\n         * The wrapper `Array` methods are:\n         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n         *\n         * The wrapper `String` methods are:\n         * `replace` and `split`\n         *\n         * The wrapper methods that support shortcut fusion are:\n         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n         *\n         * The chainable wrapper methods are:\n         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n         * `zipObject`, `zipObjectDeep`, and `zipWith`\n         *\n         * The wrapper methods that are **not** chainable by default are:\n         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n         * `upperFirst`, `value`, and `words`\n         *\n         * @name _\n         * @constructor\n         * @category Seq\n         * @param {*} value The value to wrap in a `lodash` instance.\n         * @returns {Object} Returns the new `lodash` wrapper instance.\n         * @example\n         *\n         * function square(n) {\n         *   return n * n;\n         * }\n         *\n         * var wrapped = _([1, 2, 3]);\n         *\n         * // Returns an unwrapped value.\n         * wrapped.reduce(_.add);\n         * // => 6\n         *\n         * // Returns a wrapped value.\n         * var squares = wrapped.map(square);\n         *\n         * _.isArray(squares);\n         * // => false\n         *\n         * _.isArray(squares.value());\n         * // => true\n         */\n        function lodash(value) {\n            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n                if (value instanceof LodashWrapper) {\n                    return value;\n                }\n                if (hasOwnProperty.call(value, '__wrapped__')) {\n                    return wrapperClone(value);\n                }\n            }\n            return new LodashWrapper(value);\n        }\n        /**\n         * The base implementation of `_.create` without support for assigning\n         * properties to the created object.\n         *\n         * @private\n         * @param {Object} proto The object to inherit from.\n         * @returns {Object} Returns the new object.\n         */\n        var baseCreate = (function () {\n            function object() { }\n            return function (proto) {\n                if (!isObject(proto)) {\n                    return {};\n                }\n                if (objectCreate) {\n                    return objectCreate(proto);\n                }\n                object.prototype = proto;\n                var result = new object;\n                object.prototype = undefined;\n                return result;\n            };\n        }());\n        /**\n         * The function whose prototype chain sequence wrappers inherit from.\n         *\n         * @private\n         */\n        function baseLodash() {\n            // No operation performed.\n        }\n        /**\n         * The base constructor for creating `lodash` wrapper objects.\n         *\n         * @private\n         * @param {*} value The value to wrap.\n         * @param {boolean} [chainAll] Enable explicit method chain sequences.\n         */\n        function LodashWrapper(value, chainAll) {\n            this.__wrapped__ = value;\n            this.__actions__ = [];\n            this.__chain__ = !!chainAll;\n            this.__index__ = 0;\n            this.__values__ = undefined;\n        }\n        /**\n         * By default, the template delimiters used by lodash are like those in\n         * embedded Ruby (ERB). Change the following template settings to use\n         * alternative delimiters.\n         *\n         * @static\n         * @memberOf _\n         * @type {Object}\n         */\n        lodash.templateSettings = {\n            /**\n             * Used to detect `data` property values to be HTML-escaped.\n             *\n             * @memberOf _.templateSettings\n             * @type {RegExp}\n             */\n            'escape': reEscape,\n            /**\n             * Used to detect code to be evaluated.\n             *\n             * @memberOf _.templateSettings\n             * @type {RegExp}\n             */\n            'evaluate': reEvaluate,\n            /**\n             * Used to detect `data` property values to inject.\n             *\n             * @memberOf _.templateSettings\n             * @type {RegExp}\n             */\n            'interpolate': reInterpolate,\n            /**\n             * Used to reference the data object in the template text.\n             *\n             * @memberOf _.templateSettings\n             * @type {string}\n             */\n            'variable': '',\n            /**\n             * Used to import variables into the compiled template.\n             *\n             * @memberOf _.templateSettings\n             * @type {Object}\n             */\n            'imports': {\n                /**\n                 * A reference to the `lodash` function.\n                 *\n                 * @memberOf _.templateSettings.imports\n                 * @type {Function}\n                 */\n                '_': lodash\n            }\n        };\n        // Ensure wrappers are instances of `baseLodash`.\n        lodash.prototype = baseLodash.prototype;\n        lodash.prototype.constructor = lodash;\n        LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n        LodashWrapper.prototype.constructor = LodashWrapper;\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n         *\n         * @private\n         * @constructor\n         * @param {*} value The value to wrap.\n         */\n        function LazyWrapper(value) {\n            this.__wrapped__ = value;\n            this.__actions__ = [];\n            this.__dir__ = 1;\n            this.__filtered__ = false;\n            this.__iteratees__ = [];\n            this.__takeCount__ = MAX_ARRAY_LENGTH;\n            this.__views__ = [];\n        }\n        /**\n         * Creates a clone of the lazy wrapper object.\n         *\n         * @private\n         * @name clone\n         * @memberOf LazyWrapper\n         * @returns {Object} Returns the cloned `LazyWrapper` object.\n         */\n        function lazyClone() {\n            var result = new LazyWrapper(this.__wrapped__);\n            result.__actions__ = copyArray(this.__actions__);\n            result.__dir__ = this.__dir__;\n            result.__filtered__ = this.__filtered__;\n            result.__iteratees__ = copyArray(this.__iteratees__);\n            result.__takeCount__ = this.__takeCount__;\n            result.__views__ = copyArray(this.__views__);\n            return result;\n        }\n        /**\n         * Reverses the direction of lazy iteration.\n         *\n         * @private\n         * @name reverse\n         * @memberOf LazyWrapper\n         * @returns {Object} Returns the new reversed `LazyWrapper` object.\n         */\n        function lazyReverse() {\n            if (this.__filtered__) {\n                var result = new LazyWrapper(this);\n                result.__dir__ = -1;\n                result.__filtered__ = true;\n            }\n            else {\n                result = this.clone();\n                result.__dir__ *= -1;\n            }\n            return result;\n        }\n        /**\n         * Extracts the unwrapped value from its lazy wrapper.\n         *\n         * @private\n         * @name value\n         * @memberOf LazyWrapper\n         * @returns {*} Returns the unwrapped value.\n         */\n        function lazyValue() {\n            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : (start - 1), iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);\n            if (!isArr || arrLength < LARGE_ARRAY_SIZE ||\n                (arrLength == length && takeCount == length)) {\n                return baseWrapperValue(array, this.__actions__);\n            }\n            var result = [];\n            outer: while (length-- && resIndex < takeCount) {\n                index += dir;\n                var iterIndex = -1, value = array[index];\n                while (++iterIndex < iterLength) {\n                    var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);\n                    if (type == LAZY_MAP_FLAG) {\n                        value = computed;\n                    }\n                    else if (!computed) {\n                        if (type == LAZY_FILTER_FLAG) {\n                            continue outer;\n                        }\n                        else {\n                            break outer;\n                        }\n                    }\n                }\n                result[resIndex++] = value;\n            }\n            return result;\n        }\n        // Ensure `LazyWrapper` is an instance of `baseLodash`.\n        LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n        LazyWrapper.prototype.constructor = LazyWrapper;\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates a hash object.\n         *\n         * @private\n         * @constructor\n         * @param {Array} [entries] The key-value pairs to cache.\n         */\n        function Hash(entries) {\n            var index = -1, length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n                var entry = entries[index];\n                this.set(entry[0], entry[1]);\n            }\n        }\n        /**\n         * Removes all key-value entries from the hash.\n         *\n         * @private\n         * @name clear\n         * @memberOf Hash\n         */\n        function hashClear() {\n            this.__data__ = nativeCreate ? nativeCreate(null) : {};\n            this.size = 0;\n        }\n        /**\n         * Removes `key` and its value from the hash.\n         *\n         * @private\n         * @name delete\n         * @memberOf Hash\n         * @param {Object} hash The hash to modify.\n         * @param {string} key The key of the value to remove.\n         * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n         */\n        function hashDelete(key) {\n            var result = this.has(key) && delete this.__data__[key];\n            this.size -= result ? 1 : 0;\n            return result;\n        }\n        /**\n         * Gets the hash value for `key`.\n         *\n         * @private\n         * @name get\n         * @memberOf Hash\n         * @param {string} key The key of the value to get.\n         * @returns {*} Returns the entry value.\n         */\n        function hashGet(key) {\n            var data = this.__data__;\n            if (nativeCreate) {\n                var result = data[key];\n                return result === HASH_UNDEFINED ? undefined : result;\n            }\n            return hasOwnProperty.call(data, key) ? data[key] : undefined;\n        }\n        /**\n         * Checks if a hash value for `key` exists.\n         *\n         * @private\n         * @name has\n         * @memberOf Hash\n         * @param {string} key The key of the entry to check.\n         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n         */\n        function hashHas(key) {\n            var data = this.__data__;\n            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n        }\n        /**\n         * Sets the hash `key` to `value`.\n         *\n         * @private\n         * @name set\n         * @memberOf Hash\n         * @param {string} key The key of the value to set.\n         * @param {*} value The value to set.\n         * @returns {Object} Returns the hash instance.\n         */\n        function hashSet(key, value) {\n            var data = this.__data__;\n            this.size += this.has(key) ? 0 : 1;\n            data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n            return this;\n        }\n        // Add methods to `Hash`.\n        Hash.prototype.clear = hashClear;\n        Hash.prototype['delete'] = hashDelete;\n        Hash.prototype.get = hashGet;\n        Hash.prototype.has = hashHas;\n        Hash.prototype.set = hashSet;\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates an list cache object.\n         *\n         * @private\n         * @constructor\n         * @param {Array} [entries] The key-value pairs to cache.\n         */\n        function ListCache(entries) {\n            var index = -1, length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n                var entry = entries[index];\n                this.set(entry[0], entry[1]);\n            }\n        }\n        /**\n         * Removes all key-value entries from the list cache.\n         *\n         * @private\n         * @name clear\n         * @memberOf ListCache\n         */\n        function listCacheClear() {\n            this.__data__ = [];\n            this.size = 0;\n        }\n        /**\n         * Removes `key` and its value from the list cache.\n         *\n         * @private\n         * @name delete\n         * @memberOf ListCache\n         * @param {string} key The key of the value to remove.\n         * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n         */\n        function listCacheDelete(key) {\n            var data = this.__data__, index = assocIndexOf(data, key);\n            if (index < 0) {\n                return false;\n            }\n            var lastIndex = data.length - 1;\n            if (index == lastIndex) {\n                data.pop();\n            }\n            else {\n                splice.call(data, index, 1);\n            }\n            --this.size;\n            return true;\n        }\n        /**\n         * Gets the list cache value for `key`.\n         *\n         * @private\n         * @name get\n         * @memberOf ListCache\n         * @param {string} key The key of the value to get.\n         * @returns {*} Returns the entry value.\n         */\n        function listCacheGet(key) {\n            var data = this.__data__, index = assocIndexOf(data, key);\n            return index < 0 ? undefined : data[index][1];\n        }\n        /**\n         * Checks if a list cache value for `key` exists.\n         *\n         * @private\n         * @name has\n         * @memberOf ListCache\n         * @param {string} key The key of the entry to check.\n         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n         */\n        function listCacheHas(key) {\n            return assocIndexOf(this.__data__, key) > -1;\n        }\n        /**\n         * Sets the list cache `key` to `value`.\n         *\n         * @private\n         * @name set\n         * @memberOf ListCache\n         * @param {string} key The key of the value to set.\n         * @param {*} value The value to set.\n         * @returns {Object} Returns the list cache instance.\n         */\n        function listCacheSet(key, value) {\n            var data = this.__data__, index = assocIndexOf(data, key);\n            if (index < 0) {\n                ++this.size;\n                data.push([key, value]);\n            }\n            else {\n                data[index][1] = value;\n            }\n            return this;\n        }\n        // Add methods to `ListCache`.\n        ListCache.prototype.clear = listCacheClear;\n        ListCache.prototype['delete'] = listCacheDelete;\n        ListCache.prototype.get = listCacheGet;\n        ListCache.prototype.has = listCacheHas;\n        ListCache.prototype.set = listCacheSet;\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates a map cache object to store key-value pairs.\n         *\n         * @private\n         * @constructor\n         * @param {Array} [entries] The key-value pairs to cache.\n         */\n        function MapCache(entries) {\n            var index = -1, length = entries == null ? 0 : entries.length;\n            this.clear();\n            while (++index < length) {\n                var entry = entries[index];\n                this.set(entry[0], entry[1]);\n            }\n        }\n        /**\n         * Removes all key-value entries from the map.\n         *\n         * @private\n         * @name clear\n         * @memberOf MapCache\n         */\n        function mapCacheClear() {\n            this.size = 0;\n            this.__data__ = {\n                'hash': new Hash,\n                'map': new (Map || ListCache),\n                'string': new Hash\n            };\n        }\n        /**\n         * Removes `key` and its value from the map.\n         *\n         * @private\n         * @name delete\n         * @memberOf MapCache\n         * @param {string} key The key of the value to remove.\n         * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n         */\n        function mapCacheDelete(key) {\n            var result = getMapData(this, key)['delete'](key);\n            this.size -= result ? 1 : 0;\n            return result;\n        }\n        /**\n         * Gets the map value for `key`.\n         *\n         * @private\n         * @name get\n         * @memberOf MapCache\n         * @param {string} key The key of the value to get.\n         * @returns {*} Returns the entry value.\n         */\n        function mapCacheGet(key) {\n            return getMapData(this, key).get(key);\n        }\n        /**\n         * Checks if a map value for `key` exists.\n         *\n         * @private\n         * @name has\n         * @memberOf MapCache\n         * @param {string} key The key of the entry to check.\n         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n         */\n        function mapCacheHas(key) {\n            return getMapData(this, key).has(key);\n        }\n        /**\n         * Sets the map `key` to `value`.\n         *\n         * @private\n         * @name set\n         * @memberOf MapCache\n         * @param {string} key The key of the value to set.\n         * @param {*} value The value to set.\n         * @returns {Object} Returns the map cache instance.\n         */\n        function mapCacheSet(key, value) {\n            var data = getMapData(this, key), size = data.size;\n            data.set(key, value);\n            this.size += data.size == size ? 0 : 1;\n            return this;\n        }\n        // Add methods to `MapCache`.\n        MapCache.prototype.clear = mapCacheClear;\n        MapCache.prototype['delete'] = mapCacheDelete;\n        MapCache.prototype.get = mapCacheGet;\n        MapCache.prototype.has = mapCacheHas;\n        MapCache.prototype.set = mapCacheSet;\n        /*------------------------------------------------------------------------*/\n        /**\n         *\n         * Creates an array cache object to store unique values.\n         *\n         * @private\n         * @constructor\n         * @param {Array} [values] The values to cache.\n         */\n        function SetCache(values) {\n            var index = -1, length = values == null ? 0 : values.length;\n            this.__data__ = new MapCache;\n            while (++index < length) {\n                this.add(values[index]);\n            }\n        }\n        /**\n         * Adds `value` to the array cache.\n         *\n         * @private\n         * @name add\n         * @memberOf SetCache\n         * @alias push\n         * @param {*} value The value to cache.\n         * @returns {Object} Returns the cache instance.\n         */\n        function setCacheAdd(value) {\n            this.__data__.set(value, HASH_UNDEFINED);\n            return this;\n        }\n        /**\n         * Checks if `value` is in the array cache.\n         *\n         * @private\n         * @name has\n         * @memberOf SetCache\n         * @param {*} value The value to search for.\n         * @returns {number} Returns `true` if `value` is found, else `false`.\n         */\n        function setCacheHas(value) {\n            return this.__data__.has(value);\n        }\n        // Add methods to `SetCache`.\n        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n        SetCache.prototype.has = setCacheHas;\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates a stack cache object to store key-value pairs.\n         *\n         * @private\n         * @constructor\n         * @param {Array} [entries] The key-value pairs to cache.\n         */\n        function Stack(entries) {\n            var data = this.__data__ = new ListCache(entries);\n            this.size = data.size;\n        }\n        /**\n         * Removes all key-value entries from the stack.\n         *\n         * @private\n         * @name clear\n         * @memberOf Stack\n         */\n        function stackClear() {\n            this.__data__ = new ListCache;\n            this.size = 0;\n        }\n        /**\n         * Removes `key` and its value from the stack.\n         *\n         * @private\n         * @name delete\n         * @memberOf Stack\n         * @param {string} key The key of the value to remove.\n         * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n         */\n        function stackDelete(key) {\n            var data = this.__data__, result = data['delete'](key);\n            this.size = data.size;\n            return result;\n        }\n        /**\n         * Gets the stack value for `key`.\n         *\n         * @private\n         * @name get\n         * @memberOf Stack\n         * @param {string} key The key of the value to get.\n         * @returns {*} Returns the entry value.\n         */\n        function stackGet(key) {\n            return this.__data__.get(key);\n        }\n        /**\n         * Checks if a stack value for `key` exists.\n         *\n         * @private\n         * @name has\n         * @memberOf Stack\n         * @param {string} key The key of the entry to check.\n         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n         */\n        function stackHas(key) {\n            return this.__data__.has(key);\n        }\n        /**\n         * Sets the stack `key` to `value`.\n         *\n         * @private\n         * @name set\n         * @memberOf Stack\n         * @param {string} key The key of the value to set.\n         * @param {*} value The value to set.\n         * @returns {Object} Returns the stack cache instance.\n         */\n        function stackSet(key, value) {\n            var data = this.__data__;\n            if (data instanceof ListCache) {\n                var pairs = data.__data__;\n                if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n                    pairs.push([key, value]);\n                    this.size = ++data.size;\n                    return this;\n                }\n                data = this.__data__ = new MapCache(pairs);\n            }\n            data.set(key, value);\n            this.size = data.size;\n            return this;\n        }\n        // Add methods to `Stack`.\n        Stack.prototype.clear = stackClear;\n        Stack.prototype['delete'] = stackDelete;\n        Stack.prototype.get = stackGet;\n        Stack.prototype.has = stackHas;\n        Stack.prototype.set = stackSet;\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates an array of the enumerable property names of the array-like `value`.\n         *\n         * @private\n         * @param {*} value The value to query.\n         * @param {boolean} inherited Specify returning inherited property names.\n         * @returns {Array} Returns the array of property names.\n         */\n        function arrayLikeKeys(value, inherited) {\n            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;\n            for (var key in value) {\n                if ((inherited || hasOwnProperty.call(value, key)) &&\n                    !(skipIndexes && (\n                    // Safari 9 has enumerable `arguments.length` in strict mode.\n                    key == 'length' ||\n                        // Node.js 0.10 has enumerable non-index properties on buffers.\n                        (isBuff && (key == 'offset' || key == 'parent')) ||\n                        // PhantomJS 2 has enumerable non-index properties on typed arrays.\n                        (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n                        // Skip index properties.\n                        isIndex(key, length)))) {\n                    result.push(key);\n                }\n            }\n            return result;\n        }\n        /**\n         * A specialized version of `_.sample` for arrays.\n         *\n         * @private\n         * @param {Array} array The array to sample.\n         * @returns {*} Returns the random element.\n         */\n        function arraySample(array) {\n            var length = array.length;\n            return length ? array[baseRandom(0, length - 1)] : undefined;\n        }\n        /**\n         * A specialized version of `_.sampleSize` for arrays.\n         *\n         * @private\n         * @param {Array} array The array to sample.\n         * @param {number} n The number of elements to sample.\n         * @returns {Array} Returns the random elements.\n         */\n        function arraySampleSize(array, n) {\n            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n        }\n        /**\n         * A specialized version of `_.shuffle` for arrays.\n         *\n         * @private\n         * @param {Array} array The array to shuffle.\n         * @returns {Array} Returns the new shuffled array.\n         */\n        function arrayShuffle(array) {\n            return shuffleSelf(copyArray(array));\n        }\n        /**\n         * Used by `_.defaults` to customize its `_.assignIn` use.\n         *\n         * @private\n         * @param {*} objValue The destination value.\n         * @param {*} srcValue The source value.\n         * @param {string} key The key of the property to assign.\n         * @param {Object} object The parent object of `objValue`.\n         * @returns {*} Returns the value to assign.\n         */\n        function assignInDefaults(objValue, srcValue, key, object) {\n            if (objValue === undefined ||\n                (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n                return srcValue;\n            }\n            return objValue;\n        }\n        /**\n         * This function is like `assignValue` except that it doesn't assign\n         * `undefined` values.\n         *\n         * @private\n         * @param {Object} object The object to modify.\n         * @param {string} key The key of the property to assign.\n         * @param {*} value The value to assign.\n         */\n        function assignMergeValue(object, key, value) {\n            if ((value !== undefined && !eq(object[key], value)) ||\n                (value === undefined && !(key in object))) {\n                baseAssignValue(object, key, value);\n            }\n        }\n        /**\n         * Assigns `value` to `key` of `object` if the existing value is not equivalent\n         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * @private\n         * @param {Object} object The object to modify.\n         * @param {string} key The key of the property to assign.\n         * @param {*} value The value to assign.\n         */\n        function assignValue(object, key, value) {\n            var objValue = object[key];\n            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n                (value === undefined && !(key in object))) {\n                baseAssignValue(object, key, value);\n            }\n        }\n        /**\n         * Gets the index at which the `key` is found in `array` of key-value pairs.\n         *\n         * @private\n         * @param {Array} array The array to inspect.\n         * @param {*} key The key to search for.\n         * @returns {number} Returns the index of the matched value, else `-1`.\n         */\n        function assocIndexOf(array, key) {\n            var length = array.length;\n            while (length--) {\n                if (eq(array[length][0], key)) {\n                    return length;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Aggregates elements of `collection` on `accumulator` with keys transformed\n         * by `iteratee` and values set by `setter`.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} setter The function to set `accumulator` values.\n         * @param {Function} iteratee The iteratee to transform keys.\n         * @param {Object} accumulator The initial aggregated object.\n         * @returns {Function} Returns `accumulator`.\n         */\n        function baseAggregator(collection, setter, iteratee, accumulator) {\n            baseEach(collection, function (value, key, collection) {\n                setter(accumulator, value, iteratee(value), collection);\n            });\n            return accumulator;\n        }\n        /**\n         * The base implementation of `_.assign` without support for multiple sources\n         * or `customizer` functions.\n         *\n         * @private\n         * @param {Object} object The destination object.\n         * @param {Object} source The source object.\n         * @returns {Object} Returns `object`.\n         */\n        function baseAssign(object, source) {\n            return object && copyObject(source, keys(source), object);\n        }\n        /**\n         * The base implementation of `_.assignIn` without support for multiple sources\n         * or `customizer` functions.\n         *\n         * @private\n         * @param {Object} object The destination object.\n         * @param {Object} source The source object.\n         * @returns {Object} Returns `object`.\n         */\n        function baseAssignIn(object, source) {\n            return object && copyObject(source, keysIn(source), object);\n        }\n        /**\n         * The base implementation of `assignValue` and `assignMergeValue` without\n         * value checks.\n         *\n         * @private\n         * @param {Object} object The object to modify.\n         * @param {string} key The key of the property to assign.\n         * @param {*} value The value to assign.\n         */\n        function baseAssignValue(object, key, value) {\n            if (key == '__proto__' && defineProperty) {\n                defineProperty(object, key, {\n                    'configurable': true,\n                    'enumerable': true,\n                    'value': value,\n                    'writable': true\n                });\n            }\n            else {\n                object[key] = value;\n            }\n        }\n        /**\n         * The base implementation of `_.at` without support for individual paths.\n         *\n         * @private\n         * @param {Object} object The object to iterate over.\n         * @param {string[]} paths The property paths to pick.\n         * @returns {Array} Returns the picked elements.\n         */\n        function baseAt(object, paths) {\n            var index = -1, length = paths.length, result = Array(length), skip = object == null;\n            while (++index < length) {\n                result[index] = skip ? undefined : get(object, paths[index]);\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.clamp` which doesn't coerce arguments.\n         *\n         * @private\n         * @param {number} number The number to clamp.\n         * @param {number} [lower] The lower bound.\n         * @param {number} upper The upper bound.\n         * @returns {number} Returns the clamped number.\n         */\n        function baseClamp(number, lower, upper) {\n            if (number === number) {\n                if (upper !== undefined) {\n                    number = number <= upper ? number : upper;\n                }\n                if (lower !== undefined) {\n                    number = number >= lower ? number : lower;\n                }\n            }\n            return number;\n        }\n        /**\n         * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n         * traversed objects.\n         *\n         * @private\n         * @param {*} value The value to clone.\n         * @param {boolean} bitmask The bitmask flags.\n         *  1 - Deep clone\n         *  2 - Flatten inherited properties\n         *  4 - Clone symbols\n         * @param {Function} [customizer] The function to customize cloning.\n         * @param {string} [key] The key of `value`.\n         * @param {Object} [object] The parent object of `value`.\n         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n         * @returns {*} Returns the cloned value.\n         */\n        function baseClone(value, bitmask, customizer, key, object, stack) {\n            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;\n            if (customizer) {\n                result = object ? customizer(value, key, object, stack) : customizer(value);\n            }\n            if (result !== undefined) {\n                return result;\n            }\n            if (!isObject(value)) {\n                return value;\n            }\n            var isArr = isArray(value);\n            if (isArr) {\n                result = initCloneArray(value);\n                if (!isDeep) {\n                    return copyArray(value, result);\n                }\n            }\n            else {\n                var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;\n                if (isBuffer(value)) {\n                    return cloneBuffer(value, isDeep);\n                }\n                if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n                    result = (isFlat || isFunc) ? {} : initCloneObject(value);\n                    if (!isDeep) {\n                        return isFlat\n                            ? copySymbolsIn(value, baseAssignIn(result, value))\n                            : copySymbols(value, baseAssign(result, value));\n                    }\n                }\n                else {\n                    if (!cloneableTags[tag]) {\n                        return object ? value : {};\n                    }\n                    result = initCloneByTag(value, tag, baseClone, isDeep);\n                }\n            }\n            // Check for circular references and return its corresponding clone.\n            stack || (stack = new Stack);\n            var stacked = stack.get(value);\n            if (stacked) {\n                return stacked;\n            }\n            stack.set(value, result);\n            var keysFunc = isFull\n                ? (isFlat ? getAllKeysIn : getAllKeys)\n                : (isFlat ? keysIn : keys);\n            var props = isArr ? undefined : keysFunc(value);\n            arrayEach(props || value, function (subValue, key) {\n                if (props) {\n                    key = subValue;\n                    subValue = value[key];\n                }\n                // Recursively populate clone (susceptible to call stack limits).\n                assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n            });\n            return result;\n        }\n        /**\n         * The base implementation of `_.conforms` which doesn't clone `source`.\n         *\n         * @private\n         * @param {Object} source The object of property predicates to conform to.\n         * @returns {Function} Returns the new spec function.\n         */\n        function baseConforms(source) {\n            var props = keys(source);\n            return function (object) {\n                return baseConformsTo(object, source, props);\n            };\n        }\n        /**\n         * The base implementation of `_.conformsTo` which accepts `props` to check.\n         *\n         * @private\n         * @param {Object} object The object to inspect.\n         * @param {Object} source The object of property predicates to conform to.\n         * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n         */\n        function baseConformsTo(object, source, props) {\n            var length = props.length;\n            if (object == null) {\n                return !length;\n            }\n            object = Object(object);\n            while (length--) {\n                var key = props[length], predicate = source[key], value = object[key];\n                if ((value === undefined && !(key in object)) || !predicate(value)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * The base implementation of `_.delay` and `_.defer` which accepts `args`\n         * to provide to `func`.\n         *\n         * @private\n         * @param {Function} func The function to delay.\n         * @param {number} wait The number of milliseconds to delay invocation.\n         * @param {Array} args The arguments to provide to `func`.\n         * @returns {number|Object} Returns the timer id or timeout object.\n         */\n        function baseDelay(func, wait, args) {\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            return setTimeout(function () { func.apply(undefined, args); }, wait);\n        }\n        /**\n         * The base implementation of methods like `_.difference` without support\n         * for excluding multiple arrays or iteratee shorthands.\n         *\n         * @private\n         * @param {Array} array The array to inspect.\n         * @param {Array} values The values to exclude.\n         * @param {Function} [iteratee] The iteratee invoked per element.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new array of filtered values.\n         */\n        function baseDifference(array, values, iteratee, comparator) {\n            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;\n            if (!length) {\n                return result;\n            }\n            if (iteratee) {\n                values = arrayMap(values, baseUnary(iteratee));\n            }\n            if (comparator) {\n                includes = arrayIncludesWith;\n                isCommon = false;\n            }\n            else if (values.length >= LARGE_ARRAY_SIZE) {\n                includes = cacheHas;\n                isCommon = false;\n                values = new SetCache(values);\n            }\n            outer: while (++index < length) {\n                var value = array[index], computed = iteratee == null ? value : iteratee(value);\n                value = (comparator || value !== 0) ? value : 0;\n                if (isCommon && computed === computed) {\n                    var valuesIndex = valuesLength;\n                    while (valuesIndex--) {\n                        if (values[valuesIndex] === computed) {\n                            continue outer;\n                        }\n                    }\n                    result.push(value);\n                }\n                else if (!includes(values, computed, comparator)) {\n                    result.push(value);\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.forEach` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} iteratee The function invoked per iteration.\n         * @returns {Array|Object} Returns `collection`.\n         */\n        var baseEach = createBaseEach(baseForOwn);\n        /**\n         * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} iteratee The function invoked per iteration.\n         * @returns {Array|Object} Returns `collection`.\n         */\n        var baseEachRight = createBaseEach(baseForOwnRight, true);\n        /**\n         * The base implementation of `_.every` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} predicate The function invoked per iteration.\n         * @returns {boolean} Returns `true` if all elements pass the predicate check,\n         *  else `false`\n         */\n        function baseEvery(collection, predicate) {\n            var result = true;\n            baseEach(collection, function (value, index, collection) {\n                result = !!predicate(value, index, collection);\n                return result;\n            });\n            return result;\n        }\n        /**\n         * The base implementation of methods like `_.max` and `_.min` which accepts a\n         * `comparator` to determine the extremum value.\n         *\n         * @private\n         * @param {Array} array The array to iterate over.\n         * @param {Function} iteratee The iteratee invoked per iteration.\n         * @param {Function} comparator The comparator used to compare values.\n         * @returns {*} Returns the extremum value.\n         */\n        function baseExtremum(array, iteratee, comparator) {\n            var index = -1, length = array.length;\n            while (++index < length) {\n                var value = array[index], current = iteratee(value);\n                if (current != null && (computed === undefined\n                    ? (current === current && !isSymbol(current))\n                    : comparator(current, computed))) {\n                    var computed = current, result = value;\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.fill` without an iteratee call guard.\n         *\n         * @private\n         * @param {Array} array The array to fill.\n         * @param {*} value The value to fill `array` with.\n         * @param {number} [start=0] The start position.\n         * @param {number} [end=array.length] The end position.\n         * @returns {Array} Returns `array`.\n         */\n        function baseFill(array, value, start, end) {\n            var length = array.length;\n            start = toInteger(start);\n            if (start < 0) {\n                start = -start > length ? 0 : (length + start);\n            }\n            end = (end === undefined || end > length) ? length : toInteger(end);\n            if (end < 0) {\n                end += length;\n            }\n            end = start > end ? 0 : toLength(end);\n            while (start < end) {\n                array[start++] = value;\n            }\n            return array;\n        }\n        /**\n         * The base implementation of `_.filter` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} predicate The function invoked per iteration.\n         * @returns {Array} Returns the new filtered array.\n         */\n        function baseFilter(collection, predicate) {\n            var result = [];\n            baseEach(collection, function (value, index, collection) {\n                if (predicate(value, index, collection)) {\n                    result.push(value);\n                }\n            });\n            return result;\n        }\n        /**\n         * The base implementation of `_.flatten` with support for restricting flattening.\n         *\n         * @private\n         * @param {Array} array The array to flatten.\n         * @param {number} depth The maximum recursion depth.\n         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n         * @param {Array} [result=[]] The initial result value.\n         * @returns {Array} Returns the new flattened array.\n         */\n        function baseFlatten(array, depth, predicate, isStrict, result) {\n            var index = -1, length = array.length;\n            predicate || (predicate = isFlattenable);\n            result || (result = []);\n            while (++index < length) {\n                var value = array[index];\n                if (depth > 0 && predicate(value)) {\n                    if (depth > 1) {\n                        // Recursively flatten arrays (susceptible to call stack limits).\n                        baseFlatten(value, depth - 1, predicate, isStrict, result);\n                    }\n                    else {\n                        arrayPush(result, value);\n                    }\n                }\n                else if (!isStrict) {\n                    result[result.length] = value;\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `baseForOwn` which iterates over `object`\n         * properties returned by `keysFunc` and invokes `iteratee` for each property.\n         * Iteratee functions may exit iteration early by explicitly returning `false`.\n         *\n         * @private\n         * @param {Object} object The object to iterate over.\n         * @param {Function} iteratee The function invoked per iteration.\n         * @param {Function} keysFunc The function to get the keys of `object`.\n         * @returns {Object} Returns `object`.\n         */\n        var baseFor = createBaseFor();\n        /**\n         * This function is like `baseFor` except that it iterates over properties\n         * in the opposite order.\n         *\n         * @private\n         * @param {Object} object The object to iterate over.\n         * @param {Function} iteratee The function invoked per iteration.\n         * @param {Function} keysFunc The function to get the keys of `object`.\n         * @returns {Object} Returns `object`.\n         */\n        var baseForRight = createBaseFor(true);\n        /**\n         * The base implementation of `_.forOwn` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Object} object The object to iterate over.\n         * @param {Function} iteratee The function invoked per iteration.\n         * @returns {Object} Returns `object`.\n         */\n        function baseForOwn(object, iteratee) {\n            return object && baseFor(object, iteratee, keys);\n        }\n        /**\n         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Object} object The object to iterate over.\n         * @param {Function} iteratee The function invoked per iteration.\n         * @returns {Object} Returns `object`.\n         */\n        function baseForOwnRight(object, iteratee) {\n            return object && baseForRight(object, iteratee, keys);\n        }\n        /**\n         * The base implementation of `_.functions` which creates an array of\n         * `object` function property names filtered from `props`.\n         *\n         * @private\n         * @param {Object} object The object to inspect.\n         * @param {Array} props The property names to filter.\n         * @returns {Array} Returns the function names.\n         */\n        function baseFunctions(object, props) {\n            return arrayFilter(props, function (key) {\n                return isFunction(object[key]);\n            });\n        }\n        /**\n         * The base implementation of `_.get` without support for default values.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path of the property to get.\n         * @returns {*} Returns the resolved value.\n         */\n        function baseGet(object, path) {\n            path = castPath(path, object);\n            var index = 0, length = path.length;\n            while (object != null && index < length) {\n                object = object[toKey(path[index++])];\n            }\n            return (index && index == length) ? object : undefined;\n        }\n        /**\n         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n         * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n         * symbols of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @param {Function} keysFunc The function to get the keys of `object`.\n         * @param {Function} symbolsFunc The function to get the symbols of `object`.\n         * @returns {Array} Returns the array of property names and symbols.\n         */\n        function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n            var result = keysFunc(object);\n            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n        }\n        /**\n         * The base implementation of `getTag` without fallbacks for buggy environments.\n         *\n         * @private\n         * @param {*} value The value to query.\n         * @returns {string} Returns the `toStringTag`.\n         */\n        function baseGetTag(value) {\n            if (value == null) {\n                return value === undefined ? undefinedTag : nullTag;\n            }\n            value = Object(value);\n            return (symToStringTag && symToStringTag in value)\n                ? getRawTag(value)\n                : objectToString(value);\n        }\n        /**\n         * The base implementation of `_.gt` which doesn't coerce arguments.\n         *\n         * @private\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if `value` is greater than `other`,\n         *  else `false`.\n         */\n        function baseGt(value, other) {\n            return value > other;\n        }\n        /**\n         * The base implementation of `_.has` without support for deep paths.\n         *\n         * @private\n         * @param {Object} [object] The object to query.\n         * @param {Array|string} key The key to check.\n         * @returns {boolean} Returns `true` if `key` exists, else `false`.\n         */\n        function baseHas(object, key) {\n            return object != null && hasOwnProperty.call(object, key);\n        }\n        /**\n         * The base implementation of `_.hasIn` without support for deep paths.\n         *\n         * @private\n         * @param {Object} [object] The object to query.\n         * @param {Array|string} key The key to check.\n         * @returns {boolean} Returns `true` if `key` exists, else `false`.\n         */\n        function baseHasIn(object, key) {\n            return object != null && key in Object(object);\n        }\n        /**\n         * The base implementation of `_.inRange` which doesn't coerce arguments.\n         *\n         * @private\n         * @param {number} number The number to check.\n         * @param {number} start The start of the range.\n         * @param {number} end The end of the range.\n         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n         */\n        function baseInRange(number, start, end) {\n            return number >= nativeMin(start, end) && number < nativeMax(start, end);\n        }\n        /**\n         * The base implementation of methods like `_.intersection`, without support\n         * for iteratee shorthands, that accepts an array of arrays to inspect.\n         *\n         * @private\n         * @param {Array} arrays The arrays to inspect.\n         * @param {Function} [iteratee] The iteratee invoked per element.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new array of shared values.\n         */\n        function baseIntersection(arrays, iteratee, comparator) {\n            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];\n            while (othIndex--) {\n                var array = arrays[othIndex];\n                if (othIndex && iteratee) {\n                    array = arrayMap(array, baseUnary(iteratee));\n                }\n                maxLength = nativeMin(array.length, maxLength);\n                caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n                    ? new SetCache(othIndex && array)\n                    : undefined;\n            }\n            array = arrays[0];\n            var index = -1, seen = caches[0];\n            outer: while (++index < length && result.length < maxLength) {\n                var value = array[index], computed = iteratee ? iteratee(value) : value;\n                value = (comparator || value !== 0) ? value : 0;\n                if (!(seen\n                    ? cacheHas(seen, computed)\n                    : includes(result, computed, comparator))) {\n                    othIndex = othLength;\n                    while (--othIndex) {\n                        var cache = caches[othIndex];\n                        if (!(cache\n                            ? cacheHas(cache, computed)\n                            : includes(arrays[othIndex], computed, comparator))) {\n                            continue outer;\n                        }\n                    }\n                    if (seen) {\n                        seen.push(computed);\n                    }\n                    result.push(value);\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.invert` and `_.invertBy` which inverts\n         * `object` with values transformed by `iteratee` and set by `setter`.\n         *\n         * @private\n         * @param {Object} object The object to iterate over.\n         * @param {Function} setter The function to set `accumulator` values.\n         * @param {Function} iteratee The iteratee to transform values.\n         * @param {Object} accumulator The initial inverted object.\n         * @returns {Function} Returns `accumulator`.\n         */\n        function baseInverter(object, setter, iteratee, accumulator) {\n            baseForOwn(object, function (value, key, object) {\n                setter(accumulator, iteratee(value), key, object);\n            });\n            return accumulator;\n        }\n        /**\n         * The base implementation of `_.invoke` without support for individual\n         * method arguments.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path of the method to invoke.\n         * @param {Array} args The arguments to invoke the method with.\n         * @returns {*} Returns the result of the invoked method.\n         */\n        function baseInvoke(object, path, args) {\n            path = castPath(path, object);\n            object = parent(object, path);\n            var func = object == null ? object : object[toKey(last(path))];\n            return func == null ? undefined : apply(func, object, args);\n        }\n        /**\n         * The base implementation of `_.isArguments`.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n         */\n        function baseIsArguments(value) {\n            return isObjectLike(value) && baseGetTag(value) == argsTag;\n        }\n        /**\n         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n         */\n        function baseIsArrayBuffer(value) {\n            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n        }\n        /**\n         * The base implementation of `_.isDate` without Node.js optimizations.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n         */\n        function baseIsDate(value) {\n            return isObjectLike(value) && baseGetTag(value) == dateTag;\n        }\n        /**\n         * The base implementation of `_.isEqual` which supports partial comparisons\n         * and tracks traversed objects.\n         *\n         * @private\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @param {boolean} bitmask The bitmask flags.\n         *  1 - Unordered comparison\n         *  2 - Partial comparison\n         * @param {Function} [customizer] The function to customize comparisons.\n         * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n         */\n        function baseIsEqual(value, other, bitmask, customizer, stack) {\n            if (value === other) {\n                return true;\n            }\n            if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {\n                return value !== value && other !== other;\n            }\n            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n        }\n        /**\n         * A specialized version of `baseIsEqual` for arrays and objects which performs\n         * deep comparisons and tracks traversed objects enabling objects with circular\n         * references to be compared.\n         *\n         * @private\n         * @param {Object} object The object to compare.\n         * @param {Object} other The other object to compare.\n         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n         * @param {Function} customizer The function to customize comparisons.\n         * @param {Function} equalFunc The function to determine equivalents of values.\n         * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n         */\n        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;\n            if (!objIsArr) {\n                objTag = getTag(object);\n                objTag = objTag == argsTag ? objectTag : objTag;\n            }\n            if (!othIsArr) {\n                othTag = getTag(other);\n                othTag = othTag == argsTag ? objectTag : othTag;\n            }\n            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n            if (isSameTag && isBuffer(object)) {\n                if (!isBuffer(other)) {\n                    return false;\n                }\n                objIsArr = true;\n                objIsObj = false;\n            }\n            if (isSameTag && !objIsObj) {\n                stack || (stack = new Stack);\n                return (objIsArr || isTypedArray(object))\n                    ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n                    : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n            }\n            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n                var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n                if (objIsWrapped || othIsWrapped) {\n                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n                    stack || (stack = new Stack);\n                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n                }\n            }\n            if (!isSameTag) {\n                return false;\n            }\n            stack || (stack = new Stack);\n            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n        }\n        /**\n         * The base implementation of `_.isMap` without Node.js optimizations.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n         */\n        function baseIsMap(value) {\n            return isObjectLike(value) && getTag(value) == mapTag;\n        }\n        /**\n         * The base implementation of `_.isMatch` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Object} object The object to inspect.\n         * @param {Object} source The object of property values to match.\n         * @param {Array} matchData The property names, values, and compare flags to match.\n         * @param {Function} [customizer] The function to customize comparisons.\n         * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n         */\n        function baseIsMatch(object, source, matchData, customizer) {\n            var index = matchData.length, length = index, noCustomizer = !customizer;\n            if (object == null) {\n                return !length;\n            }\n            object = Object(object);\n            while (index--) {\n                var data = matchData[index];\n                if ((noCustomizer && data[2])\n                    ? data[1] !== object[data[0]]\n                    : !(data[0] in object)) {\n                    return false;\n                }\n            }\n            while (++index < length) {\n                data = matchData[index];\n                var key = data[0], objValue = object[key], srcValue = data[1];\n                if (noCustomizer && data[2]) {\n                    if (objValue === undefined && !(key in object)) {\n                        return false;\n                    }\n                }\n                else {\n                    var stack = new Stack;\n                    if (customizer) {\n                        var result = customizer(objValue, srcValue, key, object, source, stack);\n                    }\n                    if (!(result === undefined\n                        ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                        : result)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        /**\n         * The base implementation of `_.isNative` without bad shim checks.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a native function,\n         *  else `false`.\n         */\n        function baseIsNative(value) {\n            if (!isObject(value) || isMasked(value)) {\n                return false;\n            }\n            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n            return pattern.test(toSource(value));\n        }\n        /**\n         * The base implementation of `_.isRegExp` without Node.js optimizations.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n         */\n        function baseIsRegExp(value) {\n            return isObjectLike(value) && baseGetTag(value) == regexpTag;\n        }\n        /**\n         * The base implementation of `_.isSet` without Node.js optimizations.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n         */\n        function baseIsSet(value) {\n            return isObjectLike(value) && getTag(value) == setTag;\n        }\n        /**\n         * The base implementation of `_.isTypedArray` without Node.js optimizations.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n         */\n        function baseIsTypedArray(value) {\n            return isObjectLike(value) &&\n                isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n        }\n        /**\n         * The base implementation of `_.iteratee`.\n         *\n         * @private\n         * @param {*} [value=_.identity] The value to convert to an iteratee.\n         * @returns {Function} Returns the iteratee.\n         */\n        function baseIteratee(value) {\n            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n            if (typeof value == 'function') {\n                return value;\n            }\n            if (value == null) {\n                return identity;\n            }\n            if (typeof value == 'object') {\n                return isArray(value)\n                    ? baseMatchesProperty(value[0], value[1])\n                    : baseMatches(value);\n            }\n            return property(value);\n        }\n        /**\n         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property names.\n         */\n        function baseKeys(object) {\n            if (!isPrototype(object)) {\n                return nativeKeys(object);\n            }\n            var result = [];\n            for (var key in Object(object)) {\n                if (hasOwnProperty.call(object, key) && key != 'constructor') {\n                    result.push(key);\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property names.\n         */\n        function baseKeysIn(object) {\n            if (!isObject(object)) {\n                return nativeKeysIn(object);\n            }\n            var isProto = isPrototype(object), result = [];\n            for (var key in object) {\n                if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n                    result.push(key);\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.lt` which doesn't coerce arguments.\n         *\n         * @private\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if `value` is less than `other`,\n         *  else `false`.\n         */\n        function baseLt(value, other) {\n            return value < other;\n        }\n        /**\n         * The base implementation of `_.map` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} iteratee The function invoked per iteration.\n         * @returns {Array} Returns the new mapped array.\n         */\n        function baseMap(collection, iteratee) {\n            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];\n            baseEach(collection, function (value, key, collection) {\n                result[++index] = iteratee(value, key, collection);\n            });\n            return result;\n        }\n        /**\n         * The base implementation of `_.matches` which doesn't clone `source`.\n         *\n         * @private\n         * @param {Object} source The object of property values to match.\n         * @returns {Function} Returns the new spec function.\n         */\n        function baseMatches(source) {\n            var matchData = getMatchData(source);\n            if (matchData.length == 1 && matchData[0][2]) {\n                return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n            }\n            return function (object) {\n                return object === source || baseIsMatch(object, source, matchData);\n            };\n        }\n        /**\n         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n         *\n         * @private\n         * @param {string} path The path of the property to get.\n         * @param {*} srcValue The value to match.\n         * @returns {Function} Returns the new spec function.\n         */\n        function baseMatchesProperty(path, srcValue) {\n            if (isKey(path) && isStrictComparable(srcValue)) {\n                return matchesStrictComparable(toKey(path), srcValue);\n            }\n            return function (object) {\n                var objValue = get(object, path);\n                return (objValue === undefined && objValue === srcValue)\n                    ? hasIn(object, path)\n                    : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n            };\n        }\n        /**\n         * The base implementation of `_.merge` without support for multiple sources.\n         *\n         * @private\n         * @param {Object} object The destination object.\n         * @param {Object} source The source object.\n         * @param {number} srcIndex The index of `source`.\n         * @param {Function} [customizer] The function to customize merged values.\n         * @param {Object} [stack] Tracks traversed source values and their merged\n         *  counterparts.\n         */\n        function baseMerge(object, source, srcIndex, customizer, stack) {\n            if (object === source) {\n                return;\n            }\n            baseFor(source, function (srcValue, key) {\n                if (isObject(srcValue)) {\n                    stack || (stack = new Stack);\n                    baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n                }\n                else {\n                    var newValue = customizer\n                        ? customizer(object[key], srcValue, (key + ''), object, source, stack)\n                        : undefined;\n                    if (newValue === undefined) {\n                        newValue = srcValue;\n                    }\n                    assignMergeValue(object, key, newValue);\n                }\n            }, keysIn);\n        }\n        /**\n         * A specialized version of `baseMerge` for arrays and objects which performs\n         * deep merges and tracks traversed objects enabling objects with circular\n         * references to be merged.\n         *\n         * @private\n         * @param {Object} object The destination object.\n         * @param {Object} source The source object.\n         * @param {string} key The key of the value to merge.\n         * @param {number} srcIndex The index of `source`.\n         * @param {Function} mergeFunc The function to merge values.\n         * @param {Function} [customizer] The function to customize assigned values.\n         * @param {Object} [stack] Tracks traversed source values and their merged\n         *  counterparts.\n         */\n        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n            var objValue = object[key], srcValue = source[key], stacked = stack.get(srcValue);\n            if (stacked) {\n                assignMergeValue(object, key, stacked);\n                return;\n            }\n            var newValue = customizer\n                ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n                : undefined;\n            var isCommon = newValue === undefined;\n            if (isCommon) {\n                var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n                newValue = srcValue;\n                if (isArr || isBuff || isTyped) {\n                    if (isArray(objValue)) {\n                        newValue = objValue;\n                    }\n                    else if (isArrayLikeObject(objValue)) {\n                        newValue = copyArray(objValue);\n                    }\n                    else if (isBuff) {\n                        isCommon = false;\n                        newValue = cloneBuffer(srcValue, true);\n                    }\n                    else if (isTyped) {\n                        isCommon = false;\n                        newValue = cloneTypedArray(srcValue, true);\n                    }\n                    else {\n                        newValue = [];\n                    }\n                }\n                else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                    newValue = objValue;\n                    if (isArguments(objValue)) {\n                        newValue = toPlainObject(objValue);\n                    }\n                    else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {\n                        newValue = initCloneObject(srcValue);\n                    }\n                }\n                else {\n                    isCommon = false;\n                }\n            }\n            if (isCommon) {\n                // Recursively merge objects and arrays (susceptible to call stack limits).\n                stack.set(srcValue, newValue);\n                mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n                stack['delete'](srcValue);\n            }\n            assignMergeValue(object, key, newValue);\n        }\n        /**\n         * The base implementation of `_.nth` which doesn't coerce arguments.\n         *\n         * @private\n         * @param {Array} array The array to query.\n         * @param {number} n The index of the element to return.\n         * @returns {*} Returns the nth element of `array`.\n         */\n        function baseNth(array, n) {\n            var length = array.length;\n            if (!length) {\n                return;\n            }\n            n += n < 0 ? length : 0;\n            return isIndex(n, length) ? array[n] : undefined;\n        }\n        /**\n         * The base implementation of `_.orderBy` without param guards.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n         * @param {string[]} orders The sort orders of `iteratees`.\n         * @returns {Array} Returns the new sorted array.\n         */\n        function baseOrderBy(collection, iteratees, orders) {\n            var index = -1;\n            iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n            var result = baseMap(collection, function (value, key, collection) {\n                var criteria = arrayMap(iteratees, function (iteratee) {\n                    return iteratee(value);\n                });\n                return { 'criteria': criteria, 'index': ++index, 'value': value };\n            });\n            return baseSortBy(result, function (object, other) {\n                return compareMultiple(object, other, orders);\n            });\n        }\n        /**\n         * The base implementation of `_.pick` without support for individual\n         * property identifiers.\n         *\n         * @private\n         * @param {Object} object The source object.\n         * @param {string[]} paths The property paths to pick.\n         * @returns {Object} Returns the new object.\n         */\n        function basePick(object, paths) {\n            object = Object(object);\n            return basePickBy(object, paths, function (value, path) {\n                return hasIn(object, path);\n            });\n        }\n        /**\n         * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Object} object The source object.\n         * @param {string[]} paths The property paths to pick.\n         * @param {Function} predicate The function invoked per property.\n         * @returns {Object} Returns the new object.\n         */\n        function basePickBy(object, paths, predicate) {\n            var index = -1, length = paths.length, result = {};\n            while (++index < length) {\n                var path = paths[index], value = baseGet(object, path);\n                if (predicate(value, path)) {\n                    baseSet(result, castPath(path, object), value);\n                }\n            }\n            return result;\n        }\n        /**\n         * A specialized version of `baseProperty` which supports deep paths.\n         *\n         * @private\n         * @param {Array|string} path The path of the property to get.\n         * @returns {Function} Returns the new accessor function.\n         */\n        function basePropertyDeep(path) {\n            return function (object) {\n                return baseGet(object, path);\n            };\n        }\n        /**\n         * The base implementation of `_.pullAllBy` without support for iteratee\n         * shorthands.\n         *\n         * @private\n         * @param {Array} array The array to modify.\n         * @param {Array} values The values to remove.\n         * @param {Function} [iteratee] The iteratee invoked per element.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns `array`.\n         */\n        function basePullAll(array, values, iteratee, comparator) {\n            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;\n            if (array === values) {\n                values = copyArray(values);\n            }\n            if (iteratee) {\n                seen = arrayMap(array, baseUnary(iteratee));\n            }\n            while (++index < length) {\n                var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;\n                while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n                    if (seen !== array) {\n                        splice.call(seen, fromIndex, 1);\n                    }\n                    splice.call(array, fromIndex, 1);\n                }\n            }\n            return array;\n        }\n        /**\n         * The base implementation of `_.pullAt` without support for individual\n         * indexes or capturing the removed elements.\n         *\n         * @private\n         * @param {Array} array The array to modify.\n         * @param {number[]} indexes The indexes of elements to remove.\n         * @returns {Array} Returns `array`.\n         */\n        function basePullAt(array, indexes) {\n            var length = array ? indexes.length : 0, lastIndex = length - 1;\n            while (length--) {\n                var index = indexes[length];\n                if (length == lastIndex || index !== previous) {\n                    var previous = index;\n                    if (isIndex(index)) {\n                        splice.call(array, index, 1);\n                    }\n                    else {\n                        baseUnset(array, index);\n                    }\n                }\n            }\n            return array;\n        }\n        /**\n         * The base implementation of `_.random` without support for returning\n         * floating-point numbers.\n         *\n         * @private\n         * @param {number} lower The lower bound.\n         * @param {number} upper The upper bound.\n         * @returns {number} Returns the random number.\n         */\n        function baseRandom(lower, upper) {\n            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n        }\n        /**\n         * The base implementation of `_.range` and `_.rangeRight` which doesn't\n         * coerce arguments.\n         *\n         * @private\n         * @param {number} start The start of the range.\n         * @param {number} end The end of the range.\n         * @param {number} step The value to increment or decrement by.\n         * @param {boolean} [fromRight] Specify iterating from right to left.\n         * @returns {Array} Returns the range of numbers.\n         */\n        function baseRange(start, end, step, fromRight) {\n            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);\n            while (length--) {\n                result[fromRight ? length : ++index] = start;\n                start += step;\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.repeat` which doesn't coerce arguments.\n         *\n         * @private\n         * @param {string} string The string to repeat.\n         * @param {number} n The number of times to repeat the string.\n         * @returns {string} Returns the repeated string.\n         */\n        function baseRepeat(string, n) {\n            var result = '';\n            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n                return result;\n            }\n            // Leverage the exponentiation by squaring algorithm for a faster repeat.\n            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n            do {\n                if (n % 2) {\n                    result += string;\n                }\n                n = nativeFloor(n / 2);\n                if (n) {\n                    string += string;\n                }\n            } while (n);\n            return result;\n        }\n        /**\n         * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n         *\n         * @private\n         * @param {Function} func The function to apply a rest parameter to.\n         * @param {number} [start=func.length-1] The start position of the rest parameter.\n         * @returns {Function} Returns the new function.\n         */\n        function baseRest(func, start) {\n            return setToString(overRest(func, start, identity), func + '');\n        }\n        /**\n         * The base implementation of `_.sample`.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to sample.\n         * @returns {*} Returns the random element.\n         */\n        function baseSample(collection) {\n            return arraySample(values(collection));\n        }\n        /**\n         * The base implementation of `_.sampleSize` without param guards.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to sample.\n         * @param {number} n The number of elements to sample.\n         * @returns {Array} Returns the random elements.\n         */\n        function baseSampleSize(collection, n) {\n            var array = values(collection);\n            return shuffleSelf(array, baseClamp(n, 0, array.length));\n        }\n        /**\n         * The base implementation of `_.set`.\n         *\n         * @private\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The path of the property to set.\n         * @param {*} value The value to set.\n         * @param {Function} [customizer] The function to customize path creation.\n         * @returns {Object} Returns `object`.\n         */\n        function baseSet(object, path, value, customizer) {\n            if (!isObject(object)) {\n                return object;\n            }\n            path = castPath(path, object);\n            var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n            while (nested != null && ++index < length) {\n                var key = toKey(path[index]), newValue = value;\n                if (index != lastIndex) {\n                    var objValue = nested[key];\n                    newValue = customizer ? customizer(objValue, key, nested) : undefined;\n                    if (newValue === undefined) {\n                        newValue = isObject(objValue)\n                            ? objValue\n                            : (isIndex(path[index + 1]) ? [] : {});\n                    }\n                }\n                assignValue(nested, key, newValue);\n                nested = nested[key];\n            }\n            return object;\n        }\n        /**\n         * The base implementation of `setData` without support for hot loop shorting.\n         *\n         * @private\n         * @param {Function} func The function to associate metadata with.\n         * @param {*} data The metadata.\n         * @returns {Function} Returns `func`.\n         */\n        var baseSetData = !metaMap ? identity : function (func, data) {\n            metaMap.set(func, data);\n            return func;\n        };\n        /**\n         * The base implementation of `setToString` without support for hot loop shorting.\n         *\n         * @private\n         * @param {Function} func The function to modify.\n         * @param {Function} string The `toString` result.\n         * @returns {Function} Returns `func`.\n         */\n        var baseSetToString = !defineProperty ? identity : function (func, string) {\n            return defineProperty(func, 'toString', {\n                'configurable': true,\n                'enumerable': false,\n                'value': constant(string),\n                'writable': true\n            });\n        };\n        /**\n         * The base implementation of `_.shuffle`.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to shuffle.\n         * @returns {Array} Returns the new shuffled array.\n         */\n        function baseShuffle(collection) {\n            return shuffleSelf(values(collection));\n        }\n        /**\n         * The base implementation of `_.slice` without an iteratee call guard.\n         *\n         * @private\n         * @param {Array} array The array to slice.\n         * @param {number} [start=0] The start position.\n         * @param {number} [end=array.length] The end position.\n         * @returns {Array} Returns the slice of `array`.\n         */\n        function baseSlice(array, start, end) {\n            var index = -1, length = array.length;\n            if (start < 0) {\n                start = -start > length ? 0 : (length + start);\n            }\n            end = end > length ? length : end;\n            if (end < 0) {\n                end += length;\n            }\n            length = start > end ? 0 : ((end - start) >>> 0);\n            start >>>= 0;\n            var result = Array(length);\n            while (++index < length) {\n                result[index] = array[index + start];\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.some` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} predicate The function invoked per iteration.\n         * @returns {boolean} Returns `true` if any element passes the predicate check,\n         *  else `false`.\n         */\n        function baseSome(collection, predicate) {\n            var result;\n            baseEach(collection, function (value, index, collection) {\n                result = predicate(value, index, collection);\n                return !result;\n            });\n            return !!result;\n        }\n        /**\n         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n         * performs a binary search of `array` to determine the index at which `value`\n         * should be inserted into `array` in order to maintain its sort order.\n         *\n         * @private\n         * @param {Array} array The sorted array to inspect.\n         * @param {*} value The value to evaluate.\n         * @param {boolean} [retHighest] Specify returning the highest qualified index.\n         * @returns {number} Returns the index at which `value` should be inserted\n         *  into `array`.\n         */\n        function baseSortedIndex(array, value, retHighest) {\n            var low = 0, high = array == null ? low : array.length;\n            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n                while (low < high) {\n                    var mid = (low + high) >>> 1, computed = array[mid];\n                    if (computed !== null && !isSymbol(computed) &&\n                        (retHighest ? (computed <= value) : (computed < value))) {\n                        low = mid + 1;\n                    }\n                    else {\n                        high = mid;\n                    }\n                }\n                return high;\n            }\n            return baseSortedIndexBy(array, value, identity, retHighest);\n        }\n        /**\n         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n         * which invokes `iteratee` for `value` and each element of `array` to compute\n         * their sort ranking. The iteratee is invoked with one argument; (value).\n         *\n         * @private\n         * @param {Array} array The sorted array to inspect.\n         * @param {*} value The value to evaluate.\n         * @param {Function} iteratee The iteratee invoked per element.\n         * @param {boolean} [retHighest] Specify returning the highest qualified index.\n         * @returns {number} Returns the index at which `value` should be inserted\n         *  into `array`.\n         */\n        function baseSortedIndexBy(array, value, iteratee, retHighest) {\n            value = iteratee(value);\n            var low = 0, high = array == null ? 0 : array.length, valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;\n            while (low < high) {\n                var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);\n                if (valIsNaN) {\n                    var setLow = retHighest || othIsReflexive;\n                }\n                else if (valIsUndefined) {\n                    setLow = othIsReflexive && (retHighest || othIsDefined);\n                }\n                else if (valIsNull) {\n                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n                }\n                else if (valIsSymbol) {\n                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n                }\n                else if (othIsNull || othIsSymbol) {\n                    setLow = false;\n                }\n                else {\n                    setLow = retHighest ? (computed <= value) : (computed < value);\n                }\n                if (setLow) {\n                    low = mid + 1;\n                }\n                else {\n                    high = mid;\n                }\n            }\n            return nativeMin(high, MAX_ARRAY_INDEX);\n        }\n        /**\n         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n         * support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array} array The array to inspect.\n         * @param {Function} [iteratee] The iteratee invoked per element.\n         * @returns {Array} Returns the new duplicate free array.\n         */\n        function baseSortedUniq(array, iteratee) {\n            var index = -1, length = array.length, resIndex = 0, result = [];\n            while (++index < length) {\n                var value = array[index], computed = iteratee ? iteratee(value) : value;\n                if (!index || !eq(computed, seen)) {\n                    var seen = computed;\n                    result[resIndex++] = value === 0 ? 0 : value;\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.toNumber` which doesn't ensure correct\n         * conversions of binary, hexadecimal, or octal string values.\n         *\n         * @private\n         * @param {*} value The value to process.\n         * @returns {number} Returns the number.\n         */\n        function baseToNumber(value) {\n            if (typeof value == 'number') {\n                return value;\n            }\n            if (isSymbol(value)) {\n                return NAN;\n            }\n            return +value;\n        }\n        /**\n         * The base implementation of `_.toString` which doesn't convert nullish\n         * values to empty strings.\n         *\n         * @private\n         * @param {*} value The value to process.\n         * @returns {string} Returns the string.\n         */\n        function baseToString(value) {\n            // Exit early for strings to avoid a performance hit in some environments.\n            if (typeof value == 'string') {\n                return value;\n            }\n            if (isArray(value)) {\n                // Recursively convert values (susceptible to call stack limits).\n                return arrayMap(value, baseToString) + '';\n            }\n            if (isSymbol(value)) {\n                return symbolToString ? symbolToString.call(value) : '';\n            }\n            var result = (value + '');\n            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n        }\n        /**\n         * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array} array The array to inspect.\n         * @param {Function} [iteratee] The iteratee invoked per element.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new duplicate free array.\n         */\n        function baseUniq(array, iteratee, comparator) {\n            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;\n            if (comparator) {\n                isCommon = false;\n                includes = arrayIncludesWith;\n            }\n            else if (length >= LARGE_ARRAY_SIZE) {\n                var set = iteratee ? null : createSet(array);\n                if (set) {\n                    return setToArray(set);\n                }\n                isCommon = false;\n                includes = cacheHas;\n                seen = new SetCache;\n            }\n            else {\n                seen = iteratee ? [] : result;\n            }\n            outer: while (++index < length) {\n                var value = array[index], computed = iteratee ? iteratee(value) : value;\n                value = (comparator || value !== 0) ? value : 0;\n                if (isCommon && computed === computed) {\n                    var seenIndex = seen.length;\n                    while (seenIndex--) {\n                        if (seen[seenIndex] === computed) {\n                            continue outer;\n                        }\n                    }\n                    if (iteratee) {\n                        seen.push(computed);\n                    }\n                    result.push(value);\n                }\n                else if (!includes(seen, computed, comparator)) {\n                    if (seen !== result) {\n                        seen.push(computed);\n                    }\n                    result.push(value);\n                }\n            }\n            return result;\n        }\n        /**\n         * The base implementation of `_.unset`.\n         *\n         * @private\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The property path to unset.\n         * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n         */\n        function baseUnset(object, path) {\n            path = castPath(path, object);\n            object = parent(object, path);\n            return object == null || delete object[toKey(last(path))];\n        }\n        /**\n         * The base implementation of `_.update`.\n         *\n         * @private\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The path of the property to update.\n         * @param {Function} updater The function to produce the updated value.\n         * @param {Function} [customizer] The function to customize path creation.\n         * @returns {Object} Returns `object`.\n         */\n        function baseUpdate(object, path, updater, customizer) {\n            return baseSet(object, path, updater(baseGet(object, path)), customizer);\n        }\n        /**\n         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n         * without support for iteratee shorthands.\n         *\n         * @private\n         * @param {Array} array The array to query.\n         * @param {Function} predicate The function invoked per iteration.\n         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n         * @param {boolean} [fromRight] Specify iterating from right to left.\n         * @returns {Array} Returns the slice of `array`.\n         */\n        function baseWhile(array, predicate, isDrop, fromRight) {\n            var length = array.length, index = fromRight ? length : -1;\n            while ((fromRight ? index-- : ++index < length) &&\n                predicate(array[index], index, array)) { }\n            return isDrop\n                ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n                : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n        }\n        /**\n         * The base implementation of `wrapperValue` which returns the result of\n         * performing a sequence of actions on the unwrapped `value`, where each\n         * successive action is supplied the return value of the previous.\n         *\n         * @private\n         * @param {*} value The unwrapped value.\n         * @param {Array} actions Actions to perform to resolve the unwrapped value.\n         * @returns {*} Returns the resolved value.\n         */\n        function baseWrapperValue(value, actions) {\n            var result = value;\n            if (result instanceof LazyWrapper) {\n                result = result.value();\n            }\n            return arrayReduce(actions, function (result, action) {\n                return action.func.apply(action.thisArg, arrayPush([result], action.args));\n            }, result);\n        }\n        /**\n         * The base implementation of methods like `_.xor`, without support for\n         * iteratee shorthands, that accepts an array of arrays to inspect.\n         *\n         * @private\n         * @param {Array} arrays The arrays to inspect.\n         * @param {Function} [iteratee] The iteratee invoked per element.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new array of values.\n         */\n        function baseXor(arrays, iteratee, comparator) {\n            var length = arrays.length;\n            if (length < 2) {\n                return length ? baseUniq(arrays[0]) : [];\n            }\n            var index = -1, result = Array(length);\n            while (++index < length) {\n                var array = arrays[index], othIndex = -1;\n                while (++othIndex < length) {\n                    if (othIndex != index) {\n                        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n                    }\n                }\n            }\n            return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n        }\n        /**\n         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n         *\n         * @private\n         * @param {Array} props The property identifiers.\n         * @param {Array} values The property values.\n         * @param {Function} assignFunc The function to assign values.\n         * @returns {Object} Returns the new object.\n         */\n        function baseZipObject(props, values, assignFunc) {\n            var index = -1, length = props.length, valsLength = values.length, result = {};\n            while (++index < length) {\n                var value = index < valsLength ? values[index] : undefined;\n                assignFunc(result, props[index], value);\n            }\n            return result;\n        }\n        /**\n         * Casts `value` to an empty array if it's not an array like object.\n         *\n         * @private\n         * @param {*} value The value to inspect.\n         * @returns {Array|Object} Returns the cast array-like object.\n         */\n        function castArrayLikeObject(value) {\n            return isArrayLikeObject(value) ? value : [];\n        }\n        /**\n         * Casts `value` to `identity` if it's not a function.\n         *\n         * @private\n         * @param {*} value The value to inspect.\n         * @returns {Function} Returns cast function.\n         */\n        function castFunction(value) {\n            return typeof value == 'function' ? value : identity;\n        }\n        /**\n         * Casts `value` to a path array if it's not one.\n         *\n         * @private\n         * @param {*} value The value to inspect.\n         * @param {Object} [object] The object to query keys on.\n         * @returns {Array} Returns the cast property path array.\n         */\n        function castPath(value, object) {\n            if (isArray(value)) {\n                return value;\n            }\n            return isKey(value, object) ? [value] : stringToPath(toString(value));\n        }\n        /**\n         * A `baseRest` alias which can be replaced with `identity` by module\n         * replacement plugins.\n         *\n         * @private\n         * @type {Function}\n         * @param {Function} func The function to apply a rest parameter to.\n         * @returns {Function} Returns the new function.\n         */\n        var castRest = baseRest;\n        /**\n         * Casts `array` to a slice if it's needed.\n         *\n         * @private\n         * @param {Array} array The array to inspect.\n         * @param {number} start The start position.\n         * @param {number} [end=array.length] The end position.\n         * @returns {Array} Returns the cast slice.\n         */\n        function castSlice(array, start, end) {\n            var length = array.length;\n            end = end === undefined ? length : end;\n            return (!start && end >= length) ? array : baseSlice(array, start, end);\n        }\n        /**\n         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n         *\n         * @private\n         * @param {number|Object} id The timer id or timeout object of the timer to clear.\n         */\n        var clearTimeout = ctxClearTimeout || function (id) {\n            return root.clearTimeout(id);\n        };\n        /**\n         * Creates a clone of  `buffer`.\n         *\n         * @private\n         * @param {Buffer} buffer The buffer to clone.\n         * @param {boolean} [isDeep] Specify a deep clone.\n         * @returns {Buffer} Returns the cloned buffer.\n         */\n        function cloneBuffer(buffer, isDeep) {\n            if (isDeep) {\n                return buffer.slice();\n            }\n            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n            buffer.copy(result);\n            return result;\n        }\n        /**\n         * Creates a clone of `arrayBuffer`.\n         *\n         * @private\n         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n         * @returns {ArrayBuffer} Returns the cloned array buffer.\n         */\n        function cloneArrayBuffer(arrayBuffer) {\n            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n            new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n            return result;\n        }\n        /**\n         * Creates a clone of `dataView`.\n         *\n         * @private\n         * @param {Object} dataView The data view to clone.\n         * @param {boolean} [isDeep] Specify a deep clone.\n         * @returns {Object} Returns the cloned data view.\n         */\n        function cloneDataView(dataView, isDeep) {\n            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n        }\n        /**\n         * Creates a clone of `map`.\n         *\n         * @private\n         * @param {Object} map The map to clone.\n         * @param {Function} cloneFunc The function to clone values.\n         * @param {boolean} [isDeep] Specify a deep clone.\n         * @returns {Object} Returns the cloned map.\n         */\n        function cloneMap(map, isDeep, cloneFunc) {\n            var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);\n            return arrayReduce(array, addMapEntry, new map.constructor);\n        }\n        /**\n         * Creates a clone of `regexp`.\n         *\n         * @private\n         * @param {Object} regexp The regexp to clone.\n         * @returns {Object} Returns the cloned regexp.\n         */\n        function cloneRegExp(regexp) {\n            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n            result.lastIndex = regexp.lastIndex;\n            return result;\n        }\n        /**\n         * Creates a clone of `set`.\n         *\n         * @private\n         * @param {Object} set The set to clone.\n         * @param {Function} cloneFunc The function to clone values.\n         * @param {boolean} [isDeep] Specify a deep clone.\n         * @returns {Object} Returns the cloned set.\n         */\n        function cloneSet(set, isDeep, cloneFunc) {\n            var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);\n            return arrayReduce(array, addSetEntry, new set.constructor);\n        }\n        /**\n         * Creates a clone of the `symbol` object.\n         *\n         * @private\n         * @param {Object} symbol The symbol object to clone.\n         * @returns {Object} Returns the cloned symbol object.\n         */\n        function cloneSymbol(symbol) {\n            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n        }\n        /**\n         * Creates a clone of `typedArray`.\n         *\n         * @private\n         * @param {Object} typedArray The typed array to clone.\n         * @param {boolean} [isDeep] Specify a deep clone.\n         * @returns {Object} Returns the cloned typed array.\n         */\n        function cloneTypedArray(typedArray, isDeep) {\n            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n        }\n        /**\n         * Compares values to sort them in ascending order.\n         *\n         * @private\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {number} Returns the sort order indicator for `value`.\n         */\n        function compareAscending(value, other) {\n            if (value !== other) {\n                var valIsDefined = value !== undefined, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);\n                var othIsDefined = other !== undefined, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);\n                if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n                    (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n                    (valIsNull && othIsDefined && othIsReflexive) ||\n                    (!valIsDefined && othIsReflexive) ||\n                    !valIsReflexive) {\n                    return 1;\n                }\n                if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n                    (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n                    (othIsNull && valIsDefined && valIsReflexive) ||\n                    (!othIsDefined && valIsReflexive) ||\n                    !othIsReflexive) {\n                    return -1;\n                }\n            }\n            return 0;\n        }\n        /**\n         * Used by `_.orderBy` to compare multiple properties of a value to another\n         * and stable sort them.\n         *\n         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n         * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n         * of corresponding values.\n         *\n         * @private\n         * @param {Object} object The object to compare.\n         * @param {Object} other The other object to compare.\n         * @param {boolean[]|string[]} orders The order to sort by for each property.\n         * @returns {number} Returns the sort order indicator for `object`.\n         */\n        function compareMultiple(object, other, orders) {\n            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;\n            while (++index < length) {\n                var result = compareAscending(objCriteria[index], othCriteria[index]);\n                if (result) {\n                    if (index >= ordersLength) {\n                        return result;\n                    }\n                    var order = orders[index];\n                    return result * (order == 'desc' ? -1 : 1);\n                }\n            }\n            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n            // that causes it, under certain circumstances, to provide the same value for\n            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n            // for more details.\n            //\n            // This also ensures a stable sort in V8 and other engines.\n            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n            return object.index - other.index;\n        }\n        /**\n         * Creates an array that is the composition of partially applied arguments,\n         * placeholders, and provided arguments into a single array of arguments.\n         *\n         * @private\n         * @param {Array} args The provided arguments.\n         * @param {Array} partials The arguments to prepend to those provided.\n         * @param {Array} holders The `partials` placeholder indexes.\n         * @params {boolean} [isCurried] Specify composing for a curried function.\n         * @returns {Array} Returns the new array of composed arguments.\n         */\n        function composeArgs(args, partials, holders, isCurried) {\n            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;\n            while (++leftIndex < leftLength) {\n                result[leftIndex] = partials[leftIndex];\n            }\n            while (++argsIndex < holdersLength) {\n                if (isUncurried || argsIndex < argsLength) {\n                    result[holders[argsIndex]] = args[argsIndex];\n                }\n            }\n            while (rangeLength--) {\n                result[leftIndex++] = args[argsIndex++];\n            }\n            return result;\n        }\n        /**\n         * This function is like `composeArgs` except that the arguments composition\n         * is tailored for `_.partialRight`.\n         *\n         * @private\n         * @param {Array} args The provided arguments.\n         * @param {Array} partials The arguments to append to those provided.\n         * @param {Array} holders The `partials` placeholder indexes.\n         * @params {boolean} [isCurried] Specify composing for a curried function.\n         * @returns {Array} Returns the new array of composed arguments.\n         */\n        function composeArgsRight(args, partials, holders, isCurried) {\n            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;\n            while (++argsIndex < rangeLength) {\n                result[argsIndex] = args[argsIndex];\n            }\n            var offset = argsIndex;\n            while (++rightIndex < rightLength) {\n                result[offset + rightIndex] = partials[rightIndex];\n            }\n            while (++holdersIndex < holdersLength) {\n                if (isUncurried || argsIndex < argsLength) {\n                    result[offset + holders[holdersIndex]] = args[argsIndex++];\n                }\n            }\n            return result;\n        }\n        /**\n         * Copies the values of `source` to `array`.\n         *\n         * @private\n         * @param {Array} source The array to copy values from.\n         * @param {Array} [array=[]] The array to copy values to.\n         * @returns {Array} Returns `array`.\n         */\n        function copyArray(source, array) {\n            var index = -1, length = source.length;\n            array || (array = Array(length));\n            while (++index < length) {\n                array[index] = source[index];\n            }\n            return array;\n        }\n        /**\n         * Copies properties of `source` to `object`.\n         *\n         * @private\n         * @param {Object} source The object to copy properties from.\n         * @param {Array} props The property identifiers to copy.\n         * @param {Object} [object={}] The object to copy properties to.\n         * @param {Function} [customizer] The function to customize copied values.\n         * @returns {Object} Returns `object`.\n         */\n        function copyObject(source, props, object, customizer) {\n            var isNew = !object;\n            object || (object = {});\n            var index = -1, length = props.length;\n            while (++index < length) {\n                var key = props[index];\n                var newValue = customizer\n                    ? customizer(object[key], source[key], key, object, source)\n                    : undefined;\n                if (newValue === undefined) {\n                    newValue = source[key];\n                }\n                if (isNew) {\n                    baseAssignValue(object, key, newValue);\n                }\n                else {\n                    assignValue(object, key, newValue);\n                }\n            }\n            return object;\n        }\n        /**\n         * Copies own symbols of `source` to `object`.\n         *\n         * @private\n         * @param {Object} source The object to copy symbols from.\n         * @param {Object} [object={}] The object to copy symbols to.\n         * @returns {Object} Returns `object`.\n         */\n        function copySymbols(source, object) {\n            return copyObject(source, getSymbols(source), object);\n        }\n        /**\n         * Copies own and inherited symbols of `source` to `object`.\n         *\n         * @private\n         * @param {Object} source The object to copy symbols from.\n         * @param {Object} [object={}] The object to copy symbols to.\n         * @returns {Object} Returns `object`.\n         */\n        function copySymbolsIn(source, object) {\n            return copyObject(source, getSymbolsIn(source), object);\n        }\n        /**\n         * Creates a function like `_.groupBy`.\n         *\n         * @private\n         * @param {Function} setter The function to set accumulator values.\n         * @param {Function} [initializer] The accumulator object initializer.\n         * @returns {Function} Returns the new aggregator function.\n         */\n        function createAggregator(setter, initializer) {\n            return function (collection, iteratee) {\n                var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};\n                return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n            };\n        }\n        /**\n         * Creates a function like `_.assign`.\n         *\n         * @private\n         * @param {Function} assigner The function to assign values.\n         * @returns {Function} Returns the new assigner function.\n         */\n        function createAssigner(assigner) {\n            return baseRest(function (object, sources) {\n                var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;\n                customizer = (assigner.length > 3 && typeof customizer == 'function')\n                    ? (length--, customizer)\n                    : undefined;\n                if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                    customizer = length < 3 ? undefined : customizer;\n                    length = 1;\n                }\n                object = Object(object);\n                while (++index < length) {\n                    var source = sources[index];\n                    if (source) {\n                        assigner(object, source, index, customizer);\n                    }\n                }\n                return object;\n            });\n        }\n        /**\n         * Creates a `baseEach` or `baseEachRight` function.\n         *\n         * @private\n         * @param {Function} eachFunc The function to iterate over a collection.\n         * @param {boolean} [fromRight] Specify iterating from right to left.\n         * @returns {Function} Returns the new base function.\n         */\n        function createBaseEach(eachFunc, fromRight) {\n            return function (collection, iteratee) {\n                if (collection == null) {\n                    return collection;\n                }\n                if (!isArrayLike(collection)) {\n                    return eachFunc(collection, iteratee);\n                }\n                var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);\n                while ((fromRight ? index-- : ++index < length)) {\n                    if (iteratee(iterable[index], index, iterable) === false) {\n                        break;\n                    }\n                }\n                return collection;\n            };\n        }\n        /**\n         * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n         *\n         * @private\n         * @param {boolean} [fromRight] Specify iterating from right to left.\n         * @returns {Function} Returns the new base function.\n         */\n        function createBaseFor(fromRight) {\n            return function (object, iteratee, keysFunc) {\n                var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;\n                while (length--) {\n                    var key = props[fromRight ? length : ++index];\n                    if (iteratee(iterable[key], key, iterable) === false) {\n                        break;\n                    }\n                }\n                return object;\n            };\n        }\n        /**\n         * Creates a function that wraps `func` to invoke it with the optional `this`\n         * binding of `thisArg`.\n         *\n         * @private\n         * @param {Function} func The function to wrap.\n         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n         * @param {*} [thisArg] The `this` binding of `func`.\n         * @returns {Function} Returns the new wrapped function.\n         */\n        function createBind(func, bitmask, thisArg) {\n            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n            function wrapper() {\n                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n                return fn.apply(isBind ? thisArg : this, arguments);\n            }\n            return wrapper;\n        }\n        /**\n         * Creates a function like `_.lowerFirst`.\n         *\n         * @private\n         * @param {string} methodName The name of the `String` case method to use.\n         * @returns {Function} Returns the new case function.\n         */\n        function createCaseFirst(methodName) {\n            return function (string) {\n                string = toString(string);\n                var strSymbols = hasUnicode(string)\n                    ? stringToArray(string)\n                    : undefined;\n                var chr = strSymbols\n                    ? strSymbols[0]\n                    : string.charAt(0);\n                var trailing = strSymbols\n                    ? castSlice(strSymbols, 1).join('')\n                    : string.slice(1);\n                return chr[methodName]() + trailing;\n            };\n        }\n        /**\n         * Creates a function like `_.camelCase`.\n         *\n         * @private\n         * @param {Function} callback The function to combine each word.\n         * @returns {Function} Returns the new compounder function.\n         */\n        function createCompounder(callback) {\n            return function (string) {\n                return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n            };\n        }\n        /**\n         * Creates a function that produces an instance of `Ctor` regardless of\n         * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n         *\n         * @private\n         * @param {Function} Ctor The constructor to wrap.\n         * @returns {Function} Returns the new wrapped function.\n         */\n        function createCtor(Ctor) {\n            return function () {\n                // Use a `switch` statement to work with class constructors. See\n                // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n                // for more details.\n                var args = arguments;\n                switch (args.length) {\n                    case 0: return new Ctor;\n                    case 1: return new Ctor(args[0]);\n                    case 2: return new Ctor(args[0], args[1]);\n                    case 3: return new Ctor(args[0], args[1], args[2]);\n                    case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n                    case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n                    case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n                    case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n                }\n                var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);\n                // Mimic the constructor's `return` behavior.\n                // See https://es5.github.io/#x13.2.2 for more details.\n                return isObject(result) ? result : thisBinding;\n            };\n        }\n        /**\n         * Creates a function that wraps `func` to enable currying.\n         *\n         * @private\n         * @param {Function} func The function to wrap.\n         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n         * @param {number} arity The arity of `func`.\n         * @returns {Function} Returns the new wrapped function.\n         */\n        function createCurry(func, bitmask, arity) {\n            var Ctor = createCtor(func);\n            function wrapper() {\n                var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);\n                while (index--) {\n                    args[index] = arguments[index];\n                }\n                var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n                    ? []\n                    : replaceHolders(args, placeholder);\n                length -= holders.length;\n                if (length < arity) {\n                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);\n                }\n                var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n                return apply(fn, this, args);\n            }\n            return wrapper;\n        }\n        /**\n         * Creates a `_.find` or `_.findLast` function.\n         *\n         * @private\n         * @param {Function} findIndexFunc The function to find the collection index.\n         * @returns {Function} Returns the new find function.\n         */\n        function createFind(findIndexFunc) {\n            return function (collection, predicate, fromIndex) {\n                var iterable = Object(collection);\n                if (!isArrayLike(collection)) {\n                    var iteratee = getIteratee(predicate, 3);\n                    collection = keys(collection);\n                    predicate = function (key) { return iteratee(iterable[key], key, iterable); };\n                }\n                var index = findIndexFunc(collection, predicate, fromIndex);\n                return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n            };\n        }\n        /**\n         * Creates a `_.flow` or `_.flowRight` function.\n         *\n         * @private\n         * @param {boolean} [fromRight] Specify iterating from right to left.\n         * @returns {Function} Returns the new flow function.\n         */\n        function createFlow(fromRight) {\n            return flatRest(function (funcs) {\n                var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;\n                if (fromRight) {\n                    funcs.reverse();\n                }\n                while (index--) {\n                    var func = funcs[index];\n                    if (typeof func != 'function') {\n                        throw new TypeError(FUNC_ERROR_TEXT);\n                    }\n                    if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n                        var wrapper = new LodashWrapper([], true);\n                    }\n                }\n                index = wrapper ? index : length;\n                while (++index < length) {\n                    func = funcs[index];\n                    var funcName = getFuncName(func), data = funcName == 'wrapper' ? getData(func) : undefined;\n                    if (data && isLaziable(data[0]) &&\n                        data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                        !data[4].length && data[9] == 1) {\n                        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n                    }\n                    else {\n                        wrapper = (func.length == 1 && isLaziable(func))\n                            ? wrapper[funcName]()\n                            : wrapper.thru(func);\n                    }\n                }\n                return function () {\n                    var args = arguments, value = args[0];\n                    if (wrapper && args.length == 1 &&\n                        isArray(value) && value.length >= LARGE_ARRAY_SIZE) {\n                        return wrapper.plant(value).value();\n                    }\n                    var index = 0, result = length ? funcs[index].apply(this, args) : value;\n                    while (++index < length) {\n                        result = funcs[index].call(this, result);\n                    }\n                    return result;\n                };\n            });\n        }\n        /**\n         * Creates a function that wraps `func` to invoke it with optional `this`\n         * binding of `thisArg`, partial application, and currying.\n         *\n         * @private\n         * @param {Function|string} func The function or method name to wrap.\n         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n         * @param {*} [thisArg] The `this` binding of `func`.\n         * @param {Array} [partials] The arguments to prepend to those provided to\n         *  the new function.\n         * @param {Array} [holders] The `partials` placeholder indexes.\n         * @param {Array} [partialsRight] The arguments to append to those provided\n         *  to the new function.\n         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n         * @param {Array} [argPos] The argument positions of the new function.\n         * @param {number} [ary] The arity cap of `func`.\n         * @param {number} [arity] The arity of `func`.\n         * @returns {Function} Returns the new wrapped function.\n         */\n        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);\n            function wrapper() {\n                var length = arguments.length, args = Array(length), index = length;\n                while (index--) {\n                    args[index] = arguments[index];\n                }\n                if (isCurried) {\n                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);\n                }\n                if (partials) {\n                    args = composeArgs(args, partials, holders, isCurried);\n                }\n                if (partialsRight) {\n                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n                }\n                length -= holdersCount;\n                if (isCurried && length < arity) {\n                    var newHolders = replaceHolders(args, placeholder);\n                    return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);\n                }\n                var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;\n                length = args.length;\n                if (argPos) {\n                    args = reorder(args, argPos);\n                }\n                else if (isFlip && length > 1) {\n                    args.reverse();\n                }\n                if (isAry && ary < length) {\n                    args.length = ary;\n                }\n                if (this && this !== root && this instanceof wrapper) {\n                    fn = Ctor || createCtor(fn);\n                }\n                return fn.apply(thisBinding, args);\n            }\n            return wrapper;\n        }\n        /**\n         * Creates a function like `_.invertBy`.\n         *\n         * @private\n         * @param {Function} setter The function to set accumulator values.\n         * @param {Function} toIteratee The function to resolve iteratees.\n         * @returns {Function} Returns the new inverter function.\n         */\n        function createInverter(setter, toIteratee) {\n            return function (object, iteratee) {\n                return baseInverter(object, setter, toIteratee(iteratee), {});\n            };\n        }\n        /**\n         * Creates a function that performs a mathematical operation on two values.\n         *\n         * @private\n         * @param {Function} operator The function to perform the operation.\n         * @param {number} [defaultValue] The value used for `undefined` arguments.\n         * @returns {Function} Returns the new mathematical operation function.\n         */\n        function createMathOperation(operator, defaultValue) {\n            return function (value, other) {\n                var result;\n                if (value === undefined && other === undefined) {\n                    return defaultValue;\n                }\n                if (value !== undefined) {\n                    result = value;\n                }\n                if (other !== undefined) {\n                    if (result === undefined) {\n                        return other;\n                    }\n                    if (typeof value == 'string' || typeof other == 'string') {\n                        value = baseToString(value);\n                        other = baseToString(other);\n                    }\n                    else {\n                        value = baseToNumber(value);\n                        other = baseToNumber(other);\n                    }\n                    result = operator(value, other);\n                }\n                return result;\n            };\n        }\n        /**\n         * Creates a function like `_.over`.\n         *\n         * @private\n         * @param {Function} arrayFunc The function to iterate over iteratees.\n         * @returns {Function} Returns the new over function.\n         */\n        function createOver(arrayFunc) {\n            return flatRest(function (iteratees) {\n                iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n                return baseRest(function (args) {\n                    var thisArg = this;\n                    return arrayFunc(iteratees, function (iteratee) {\n                        return apply(iteratee, thisArg, args);\n                    });\n                });\n            });\n        }\n        /**\n         * Creates the padding for `string` based on `length`. The `chars` string\n         * is truncated if the number of characters exceeds `length`.\n         *\n         * @private\n         * @param {number} length The padding length.\n         * @param {string} [chars=' '] The string used as padding.\n         * @returns {string} Returns the padding for `string`.\n         */\n        function createPadding(length, chars) {\n            chars = chars === undefined ? ' ' : baseToString(chars);\n            var charsLength = chars.length;\n            if (charsLength < 2) {\n                return charsLength ? baseRepeat(chars, length) : chars;\n            }\n            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n            return hasUnicode(chars)\n                ? castSlice(stringToArray(result), 0, length).join('')\n                : result.slice(0, length);\n        }\n        /**\n         * Creates a function that wraps `func` to invoke it with the `this` binding\n         * of `thisArg` and `partials` prepended to the arguments it receives.\n         *\n         * @private\n         * @param {Function} func The function to wrap.\n         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n         * @param {*} thisArg The `this` binding of `func`.\n         * @param {Array} partials The arguments to prepend to those provided to\n         *  the new function.\n         * @returns {Function} Returns the new wrapped function.\n         */\n        function createPartial(func, bitmask, thisArg, partials) {\n            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n            function wrapper() {\n                var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n                while (++leftIndex < leftLength) {\n                    args[leftIndex] = partials[leftIndex];\n                }\n                while (argsLength--) {\n                    args[leftIndex++] = arguments[++argsIndex];\n                }\n                return apply(fn, isBind ? thisArg : this, args);\n            }\n            return wrapper;\n        }\n        /**\n         * Creates a `_.range` or `_.rangeRight` function.\n         *\n         * @private\n         * @param {boolean} [fromRight] Specify iterating from right to left.\n         * @returns {Function} Returns the new range function.\n         */\n        function createRange(fromRight) {\n            return function (start, end, step) {\n                if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n                    end = step = undefined;\n                }\n                // Ensure the sign of `-0` is preserved.\n                start = toFinite(start);\n                if (end === undefined) {\n                    end = start;\n                    start = 0;\n                }\n                else {\n                    end = toFinite(end);\n                }\n                step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n                return baseRange(start, end, step, fromRight);\n            };\n        }\n        /**\n         * Creates a function that performs a relational operation on two values.\n         *\n         * @private\n         * @param {Function} operator The function to perform the operation.\n         * @returns {Function} Returns the new relational operation function.\n         */\n        function createRelationalOperation(operator) {\n            return function (value, other) {\n                if (!(typeof value == 'string' && typeof other == 'string')) {\n                    value = toNumber(value);\n                    other = toNumber(other);\n                }\n                return operator(value, other);\n            };\n        }\n        /**\n         * Creates a function that wraps `func` to continue currying.\n         *\n         * @private\n         * @param {Function} func The function to wrap.\n         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n         * @param {Function} wrapFunc The function to create the `func` wrapper.\n         * @param {*} placeholder The placeholder value.\n         * @param {*} [thisArg] The `this` binding of `func`.\n         * @param {Array} [partials] The arguments to prepend to those provided to\n         *  the new function.\n         * @param {Array} [holders] The `partials` placeholder indexes.\n         * @param {Array} [argPos] The argument positions of the new function.\n         * @param {number} [ary] The arity cap of `func`.\n         * @param {number} [arity] The arity of `func`.\n         * @returns {Function} Returns the new wrapped function.\n         */\n        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;\n            bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n                bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n            }\n            var newData = [\n                func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n                newHoldersRight, argPos, ary, arity\n            ];\n            var result = wrapFunc.apply(undefined, newData);\n            if (isLaziable(func)) {\n                setData(result, newData);\n            }\n            result.placeholder = placeholder;\n            return setWrapToString(result, func, bitmask);\n        }\n        /**\n         * Creates a function like `_.round`.\n         *\n         * @private\n         * @param {string} methodName The name of the `Math` method to use when rounding.\n         * @returns {Function} Returns the new round function.\n         */\n        function createRound(methodName) {\n            var func = Math[methodName];\n            return function (number, precision) {\n                number = toNumber(number);\n                precision = nativeMin(toInteger(precision), 292);\n                if (precision) {\n                    // Shift with exponential notation to avoid floating-point issues.\n                    // See [MDN](https://mdn.io/round#Examples) for more details.\n                    var pair = (toString(number) + 'e').split('e'), value = func(pair[0] + 'e' + (+pair[1] + precision));\n                    pair = (toString(value) + 'e').split('e');\n                    return +(pair[0] + 'e' + (+pair[1] - precision));\n                }\n                return func(number);\n            };\n        }\n        /**\n         * Creates a set object of `values`.\n         *\n         * @private\n         * @param {Array} values The values to add to the set.\n         * @returns {Object} Returns the new set.\n         */\n        var createSet = !(Set && (1 / setToArray(new Set([, -0]))[1]) == INFINITY) ? noop : function (values) {\n            return new Set(values);\n        };\n        /**\n         * Creates a `_.toPairs` or `_.toPairsIn` function.\n         *\n         * @private\n         * @param {Function} keysFunc The function to get the keys of a given object.\n         * @returns {Function} Returns the new pairs function.\n         */\n        function createToPairs(keysFunc) {\n            return function (object) {\n                var tag = getTag(object);\n                if (tag == mapTag) {\n                    return mapToArray(object);\n                }\n                if (tag == setTag) {\n                    return setToPairs(object);\n                }\n                return baseToPairs(object, keysFunc(object));\n            };\n        }\n        /**\n         * Creates a function that either curries or invokes `func` with optional\n         * `this` binding and partially applied arguments.\n         *\n         * @private\n         * @param {Function|string} func The function or method name to wrap.\n         * @param {number} bitmask The bitmask flags.\n         *    1 - `_.bind`\n         *    2 - `_.bindKey`\n         *    4 - `_.curry` or `_.curryRight` of a bound function\n         *    8 - `_.curry`\n         *   16 - `_.curryRight`\n         *   32 - `_.partial`\n         *   64 - `_.partialRight`\n         *  128 - `_.rearg`\n         *  256 - `_.ary`\n         *  512 - `_.flip`\n         * @param {*} [thisArg] The `this` binding of `func`.\n         * @param {Array} [partials] The arguments to be partially applied.\n         * @param {Array} [holders] The `partials` placeholder indexes.\n         * @param {Array} [argPos] The argument positions of the new function.\n         * @param {number} [ary] The arity cap of `func`.\n         * @param {number} [arity] The arity of `func`.\n         * @returns {Function} Returns the new wrapped function.\n         */\n        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n            if (!isBindKey && typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            var length = partials ? partials.length : 0;\n            if (!length) {\n                bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n                partials = holders = undefined;\n            }\n            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n            arity = arity === undefined ? arity : toInteger(arity);\n            length -= holders ? holders.length : 0;\n            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n                var partialsRight = partials, holdersRight = holders;\n                partials = holders = undefined;\n            }\n            var data = isBindKey ? undefined : getData(func);\n            var newData = [\n                func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n                argPos, ary, arity\n            ];\n            if (data) {\n                mergeData(newData, data);\n            }\n            func = newData[0];\n            bitmask = newData[1];\n            thisArg = newData[2];\n            partials = newData[3];\n            holders = newData[4];\n            arity = newData[9] = newData[9] == null\n                ? (isBindKey ? 0 : func.length)\n                : nativeMax(newData[9] - length, 0);\n            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n                bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n            }\n            if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n                var result = createBind(func, bitmask, thisArg);\n            }\n            else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n                result = createCurry(func, bitmask, arity);\n            }\n            else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n                result = createPartial(func, bitmask, thisArg, partials);\n            }\n            else {\n                result = createHybrid.apply(undefined, newData);\n            }\n            var setter = data ? baseSetData : setData;\n            return setWrapToString(setter(result, newData), func, bitmask);\n        }\n        /**\n         * A specialized version of `baseIsEqualDeep` for arrays with support for\n         * partial deep comparisons.\n         *\n         * @private\n         * @param {Array} array The array to compare.\n         * @param {Array} other The other array to compare.\n         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n         * @param {Function} customizer The function to customize comparisons.\n         * @param {Function} equalFunc The function to determine equivalents of values.\n         * @param {Object} stack Tracks traversed `array` and `other` objects.\n         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n         */\n        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;\n            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n                return false;\n            }\n            // Assume cyclic values are equal.\n            var stacked = stack.get(array);\n            if (stacked && stack.get(other)) {\n                return stacked == other;\n            }\n            var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n            stack.set(array, other);\n            stack.set(other, array);\n            // Ignore non-index properties.\n            while (++index < arrLength) {\n                var arrValue = array[index], othValue = other[index];\n                if (customizer) {\n                    var compared = isPartial\n                        ? customizer(othValue, arrValue, index, other, array, stack)\n                        : customizer(arrValue, othValue, index, array, other, stack);\n                }\n                if (compared !== undefined) {\n                    if (compared) {\n                        continue;\n                    }\n                    result = false;\n                    break;\n                }\n                // Recursively compare arrays (susceptible to call stack limits).\n                if (seen) {\n                    if (!arraySome(other, function (othValue, othIndex) {\n                        if (!cacheHas(seen, othIndex) &&\n                            (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                            return seen.push(othIndex);\n                        }\n                    })) {\n                        result = false;\n                        break;\n                    }\n                }\n                else if (!(arrValue === othValue ||\n                    equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                    result = false;\n                    break;\n                }\n            }\n            stack['delete'](array);\n            stack['delete'](other);\n            return result;\n        }\n        /**\n         * A specialized version of `baseIsEqualDeep` for comparing objects of\n         * the same `toStringTag`.\n         *\n         * **Note:** This function only supports comparing values with tags of\n         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n         *\n         * @private\n         * @param {Object} object The object to compare.\n         * @param {Object} other The other object to compare.\n         * @param {string} tag The `toStringTag` of the objects to compare.\n         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n         * @param {Function} customizer The function to customize comparisons.\n         * @param {Function} equalFunc The function to determine equivalents of values.\n         * @param {Object} stack Tracks traversed `object` and `other` objects.\n         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n         */\n        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n            switch (tag) {\n                case dataViewTag:\n                    if ((object.byteLength != other.byteLength) ||\n                        (object.byteOffset != other.byteOffset)) {\n                        return false;\n                    }\n                    object = object.buffer;\n                    other = other.buffer;\n                case arrayBufferTag:\n                    if ((object.byteLength != other.byteLength) ||\n                        !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n                        return false;\n                    }\n                    return true;\n                case boolTag:\n                case dateTag:\n                case numberTag:\n                    // Coerce booleans to `1` or `0` and dates to milliseconds.\n                    // Invalid dates are coerced to `NaN`.\n                    return eq(+object, +other);\n                case errorTag:\n                    return object.name == other.name && object.message == other.message;\n                case regexpTag:\n                case stringTag:\n                    // Coerce regexes to strings and treat strings, primitives and objects,\n                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n                    // for more details.\n                    return object == (other + '');\n                case mapTag:\n                    var convert = mapToArray;\n                case setTag:\n                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n                    convert || (convert = setToArray);\n                    if (object.size != other.size && !isPartial) {\n                        return false;\n                    }\n                    // Assume cyclic values are equal.\n                    var stacked = stack.get(object);\n                    if (stacked) {\n                        return stacked == other;\n                    }\n                    bitmask |= COMPARE_UNORDERED_FLAG;\n                    // Recursively compare objects (susceptible to call stack limits).\n                    stack.set(object, other);\n                    var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n                    stack['delete'](object);\n                    return result;\n                case symbolTag:\n                    if (symbolValueOf) {\n                        return symbolValueOf.call(object) == symbolValueOf.call(other);\n                    }\n            }\n            return false;\n        }\n        /**\n         * A specialized version of `baseIsEqualDeep` for objects with support for\n         * partial deep comparisons.\n         *\n         * @private\n         * @param {Object} object The object to compare.\n         * @param {Object} other The other object to compare.\n         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n         * @param {Function} customizer The function to customize comparisons.\n         * @param {Function} equalFunc The function to determine equivalents of values.\n         * @param {Object} stack Tracks traversed `object` and `other` objects.\n         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n         */\n        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;\n            if (objLength != othLength && !isPartial) {\n                return false;\n            }\n            var index = objLength;\n            while (index--) {\n                var key = objProps[index];\n                if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n                    return false;\n                }\n            }\n            // Assume cyclic values are equal.\n            var stacked = stack.get(object);\n            if (stacked && stack.get(other)) {\n                return stacked == other;\n            }\n            var result = true;\n            stack.set(object, other);\n            stack.set(other, object);\n            var skipCtor = isPartial;\n            while (++index < objLength) {\n                key = objProps[index];\n                var objValue = object[key], othValue = other[key];\n                if (customizer) {\n                    var compared = isPartial\n                        ? customizer(othValue, objValue, key, other, object, stack)\n                        : customizer(objValue, othValue, key, object, other, stack);\n                }\n                // Recursively compare objects (susceptible to call stack limits).\n                if (!(compared === undefined\n                    ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n                    : compared)) {\n                    result = false;\n                    break;\n                }\n                skipCtor || (skipCtor = key == 'constructor');\n            }\n            if (result && !skipCtor) {\n                var objCtor = object.constructor, othCtor = other.constructor;\n                // Non `Object` object instances with different constructors are not equal.\n                if (objCtor != othCtor &&\n                    ('constructor' in object && 'constructor' in other) &&\n                    !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n                        typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n                    result = false;\n                }\n            }\n            stack['delete'](object);\n            stack['delete'](other);\n            return result;\n        }\n        /**\n         * A specialized version of `baseRest` which flattens the rest array.\n         *\n         * @private\n         * @param {Function} func The function to apply a rest parameter to.\n         * @returns {Function} Returns the new function.\n         */\n        function flatRest(func) {\n            return setToString(overRest(func, undefined, flatten), func + '');\n        }\n        /**\n         * Creates an array of own enumerable property names and symbols of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property names and symbols.\n         */\n        function getAllKeys(object) {\n            return baseGetAllKeys(object, keys, getSymbols);\n        }\n        /**\n         * Creates an array of own and inherited enumerable property names and\n         * symbols of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property names and symbols.\n         */\n        function getAllKeysIn(object) {\n            return baseGetAllKeys(object, keysIn, getSymbolsIn);\n        }\n        /**\n         * Gets metadata for `func`.\n         *\n         * @private\n         * @param {Function} func The function to query.\n         * @returns {*} Returns the metadata for `func`.\n         */\n        var getData = !metaMap ? noop : function (func) {\n            return metaMap.get(func);\n        };\n        /**\n         * Gets the name of `func`.\n         *\n         * @private\n         * @param {Function} func The function to query.\n         * @returns {string} Returns the function name.\n         */\n        function getFuncName(func) {\n            var result = (func.name + ''), array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n            while (length--) {\n                var data = array[length], otherFunc = data.func;\n                if (otherFunc == null || otherFunc == func) {\n                    return data.name;\n                }\n            }\n            return result;\n        }\n        /**\n         * Gets the argument placeholder value for `func`.\n         *\n         * @private\n         * @param {Function} func The function to inspect.\n         * @returns {*} Returns the placeholder value.\n         */\n        function getHolder(func) {\n            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n            return object.placeholder;\n        }\n        /**\n         * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n         * this function returns the custom method, otherwise it returns `baseIteratee`.\n         * If arguments are provided, the chosen function is invoked with them and\n         * its result is returned.\n         *\n         * @private\n         * @param {*} [value] The value to convert to an iteratee.\n         * @param {number} [arity] The arity of the created iteratee.\n         * @returns {Function} Returns the chosen function or its result.\n         */\n        function getIteratee() {\n            var result = lodash.iteratee || iteratee;\n            result = result === iteratee ? baseIteratee : result;\n            return arguments.length ? result(arguments[0], arguments[1]) : result;\n        }\n        /**\n         * Gets the data for `map`.\n         *\n         * @private\n         * @param {Object} map The map to query.\n         * @param {string} key The reference key.\n         * @returns {*} Returns the map data.\n         */\n        function getMapData(map, key) {\n            var data = map.__data__;\n            return isKeyable(key)\n                ? data[typeof key == 'string' ? 'string' : 'hash']\n                : data.map;\n        }\n        /**\n         * Gets the property names, values, and compare flags of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the match data of `object`.\n         */\n        function getMatchData(object) {\n            var result = keys(object), length = result.length;\n            while (length--) {\n                var key = result[length], value = object[key];\n                result[length] = [key, value, isStrictComparable(value)];\n            }\n            return result;\n        }\n        /**\n         * Gets the native function at `key` of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @param {string} key The key of the method to get.\n         * @returns {*} Returns the function if it's native, else `undefined`.\n         */\n        function getNative(object, key) {\n            var value = getValue(object, key);\n            return baseIsNative(value) ? value : undefined;\n        }\n        /**\n         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n         *\n         * @private\n         * @param {*} value The value to query.\n         * @returns {string} Returns the raw `toStringTag`.\n         */\n        function getRawTag(value) {\n            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n            try {\n                value[symToStringTag] = undefined;\n                var unmasked = true;\n            }\n            catch (e) { }\n            var result = nativeObjectToString.call(value);\n            if (unmasked) {\n                if (isOwn) {\n                    value[symToStringTag] = tag;\n                }\n                else {\n                    delete value[symToStringTag];\n                }\n            }\n            return result;\n        }\n        /**\n         * Creates an array of the own enumerable symbols of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of symbols.\n         */\n        var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;\n        /**\n         * Creates an array of the own and inherited enumerable symbols of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of symbols.\n         */\n        var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {\n            var result = [];\n            while (object) {\n                arrayPush(result, getSymbols(object));\n                object = getPrototype(object);\n            }\n            return result;\n        };\n        /**\n         * Gets the `toStringTag` of `value`.\n         *\n         * @private\n         * @param {*} value The value to query.\n         * @returns {string} Returns the `toStringTag`.\n         */\n        var getTag = baseGetTag;\n        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n            (Map && getTag(new Map) != mapTag) ||\n            (Promise && getTag(Promise.resolve()) != promiseTag) ||\n            (Set && getTag(new Set) != setTag) ||\n            (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n            getTag = function (value) {\n                var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';\n                if (ctorString) {\n                    switch (ctorString) {\n                        case dataViewCtorString: return dataViewTag;\n                        case mapCtorString: return mapTag;\n                        case promiseCtorString: return promiseTag;\n                        case setCtorString: return setTag;\n                        case weakMapCtorString: return weakMapTag;\n                    }\n                }\n                return result;\n            };\n        }\n        /**\n         * Gets the view, applying any `transforms` to the `start` and `end` positions.\n         *\n         * @private\n         * @param {number} start The start of the view.\n         * @param {number} end The end of the view.\n         * @param {Array} transforms The transformations to apply to the view.\n         * @returns {Object} Returns an object containing the `start` and `end`\n         *  positions of the view.\n         */\n        function getView(start, end, transforms) {\n            var index = -1, length = transforms.length;\n            while (++index < length) {\n                var data = transforms[index], size = data.size;\n                switch (data.type) {\n                    case 'drop':\n                        start += size;\n                        break;\n                    case 'dropRight':\n                        end -= size;\n                        break;\n                    case 'take':\n                        end = nativeMin(end, start + size);\n                        break;\n                    case 'takeRight':\n                        start = nativeMax(start, end - size);\n                        break;\n                }\n            }\n            return { 'start': start, 'end': end };\n        }\n        /**\n         * Extracts wrapper details from the `source` body comment.\n         *\n         * @private\n         * @param {string} source The source to inspect.\n         * @returns {Array} Returns the wrapper details.\n         */\n        function getWrapDetails(source) {\n            var match = source.match(reWrapDetails);\n            return match ? match[1].split(reSplitDetails) : [];\n        }\n        /**\n         * Checks if `path` exists on `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path to check.\n         * @param {Function} hasFunc The function to check properties.\n         * @returns {boolean} Returns `true` if `path` exists, else `false`.\n         */\n        function hasPath(object, path, hasFunc) {\n            path = castPath(path, object);\n            var index = -1, length = path.length, result = false;\n            while (++index < length) {\n                var key = toKey(path[index]);\n                if (!(result = object != null && hasFunc(object, key))) {\n                    break;\n                }\n                object = object[key];\n            }\n            if (result || ++index != length) {\n                return result;\n            }\n            length = object == null ? 0 : object.length;\n            return !!length && isLength(length) && isIndex(key, length) &&\n                (isArray(object) || isArguments(object));\n        }\n        /**\n         * Initializes an array clone.\n         *\n         * @private\n         * @param {Array} array The array to clone.\n         * @returns {Array} Returns the initialized clone.\n         */\n        function initCloneArray(array) {\n            var length = array.length, result = array.constructor(length);\n            // Add properties assigned by `RegExp#exec`.\n            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n                result.index = array.index;\n                result.input = array.input;\n            }\n            return result;\n        }\n        /**\n         * Initializes an object clone.\n         *\n         * @private\n         * @param {Object} object The object to clone.\n         * @returns {Object} Returns the initialized clone.\n         */\n        function initCloneObject(object) {\n            return (typeof object.constructor == 'function' && !isPrototype(object))\n                ? baseCreate(getPrototype(object))\n                : {};\n        }\n        /**\n         * Initializes an object clone based on its `toStringTag`.\n         *\n         * **Note:** This function only supports cloning values with tags of\n         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n         *\n         * @private\n         * @param {Object} object The object to clone.\n         * @param {string} tag The `toStringTag` of the object to clone.\n         * @param {Function} cloneFunc The function to clone values.\n         * @param {boolean} [isDeep] Specify a deep clone.\n         * @returns {Object} Returns the initialized clone.\n         */\n        function initCloneByTag(object, tag, cloneFunc, isDeep) {\n            var Ctor = object.constructor;\n            switch (tag) {\n                case arrayBufferTag:\n                    return cloneArrayBuffer(object);\n                case boolTag:\n                case dateTag:\n                    return new Ctor(+object);\n                case dataViewTag:\n                    return cloneDataView(object, isDeep);\n                case float32Tag:\n                case float64Tag:\n                case int8Tag:\n                case int16Tag:\n                case int32Tag:\n                case uint8Tag:\n                case uint8ClampedTag:\n                case uint16Tag:\n                case uint32Tag:\n                    return cloneTypedArray(object, isDeep);\n                case mapTag:\n                    return cloneMap(object, isDeep, cloneFunc);\n                case numberTag:\n                case stringTag:\n                    return new Ctor(object);\n                case regexpTag:\n                    return cloneRegExp(object);\n                case setTag:\n                    return cloneSet(object, isDeep, cloneFunc);\n                case symbolTag:\n                    return cloneSymbol(object);\n            }\n        }\n        /**\n         * Inserts wrapper `details` in a comment at the top of the `source` body.\n         *\n         * @private\n         * @param {string} source The source to modify.\n         * @returns {Array} details The details to insert.\n         * @returns {string} Returns the modified source.\n         */\n        function insertWrapDetails(source, details) {\n            var length = details.length;\n            if (!length) {\n                return source;\n            }\n            var lastIndex = length - 1;\n            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n            details = details.join(length > 2 ? ', ' : ' ');\n            return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n        }\n        /**\n         * Checks if `value` is a flattenable `arguments` object or array.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n         */\n        function isFlattenable(value) {\n            return isArray(value) || isArguments(value) ||\n                !!(spreadableSymbol && value && value[spreadableSymbol]);\n        }\n        /**\n         * Checks if `value` is a valid array-like index.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n         */\n        function isIndex(value, length) {\n            length = length == null ? MAX_SAFE_INTEGER : length;\n            return !!length &&\n                (typeof value == 'number' || reIsUint.test(value)) &&\n                (value > -1 && value % 1 == 0 && value < length);\n        }\n        /**\n         * Checks if the given arguments are from an iteratee call.\n         *\n         * @private\n         * @param {*} value The potential iteratee value argument.\n         * @param {*} index The potential iteratee index or key argument.\n         * @param {*} object The potential iteratee object argument.\n         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n         *  else `false`.\n         */\n        function isIterateeCall(value, index, object) {\n            if (!isObject(object)) {\n                return false;\n            }\n            var type = typeof index;\n            if (type == 'number'\n                ? (isArrayLike(object) && isIndex(index, object.length))\n                : (type == 'string' && index in object)) {\n                return eq(object[index], value);\n            }\n            return false;\n        }\n        /**\n         * Checks if `value` is a property name and not a property path.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @param {Object} [object] The object to query keys on.\n         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n         */\n        function isKey(value, object) {\n            if (isArray(value)) {\n                return false;\n            }\n            var type = typeof value;\n            if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n                value == null || isSymbol(value)) {\n                return true;\n            }\n            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n                (object != null && value in Object(object));\n        }\n        /**\n         * Checks if `value` is suitable for use as unique object key.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n         */\n        function isKeyable(value) {\n            var type = typeof value;\n            return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n                ? (value !== '__proto__')\n                : (value === null);\n        }\n        /**\n         * Checks if `func` has a lazy counterpart.\n         *\n         * @private\n         * @param {Function} func The function to check.\n         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n         *  else `false`.\n         */\n        function isLaziable(func) {\n            var funcName = getFuncName(func), other = lodash[funcName];\n            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n                return false;\n            }\n            if (func === other) {\n                return true;\n            }\n            var data = getData(other);\n            return !!data && func === data[0];\n        }\n        /**\n         * Checks if `func` has its source masked.\n         *\n         * @private\n         * @param {Function} func The function to check.\n         * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n         */\n        function isMasked(func) {\n            return !!maskSrcKey && (maskSrcKey in func);\n        }\n        /**\n         * Checks if `func` is capable of being masked.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n         */\n        var isMaskable = coreJsData ? isFunction : stubFalse;\n        /**\n         * Checks if `value` is likely a prototype object.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n         */\n        function isPrototype(value) {\n            var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n            return value === proto;\n        }\n        /**\n         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n         *\n         * @private\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` if suitable for strict\n         *  equality comparisons, else `false`.\n         */\n        function isStrictComparable(value) {\n            return value === value && !isObject(value);\n        }\n        /**\n         * A specialized version of `matchesProperty` for source values suitable\n         * for strict equality comparisons, i.e. `===`.\n         *\n         * @private\n         * @param {string} key The key of the property to get.\n         * @param {*} srcValue The value to match.\n         * @returns {Function} Returns the new spec function.\n         */\n        function matchesStrictComparable(key, srcValue) {\n            return function (object) {\n                if (object == null) {\n                    return false;\n                }\n                return object[key] === srcValue &&\n                    (srcValue !== undefined || (key in Object(object)));\n            };\n        }\n        /**\n         * A specialized version of `_.memoize` which clears the memoized function's\n         * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n         *\n         * @private\n         * @param {Function} func The function to have its output memoized.\n         * @returns {Function} Returns the new memoized function.\n         */\n        function memoizeCapped(func) {\n            var result = memoize(func, function (key) {\n                if (cache.size === MAX_MEMOIZE_SIZE) {\n                    cache.clear();\n                }\n                return key;\n            });\n            var cache = result.cache;\n            return result;\n        }\n        /**\n         * Merges the function metadata of `source` into `data`.\n         *\n         * Merging metadata reduces the number of wrappers used to invoke a function.\n         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n         * may be applied regardless of execution order. Methods like `_.ary` and\n         * `_.rearg` modify function arguments, making the order in which they are\n         * executed important, preventing the merging of metadata. However, we make\n         * an exception for a safe combined case where curried functions have `_.ary`\n         * and or `_.rearg` applied.\n         *\n         * @private\n         * @param {Array} data The destination metadata.\n         * @param {Array} source The source metadata.\n         * @returns {Array} Returns `data`.\n         */\n        function mergeData(data, source) {\n            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n            var isCombo = ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n                ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n                ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n            // Exit early if metadata can't be merged.\n            if (!(isCommon || isCombo)) {\n                return data;\n            }\n            // Use source `thisArg` if available.\n            if (srcBitmask & WRAP_BIND_FLAG) {\n                data[2] = source[2];\n                // Set when currying a bound function.\n                newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n            }\n            // Compose partial arguments.\n            var value = source[3];\n            if (value) {\n                var partials = data[3];\n                data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n                data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n            }\n            // Compose partial right arguments.\n            value = source[5];\n            if (value) {\n                partials = data[5];\n                data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n                data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n            }\n            // Use source `argPos` if available.\n            value = source[7];\n            if (value) {\n                data[7] = value;\n            }\n            // Use source `ary` if it's smaller.\n            if (srcBitmask & WRAP_ARY_FLAG) {\n                data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n            }\n            // Use source `arity` if one is not provided.\n            if (data[9] == null) {\n                data[9] = source[9];\n            }\n            // Use source `func` and merge bitmasks.\n            data[0] = source[0];\n            data[1] = newBitmask;\n            return data;\n        }\n        /**\n         * Used by `_.defaultsDeep` to customize its `_.merge` use.\n         *\n         * @private\n         * @param {*} objValue The destination value.\n         * @param {*} srcValue The source value.\n         * @param {string} key The key of the property to merge.\n         * @param {Object} object The parent object of `objValue`.\n         * @param {Object} source The parent object of `srcValue`.\n         * @param {Object} [stack] Tracks traversed source values and their merged\n         *  counterparts.\n         * @returns {*} Returns the value to assign.\n         */\n        function mergeDefaults(objValue, srcValue, key, object, source, stack) {\n            if (isObject(objValue) && isObject(srcValue)) {\n                // Recursively merge objects and arrays (susceptible to call stack limits).\n                stack.set(srcValue, objValue);\n                baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);\n                stack['delete'](srcValue);\n            }\n            return objValue;\n        }\n        /**\n         * This function is like\n         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n         * except that it includes inherited enumerable properties.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property names.\n         */\n        function nativeKeysIn(object) {\n            var result = [];\n            if (object != null) {\n                for (var key in Object(object)) {\n                    result.push(key);\n                }\n            }\n            return result;\n        }\n        /**\n         * Converts `value` to a string using `Object.prototype.toString`.\n         *\n         * @private\n         * @param {*} value The value to convert.\n         * @returns {string} Returns the converted string.\n         */\n        function objectToString(value) {\n            return nativeObjectToString.call(value);\n        }\n        /**\n         * A specialized version of `baseRest` which transforms the rest array.\n         *\n         * @private\n         * @param {Function} func The function to apply a rest parameter to.\n         * @param {number} [start=func.length-1] The start position of the rest parameter.\n         * @param {Function} transform The rest array transform.\n         * @returns {Function} Returns the new function.\n         */\n        function overRest(func, start, transform) {\n            start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n            return function () {\n                var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);\n                while (++index < length) {\n                    array[index] = args[start + index];\n                }\n                index = -1;\n                var otherArgs = Array(start + 1);\n                while (++index < start) {\n                    otherArgs[index] = args[index];\n                }\n                otherArgs[start] = transform(array);\n                return apply(func, this, otherArgs);\n            };\n        }\n        /**\n         * Gets the parent value at `path` of `object`.\n         *\n         * @private\n         * @param {Object} object The object to query.\n         * @param {Array} path The path to get the parent value of.\n         * @returns {*} Returns the parent value.\n         */\n        function parent(object, path) {\n            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n        }\n        /**\n         * Reorder `array` according to the specified indexes where the element at\n         * the first index is assigned as the first element, the element at\n         * the second index is assigned as the second element, and so on.\n         *\n         * @private\n         * @param {Array} array The array to reorder.\n         * @param {Array} indexes The arranged array indexes.\n         * @returns {Array} Returns `array`.\n         */\n        function reorder(array, indexes) {\n            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);\n            while (length--) {\n                var index = indexes[length];\n                array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n            }\n            return array;\n        }\n        /**\n         * Sets metadata for `func`.\n         *\n         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n         * period of time, it will trip its breaker and transition to an identity\n         * function to avoid garbage collection pauses in V8. See\n         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n         * for more details.\n         *\n         * @private\n         * @param {Function} func The function to associate metadata with.\n         * @param {*} data The metadata.\n         * @returns {Function} Returns `func`.\n         */\n        var setData = shortOut(baseSetData);\n        /**\n         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n         *\n         * @private\n         * @param {Function} func The function to delay.\n         * @param {number} wait The number of milliseconds to delay invocation.\n         * @returns {number|Object} Returns the timer id or timeout object.\n         */\n        var setTimeout = ctxSetTimeout || function (func, wait) {\n            return root.setTimeout(func, wait);\n        };\n        /**\n         * Sets the `toString` method of `func` to return `string`.\n         *\n         * @private\n         * @param {Function} func The function to modify.\n         * @param {Function} string The `toString` result.\n         * @returns {Function} Returns `func`.\n         */\n        var setToString = shortOut(baseSetToString);\n        /**\n         * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n         * with wrapper details in a comment at the top of the source body.\n         *\n         * @private\n         * @param {Function} wrapper The function to modify.\n         * @param {Function} reference The reference function.\n         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n         * @returns {Function} Returns `wrapper`.\n         */\n        function setWrapToString(wrapper, reference, bitmask) {\n            var source = (reference + '');\n            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n        }\n        /**\n         * Creates a function that'll short out and invoke `identity` instead\n         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n         * milliseconds.\n         *\n         * @private\n         * @param {Function} func The function to restrict.\n         * @returns {Function} Returns the new shortable function.\n         */\n        function shortOut(func) {\n            var count = 0, lastCalled = 0;\n            return function () {\n                var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n                lastCalled = stamp;\n                if (remaining > 0) {\n                    if (++count >= HOT_COUNT) {\n                        return arguments[0];\n                    }\n                }\n                else {\n                    count = 0;\n                }\n                return func.apply(undefined, arguments);\n            };\n        }\n        /**\n         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n         *\n         * @private\n         * @param {Array} array The array to shuffle.\n         * @param {number} [size=array.length] The size of `array`.\n         * @returns {Array} Returns `array`.\n         */\n        function shuffleSelf(array, size) {\n            var index = -1, length = array.length, lastIndex = length - 1;\n            size = size === undefined ? length : size;\n            while (++index < size) {\n                var rand = baseRandom(index, lastIndex), value = array[rand];\n                array[rand] = array[index];\n                array[index] = value;\n            }\n            array.length = size;\n            return array;\n        }\n        /**\n         * Converts `string` to a property path array.\n         *\n         * @private\n         * @param {string} string The string to convert.\n         * @returns {Array} Returns the property path array.\n         */\n        var stringToPath = memoizeCapped(function (string) {\n            var result = [];\n            if (reLeadingDot.test(string)) {\n                result.push('');\n            }\n            string.replace(rePropName, function (match, number, quote, string) {\n                result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n            });\n            return result;\n        });\n        /**\n         * Converts `value` to a string key if it's not a string or symbol.\n         *\n         * @private\n         * @param {*} value The value to inspect.\n         * @returns {string|symbol} Returns the key.\n         */\n        function toKey(value) {\n            if (typeof value == 'string' || isSymbol(value)) {\n                return value;\n            }\n            var result = (value + '');\n            return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n        }\n        /**\n         * Converts `func` to its source code.\n         *\n         * @private\n         * @param {Function} func The function to convert.\n         * @returns {string} Returns the source code.\n         */\n        function toSource(func) {\n            if (func != null) {\n                try {\n                    return funcToString.call(func);\n                }\n                catch (e) { }\n                try {\n                    return (func + '');\n                }\n                catch (e) { }\n            }\n            return '';\n        }\n        /**\n         * Updates wrapper `details` based on `bitmask` flags.\n         *\n         * @private\n         * @returns {Array} details The details to modify.\n         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n         * @returns {Array} Returns `details`.\n         */\n        function updateWrapDetails(details, bitmask) {\n            arrayEach(wrapFlags, function (pair) {\n                var value = '_.' + pair[0];\n                if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n                    details.push(value);\n                }\n            });\n            return details.sort();\n        }\n        /**\n         * Creates a clone of `wrapper`.\n         *\n         * @private\n         * @param {Object} wrapper The wrapper to clone.\n         * @returns {Object} Returns the cloned wrapper.\n         */\n        function wrapperClone(wrapper) {\n            if (wrapper instanceof LazyWrapper) {\n                return wrapper.clone();\n            }\n            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n            result.__actions__ = copyArray(wrapper.__actions__);\n            result.__index__ = wrapper.__index__;\n            result.__values__ = wrapper.__values__;\n            return result;\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates an array of elements split into groups the length of `size`.\n         * If `array` can't be split evenly, the final chunk will be the remaining\n         * elements.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to process.\n         * @param {number} [size=1] The length of each chunk\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Array} Returns the new array of chunks.\n         * @example\n         *\n         * _.chunk(['a', 'b', 'c', 'd'], 2);\n         * // => [['a', 'b'], ['c', 'd']]\n         *\n         * _.chunk(['a', 'b', 'c', 'd'], 3);\n         * // => [['a', 'b', 'c'], ['d']]\n         */\n        function chunk(array, size, guard) {\n            if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n                size = 1;\n            }\n            else {\n                size = nativeMax(toInteger(size), 0);\n            }\n            var length = array == null ? 0 : array.length;\n            if (!length || size < 1) {\n                return [];\n            }\n            var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));\n            while (index < length) {\n                result[resIndex++] = baseSlice(array, index, (index += size));\n            }\n            return result;\n        }\n        /**\n         * Creates an array with all falsey values removed. The values `false`, `null`,\n         * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to compact.\n         * @returns {Array} Returns the new array of filtered values.\n         * @example\n         *\n         * _.compact([0, 1, false, 2, '', 3]);\n         * // => [1, 2, 3]\n         */\n        function compact(array) {\n            var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n            while (++index < length) {\n                var value = array[index];\n                if (value) {\n                    result[resIndex++] = value;\n                }\n            }\n            return result;\n        }\n        /**\n         * Creates a new array concatenating `array` with any additional arrays\n         * and/or values.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to concatenate.\n         * @param {...*} [values] The values to concatenate.\n         * @returns {Array} Returns the new concatenated array.\n         * @example\n         *\n         * var array = [1];\n         * var other = _.concat(array, 2, [3], [[4]]);\n         *\n         * console.log(other);\n         * // => [1, 2, 3, [4]]\n         *\n         * console.log(array);\n         * // => [1]\n         */\n        function concat() {\n            var length = arguments.length;\n            if (!length) {\n                return [];\n            }\n            var args = Array(length - 1), array = arguments[0], index = length;\n            while (index--) {\n                args[index - 1] = arguments[index];\n            }\n            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n        }\n        /**\n         * Creates an array of `array` values not included in the other given arrays\n         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons. The order and references of result values are\n         * determined by the first array.\n         *\n         * **Note:** Unlike `_.pullAll`, this method returns a new array.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {...Array} [values] The values to exclude.\n         * @returns {Array} Returns the new array of filtered values.\n         * @see _.without, _.xor\n         * @example\n         *\n         * _.difference([2, 1], [2, 3]);\n         * // => [1]\n         */\n        var difference = baseRest(function (array, values) {\n            return isArrayLikeObject(array)\n                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n                : [];\n        });\n        /**\n         * This method is like `_.difference` except that it accepts `iteratee` which\n         * is invoked for each element of `array` and `values` to generate the criterion\n         * by which they're compared. The order and references of result values are\n         * determined by the first array. The iteratee is invoked with one argument:\n         * (value).\n         *\n         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {...Array} [values] The values to exclude.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {Array} Returns the new array of filtered values.\n         * @example\n         *\n         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n         * // => [1.2]\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n         * // => [{ 'x': 2 }]\n         */\n        var differenceBy = baseRest(function (array, values) {\n            var iteratee = last(values);\n            if (isArrayLikeObject(iteratee)) {\n                iteratee = undefined;\n            }\n            return isArrayLikeObject(array)\n                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n                : [];\n        });\n        /**\n         * This method is like `_.difference` except that it accepts `comparator`\n         * which is invoked to compare elements of `array` to `values`. The order and\n         * references of result values are determined by the first array. The comparator\n         * is invoked with two arguments: (arrVal, othVal).\n         *\n         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {...Array} [values] The values to exclude.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new array of filtered values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         *\n         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n         * // => [{ 'x': 2, 'y': 1 }]\n         */\n        var differenceWith = baseRest(function (array, values) {\n            var comparator = last(values);\n            if (isArrayLikeObject(comparator)) {\n                comparator = undefined;\n            }\n            return isArrayLikeObject(array)\n                ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n                : [];\n        });\n        /**\n         * Creates a slice of `array` with `n` elements dropped from the beginning.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.5.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {number} [n=1] The number of elements to drop.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * _.drop([1, 2, 3]);\n         * // => [2, 3]\n         *\n         * _.drop([1, 2, 3], 2);\n         * // => [3]\n         *\n         * _.drop([1, 2, 3], 5);\n         * // => []\n         *\n         * _.drop([1, 2, 3], 0);\n         * // => [1, 2, 3]\n         */\n        function drop(array, n, guard) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return [];\n            }\n            n = (guard || n === undefined) ? 1 : toInteger(n);\n            return baseSlice(array, n < 0 ? 0 : n, length);\n        }\n        /**\n         * Creates a slice of `array` with `n` elements dropped from the end.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {number} [n=1] The number of elements to drop.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * _.dropRight([1, 2, 3]);\n         * // => [1, 2]\n         *\n         * _.dropRight([1, 2, 3], 2);\n         * // => [1]\n         *\n         * _.dropRight([1, 2, 3], 5);\n         * // => []\n         *\n         * _.dropRight([1, 2, 3], 0);\n         * // => [1, 2, 3]\n         */\n        function dropRight(array, n, guard) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return [];\n            }\n            n = (guard || n === undefined) ? 1 : toInteger(n);\n            n = length - n;\n            return baseSlice(array, 0, n < 0 ? 0 : n);\n        }\n        /**\n         * Creates a slice of `array` excluding elements dropped from the end.\n         * Elements are dropped until `predicate` returns falsey. The predicate is\n         * invoked with three arguments: (value, index, array).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'active': true },\n         *   { 'user': 'fred',    'active': false },\n         *   { 'user': 'pebbles', 'active': false }\n         * ];\n         *\n         * _.dropRightWhile(users, function(o) { return !o.active; });\n         * // => objects for ['barney']\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n         * // => objects for ['barney', 'fred']\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.dropRightWhile(users, ['active', false]);\n         * // => objects for ['barney']\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.dropRightWhile(users, 'active');\n         * // => objects for ['barney', 'fred', 'pebbles']\n         */\n        function dropRightWhile(array, predicate) {\n            return (array && array.length)\n                ? baseWhile(array, getIteratee(predicate, 3), true, true)\n                : [];\n        }\n        /**\n         * Creates a slice of `array` excluding elements dropped from the beginning.\n         * Elements are dropped until `predicate` returns falsey. The predicate is\n         * invoked with three arguments: (value, index, array).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'active': false },\n         *   { 'user': 'fred',    'active': false },\n         *   { 'user': 'pebbles', 'active': true }\n         * ];\n         *\n         * _.dropWhile(users, function(o) { return !o.active; });\n         * // => objects for ['pebbles']\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.dropWhile(users, { 'user': 'barney', 'active': false });\n         * // => objects for ['fred', 'pebbles']\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.dropWhile(users, ['active', false]);\n         * // => objects for ['pebbles']\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.dropWhile(users, 'active');\n         * // => objects for ['barney', 'fred', 'pebbles']\n         */\n        function dropWhile(array, predicate) {\n            return (array && array.length)\n                ? baseWhile(array, getIteratee(predicate, 3), true)\n                : [];\n        }\n        /**\n         * Fills elements of `array` with `value` from `start` up to, but not\n         * including, `end`.\n         *\n         * **Note:** This method mutates `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.2.0\n         * @category Array\n         * @param {Array} array The array to fill.\n         * @param {*} value The value to fill `array` with.\n         * @param {number} [start=0] The start position.\n         * @param {number} [end=array.length] The end position.\n         * @returns {Array} Returns `array`.\n         * @example\n         *\n         * var array = [1, 2, 3];\n         *\n         * _.fill(array, 'a');\n         * console.log(array);\n         * // => ['a', 'a', 'a']\n         *\n         * _.fill(Array(3), 2);\n         * // => [2, 2, 2]\n         *\n         * _.fill([4, 6, 8, 10], '*', 1, 3);\n         * // => [4, '*', '*', 10]\n         */\n        function fill(array, value, start, end) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return [];\n            }\n            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n                start = 0;\n                end = length;\n            }\n            return baseFill(array, value, start, end);\n        }\n        /**\n         * This method is like `_.find` except that it returns the index of the first\n         * element `predicate` returns truthy for instead of the element itself.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.1.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @param {number} [fromIndex=0] The index to search from.\n         * @returns {number} Returns the index of the found element, else `-1`.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'active': false },\n         *   { 'user': 'fred',    'active': false },\n         *   { 'user': 'pebbles', 'active': true }\n         * ];\n         *\n         * _.findIndex(users, function(o) { return o.user == 'barney'; });\n         * // => 0\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.findIndex(users, { 'user': 'fred', 'active': false });\n         * // => 1\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.findIndex(users, ['active', false]);\n         * // => 0\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.findIndex(users, 'active');\n         * // => 2\n         */\n        function findIndex(array, predicate, fromIndex) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return -1;\n            }\n            var index = fromIndex == null ? 0 : toInteger(fromIndex);\n            if (index < 0) {\n                index = nativeMax(length + index, 0);\n            }\n            return baseFindIndex(array, getIteratee(predicate, 3), index);\n        }\n        /**\n         * This method is like `_.findIndex` except that it iterates over elements\n         * of `collection` from right to left.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @param {number} [fromIndex=array.length-1] The index to search from.\n         * @returns {number} Returns the index of the found element, else `-1`.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'active': true },\n         *   { 'user': 'fred',    'active': false },\n         *   { 'user': 'pebbles', 'active': false }\n         * ];\n         *\n         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n         * // => 2\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n         * // => 0\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.findLastIndex(users, ['active', false]);\n         * // => 2\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.findLastIndex(users, 'active');\n         * // => 0\n         */\n        function findLastIndex(array, predicate, fromIndex) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return -1;\n            }\n            var index = length - 1;\n            if (fromIndex !== undefined) {\n                index = toInteger(fromIndex);\n                index = fromIndex < 0\n                    ? nativeMax(length + index, 0)\n                    : nativeMin(index, length - 1);\n            }\n            return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n        }\n        /**\n         * Flattens `array` a single level deep.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to flatten.\n         * @returns {Array} Returns the new flattened array.\n         * @example\n         *\n         * _.flatten([1, [2, [3, [4]], 5]]);\n         * // => [1, 2, [3, [4]], 5]\n         */\n        function flatten(array) {\n            var length = array == null ? 0 : array.length;\n            return length ? baseFlatten(array, 1) : [];\n        }\n        /**\n         * Recursively flattens `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to flatten.\n         * @returns {Array} Returns the new flattened array.\n         * @example\n         *\n         * _.flattenDeep([1, [2, [3, [4]], 5]]);\n         * // => [1, 2, 3, 4, 5]\n         */\n        function flattenDeep(array) {\n            var length = array == null ? 0 : array.length;\n            return length ? baseFlatten(array, INFINITY) : [];\n        }\n        /**\n         * Recursively flatten `array` up to `depth` times.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.4.0\n         * @category Array\n         * @param {Array} array The array to flatten.\n         * @param {number} [depth=1] The maximum recursion depth.\n         * @returns {Array} Returns the new flattened array.\n         * @example\n         *\n         * var array = [1, [2, [3, [4]], 5]];\n         *\n         * _.flattenDepth(array, 1);\n         * // => [1, 2, [3, [4]], 5]\n         *\n         * _.flattenDepth(array, 2);\n         * // => [1, 2, 3, [4], 5]\n         */\n        function flattenDepth(array, depth) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return [];\n            }\n            depth = depth === undefined ? 1 : toInteger(depth);\n            return baseFlatten(array, depth);\n        }\n        /**\n         * The inverse of `_.toPairs`; this method returns an object composed\n         * from key-value `pairs`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} pairs The key-value pairs.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * _.fromPairs([['a', 1], ['b', 2]]);\n         * // => { 'a': 1, 'b': 2 }\n         */\n        function fromPairs(pairs) {\n            var index = -1, length = pairs == null ? 0 : pairs.length, result = {};\n            while (++index < length) {\n                var pair = pairs[index];\n                result[pair[0]] = pair[1];\n            }\n            return result;\n        }\n        /**\n         * Gets the first element of `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @alias first\n         * @category Array\n         * @param {Array} array The array to query.\n         * @returns {*} Returns the first element of `array`.\n         * @example\n         *\n         * _.head([1, 2, 3]);\n         * // => 1\n         *\n         * _.head([]);\n         * // => undefined\n         */\n        function head(array) {\n            return (array && array.length) ? array[0] : undefined;\n        }\n        /**\n         * Gets the index at which the first occurrence of `value` is found in `array`\n         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons. If `fromIndex` is negative, it's used as the\n         * offset from the end of `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {*} value The value to search for.\n         * @param {number} [fromIndex=0] The index to search from.\n         * @returns {number} Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.indexOf([1, 2, 1, 2], 2);\n         * // => 1\n         *\n         * // Search from the `fromIndex`.\n         * _.indexOf([1, 2, 1, 2], 2, 2);\n         * // => 3\n         */\n        function indexOf(array, value, fromIndex) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return -1;\n            }\n            var index = fromIndex == null ? 0 : toInteger(fromIndex);\n            if (index < 0) {\n                index = nativeMax(length + index, 0);\n            }\n            return baseIndexOf(array, value, index);\n        }\n        /**\n         * Gets all but the last element of `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * _.initial([1, 2, 3]);\n         * // => [1, 2]\n         */\n        function initial(array) {\n            var length = array == null ? 0 : array.length;\n            return length ? baseSlice(array, 0, -1) : [];\n        }\n        /**\n         * Creates an array of unique values that are included in all given arrays\n         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons. The order and references of result values are\n         * determined by the first array.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @returns {Array} Returns the new array of intersecting values.\n         * @example\n         *\n         * _.intersection([2, 1], [2, 3]);\n         * // => [2]\n         */\n        var intersection = baseRest(function (arrays) {\n            var mapped = arrayMap(arrays, castArrayLikeObject);\n            return (mapped.length && mapped[0] === arrays[0])\n                ? baseIntersection(mapped)\n                : [];\n        });\n        /**\n         * This method is like `_.intersection` except that it accepts `iteratee`\n         * which is invoked for each element of each `arrays` to generate the criterion\n         * by which they're compared. The order and references of result values are\n         * determined by the first array. The iteratee is invoked with one argument:\n         * (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {Array} Returns the new array of intersecting values.\n         * @example\n         *\n         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n         * // => [2.1]\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 1 }]\n         */\n        var intersectionBy = baseRest(function (arrays) {\n            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n            if (iteratee === last(mapped)) {\n                iteratee = undefined;\n            }\n            else {\n                mapped.pop();\n            }\n            return (mapped.length && mapped[0] === arrays[0])\n                ? baseIntersection(mapped, getIteratee(iteratee, 2))\n                : [];\n        });\n        /**\n         * This method is like `_.intersection` except that it accepts `comparator`\n         * which is invoked to compare elements of `arrays`. The order and references\n         * of result values are determined by the first array. The comparator is\n         * invoked with two arguments: (arrVal, othVal).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new array of intersecting values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.intersectionWith(objects, others, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }]\n         */\n        var intersectionWith = baseRest(function (arrays) {\n            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n            comparator = typeof comparator == 'function' ? comparator : undefined;\n            if (comparator) {\n                mapped.pop();\n            }\n            return (mapped.length && mapped[0] === arrays[0])\n                ? baseIntersection(mapped, undefined, comparator)\n                : [];\n        });\n        /**\n         * Converts all elements in `array` into a string separated by `separator`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to convert.\n         * @param {string} [separator=','] The element separator.\n         * @returns {string} Returns the joined string.\n         * @example\n         *\n         * _.join(['a', 'b', 'c'], '~');\n         * // => 'a~b~c'\n         */\n        function join(array, separator) {\n            return array == null ? '' : nativeJoin.call(array, separator);\n        }\n        /**\n         * Gets the last element of `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @returns {*} Returns the last element of `array`.\n         * @example\n         *\n         * _.last([1, 2, 3]);\n         * // => 3\n         */\n        function last(array) {\n            var length = array == null ? 0 : array.length;\n            return length ? array[length - 1] : undefined;\n        }\n        /**\n         * This method is like `_.indexOf` except that it iterates over elements of\n         * `array` from right to left.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {*} value The value to search for.\n         * @param {number} [fromIndex=array.length-1] The index to search from.\n         * @returns {number} Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.lastIndexOf([1, 2, 1, 2], 2);\n         * // => 3\n         *\n         * // Search from the `fromIndex`.\n         * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n         * // => 1\n         */\n        function lastIndexOf(array, value, fromIndex) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return -1;\n            }\n            var index = length;\n            if (fromIndex !== undefined) {\n                index = toInteger(fromIndex);\n                index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n            }\n            return value === value\n                ? strictLastIndexOf(array, value, index)\n                : baseFindIndex(array, baseIsNaN, index, true);\n        }\n        /**\n         * Gets the element at index `n` of `array`. If `n` is negative, the nth\n         * element from the end is returned.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.11.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {number} [n=0] The index of the element to return.\n         * @returns {*} Returns the nth element of `array`.\n         * @example\n         *\n         * var array = ['a', 'b', 'c', 'd'];\n         *\n         * _.nth(array, 1);\n         * // => 'b'\n         *\n         * _.nth(array, -2);\n         * // => 'c';\n         */\n        function nth(array, n) {\n            return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n        }\n        /**\n         * Removes all given values from `array` using\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n         * to remove elements from an array by predicate.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Array\n         * @param {Array} array The array to modify.\n         * @param {...*} [values] The values to remove.\n         * @returns {Array} Returns `array`.\n         * @example\n         *\n         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n         *\n         * _.pull(array, 'a', 'c');\n         * console.log(array);\n         * // => ['b', 'b']\n         */\n        var pull = baseRest(pullAll);\n        /**\n         * This method is like `_.pull` except that it accepts an array of values to remove.\n         *\n         * **Note:** Unlike `_.difference`, this method mutates `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to modify.\n         * @param {Array} values The values to remove.\n         * @returns {Array} Returns `array`.\n         * @example\n         *\n         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n         *\n         * _.pullAll(array, ['a', 'c']);\n         * console.log(array);\n         * // => ['b', 'b']\n         */\n        function pullAll(array, values) {\n            return (array && array.length && values && values.length)\n                ? basePullAll(array, values)\n                : array;\n        }\n        /**\n         * This method is like `_.pullAll` except that it accepts `iteratee` which is\n         * invoked for each element of `array` and `values` to generate the criterion\n         * by which they're compared. The iteratee is invoked with one argument: (value).\n         *\n         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to modify.\n         * @param {Array} values The values to remove.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {Array} Returns `array`.\n         * @example\n         *\n         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n         *\n         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n         * console.log(array);\n         * // => [{ 'x': 2 }]\n         */\n        function pullAllBy(array, values, iteratee) {\n            return (array && array.length && values && values.length)\n                ? basePullAll(array, values, getIteratee(iteratee, 2))\n                : array;\n        }\n        /**\n         * This method is like `_.pullAll` except that it accepts `comparator` which\n         * is invoked to compare elements of `array` to `values`. The comparator is\n         * invoked with two arguments: (arrVal, othVal).\n         *\n         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.6.0\n         * @category Array\n         * @param {Array} array The array to modify.\n         * @param {Array} values The values to remove.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns `array`.\n         * @example\n         *\n         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n         *\n         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n         * console.log(array);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n         */\n        function pullAllWith(array, values, comparator) {\n            return (array && array.length && values && values.length)\n                ? basePullAll(array, values, undefined, comparator)\n                : array;\n        }\n        /**\n         * Removes elements from `array` corresponding to `indexes` and returns an\n         * array of removed elements.\n         *\n         * **Note:** Unlike `_.at`, this method mutates `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to modify.\n         * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n         * @returns {Array} Returns the new array of removed elements.\n         * @example\n         *\n         * var array = ['a', 'b', 'c', 'd'];\n         * var pulled = _.pullAt(array, [1, 3]);\n         *\n         * console.log(array);\n         * // => ['a', 'c']\n         *\n         * console.log(pulled);\n         * // => ['b', 'd']\n         */\n        var pullAt = flatRest(function (array, indexes) {\n            var length = array == null ? 0 : array.length, result = baseAt(array, indexes);\n            basePullAt(array, arrayMap(indexes, function (index) {\n                return isIndex(index, length) ? +index : index;\n            }).sort(compareAscending));\n            return result;\n        });\n        /**\n         * Removes all elements from `array` that `predicate` returns truthy for\n         * and returns an array of the removed elements. The predicate is invoked\n         * with three arguments: (value, index, array).\n         *\n         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n         * to pull elements from an array by value.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Array\n         * @param {Array} array The array to modify.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the new array of removed elements.\n         * @example\n         *\n         * var array = [1, 2, 3, 4];\n         * var evens = _.remove(array, function(n) {\n         *   return n % 2 == 0;\n         * });\n         *\n         * console.log(array);\n         * // => [1, 3]\n         *\n         * console.log(evens);\n         * // => [2, 4]\n         */\n        function remove(array, predicate) {\n            var result = [];\n            if (!(array && array.length)) {\n                return result;\n            }\n            var index = -1, indexes = [], length = array.length;\n            predicate = getIteratee(predicate, 3);\n            while (++index < length) {\n                var value = array[index];\n                if (predicate(value, index, array)) {\n                    result.push(value);\n                    indexes.push(index);\n                }\n            }\n            basePullAt(array, indexes);\n            return result;\n        }\n        /**\n         * Reverses `array` so that the first element becomes the last, the second\n         * element becomes the second to last, and so on.\n         *\n         * **Note:** This method mutates `array` and is based on\n         * [`Array#reverse`](https://mdn.io/Array/reverse).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to modify.\n         * @returns {Array} Returns `array`.\n         * @example\n         *\n         * var array = [1, 2, 3];\n         *\n         * _.reverse(array);\n         * // => [3, 2, 1]\n         *\n         * console.log(array);\n         * // => [3, 2, 1]\n         */\n        function reverse(array) {\n            return array == null ? array : nativeReverse.call(array);\n        }\n        /**\n         * Creates a slice of `array` from `start` up to, but not including, `end`.\n         *\n         * **Note:** This method is used instead of\n         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n         * returned.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to slice.\n         * @param {number} [start=0] The start position.\n         * @param {number} [end=array.length] The end position.\n         * @returns {Array} Returns the slice of `array`.\n         */\n        function slice(array, start, end) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return [];\n            }\n            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n                start = 0;\n                end = length;\n            }\n            else {\n                start = start == null ? 0 : toInteger(start);\n                end = end === undefined ? length : toInteger(end);\n            }\n            return baseSlice(array, start, end);\n        }\n        /**\n         * Uses a binary search to determine the lowest index at which `value`\n         * should be inserted into `array` in order to maintain its sort order.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The sorted array to inspect.\n         * @param {*} value The value to evaluate.\n         * @returns {number} Returns the index at which `value` should be inserted\n         *  into `array`.\n         * @example\n         *\n         * _.sortedIndex([30, 50], 40);\n         * // => 1\n         */\n        function sortedIndex(array, value) {\n            return baseSortedIndex(array, value);\n        }\n        /**\n         * This method is like `_.sortedIndex` except that it accepts `iteratee`\n         * which is invoked for `value` and each element of `array` to compute their\n         * sort ranking. The iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The sorted array to inspect.\n         * @param {*} value The value to evaluate.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {number} Returns the index at which `value` should be inserted\n         *  into `array`.\n         * @example\n         *\n         * var objects = [{ 'x': 4 }, { 'x': 5 }];\n         *\n         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n         * // => 0\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n         * // => 0\n         */\n        function sortedIndexBy(array, value, iteratee) {\n            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n        }\n        /**\n         * This method is like `_.indexOf` except that it performs a binary\n         * search on a sorted `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {*} value The value to search for.\n         * @returns {number} Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n         * // => 1\n         */\n        function sortedIndexOf(array, value) {\n            var length = array == null ? 0 : array.length;\n            if (length) {\n                var index = baseSortedIndex(array, value);\n                if (index < length && eq(array[index], value)) {\n                    return index;\n                }\n            }\n            return -1;\n        }\n        /**\n         * This method is like `_.sortedIndex` except that it returns the highest\n         * index at which `value` should be inserted into `array` in order to\n         * maintain its sort order.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The sorted array to inspect.\n         * @param {*} value The value to evaluate.\n         * @returns {number} Returns the index at which `value` should be inserted\n         *  into `array`.\n         * @example\n         *\n         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n         * // => 4\n         */\n        function sortedLastIndex(array, value) {\n            return baseSortedIndex(array, value, true);\n        }\n        /**\n         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n         * which is invoked for `value` and each element of `array` to compute their\n         * sort ranking. The iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The sorted array to inspect.\n         * @param {*} value The value to evaluate.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {number} Returns the index at which `value` should be inserted\n         *  into `array`.\n         * @example\n         *\n         * var objects = [{ 'x': 4 }, { 'x': 5 }];\n         *\n         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n         * // => 1\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n         * // => 1\n         */\n        function sortedLastIndexBy(array, value, iteratee) {\n            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n        }\n        /**\n         * This method is like `_.lastIndexOf` except that it performs a binary\n         * search on a sorted `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {*} value The value to search for.\n         * @returns {number} Returns the index of the matched value, else `-1`.\n         * @example\n         *\n         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n         * // => 3\n         */\n        function sortedLastIndexOf(array, value) {\n            var length = array == null ? 0 : array.length;\n            if (length) {\n                var index = baseSortedIndex(array, value, true) - 1;\n                if (eq(array[index], value)) {\n                    return index;\n                }\n            }\n            return -1;\n        }\n        /**\n         * This method is like `_.uniq` except that it's designed and optimized\n         * for sorted arrays.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @returns {Array} Returns the new duplicate free array.\n         * @example\n         *\n         * _.sortedUniq([1, 1, 2]);\n         * // => [1, 2]\n         */\n        function sortedUniq(array) {\n            return (array && array.length)\n                ? baseSortedUniq(array)\n                : [];\n        }\n        /**\n         * This method is like `_.uniqBy` except that it's designed and optimized\n         * for sorted arrays.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {Function} [iteratee] The iteratee invoked per element.\n         * @returns {Array} Returns the new duplicate free array.\n         * @example\n         *\n         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n         * // => [1.1, 2.3]\n         */\n        function sortedUniqBy(array, iteratee) {\n            return (array && array.length)\n                ? baseSortedUniq(array, getIteratee(iteratee, 2))\n                : [];\n        }\n        /**\n         * Gets all but the first element of `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * _.tail([1, 2, 3]);\n         * // => [2, 3]\n         */\n        function tail(array) {\n            var length = array == null ? 0 : array.length;\n            return length ? baseSlice(array, 1, length) : [];\n        }\n        /**\n         * Creates a slice of `array` with `n` elements taken from the beginning.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {number} [n=1] The number of elements to take.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * _.take([1, 2, 3]);\n         * // => [1]\n         *\n         * _.take([1, 2, 3], 2);\n         * // => [1, 2]\n         *\n         * _.take([1, 2, 3], 5);\n         * // => [1, 2, 3]\n         *\n         * _.take([1, 2, 3], 0);\n         * // => []\n         */\n        function take(array, n, guard) {\n            if (!(array && array.length)) {\n                return [];\n            }\n            n = (guard || n === undefined) ? 1 : toInteger(n);\n            return baseSlice(array, 0, n < 0 ? 0 : n);\n        }\n        /**\n         * Creates a slice of `array` with `n` elements taken from the end.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {number} [n=1] The number of elements to take.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * _.takeRight([1, 2, 3]);\n         * // => [3]\n         *\n         * _.takeRight([1, 2, 3], 2);\n         * // => [2, 3]\n         *\n         * _.takeRight([1, 2, 3], 5);\n         * // => [1, 2, 3]\n         *\n         * _.takeRight([1, 2, 3], 0);\n         * // => []\n         */\n        function takeRight(array, n, guard) {\n            var length = array == null ? 0 : array.length;\n            if (!length) {\n                return [];\n            }\n            n = (guard || n === undefined) ? 1 : toInteger(n);\n            n = length - n;\n            return baseSlice(array, n < 0 ? 0 : n, length);\n        }\n        /**\n         * Creates a slice of `array` with elements taken from the end. Elements are\n         * taken until `predicate` returns falsey. The predicate is invoked with\n         * three arguments: (value, index, array).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'active': true },\n         *   { 'user': 'fred',    'active': false },\n         *   { 'user': 'pebbles', 'active': false }\n         * ];\n         *\n         * _.takeRightWhile(users, function(o) { return !o.active; });\n         * // => objects for ['fred', 'pebbles']\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n         * // => objects for ['pebbles']\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.takeRightWhile(users, ['active', false]);\n         * // => objects for ['fred', 'pebbles']\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.takeRightWhile(users, 'active');\n         * // => []\n         */\n        function takeRightWhile(array, predicate) {\n            return (array && array.length)\n                ? baseWhile(array, getIteratee(predicate, 3), false, true)\n                : [];\n        }\n        /**\n         * Creates a slice of `array` with elements taken from the beginning. Elements\n         * are taken until `predicate` returns falsey. The predicate is invoked with\n         * three arguments: (value, index, array).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Array\n         * @param {Array} array The array to query.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the slice of `array`.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'active': false },\n         *   { 'user': 'fred',    'active': false},\n         *   { 'user': 'pebbles', 'active': true }\n         * ];\n         *\n         * _.takeWhile(users, function(o) { return !o.active; });\n         * // => objects for ['barney', 'fred']\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.takeWhile(users, { 'user': 'barney', 'active': false });\n         * // => objects for ['barney']\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.takeWhile(users, ['active', false]);\n         * // => objects for ['barney', 'fred']\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.takeWhile(users, 'active');\n         * // => []\n         */\n        function takeWhile(array, predicate) {\n            return (array && array.length)\n                ? baseWhile(array, getIteratee(predicate, 3))\n                : [];\n        }\n        /**\n         * Creates an array of unique values, in order, from all given arrays using\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @returns {Array} Returns the new array of combined values.\n         * @example\n         *\n         * _.union([2], [1, 2]);\n         * // => [2, 1]\n         */\n        var union = baseRest(function (arrays) {\n            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n        });\n        /**\n         * This method is like `_.union` except that it accepts `iteratee` which is\n         * invoked for each element of each `arrays` to generate the criterion by\n         * which uniqueness is computed. Result values are chosen from the first\n         * array in which the value occurs. The iteratee is invoked with one argument:\n         * (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {Array} Returns the new array of combined values.\n         * @example\n         *\n         * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n         * // => [2.1, 1.2]\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 1 }, { 'x': 2 }]\n         */\n        var unionBy = baseRest(function (arrays) {\n            var iteratee = last(arrays);\n            if (isArrayLikeObject(iteratee)) {\n                iteratee = undefined;\n            }\n            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n        });\n        /**\n         * This method is like `_.union` except that it accepts `comparator` which\n         * is invoked to compare elements of `arrays`. Result values are chosen from\n         * the first array in which the value occurs. The comparator is invoked\n         * with two arguments: (arrVal, othVal).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new array of combined values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.unionWith(objects, others, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n         */\n        var unionWith = baseRest(function (arrays) {\n            var comparator = last(arrays);\n            comparator = typeof comparator == 'function' ? comparator : undefined;\n            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n        });\n        /**\n         * Creates a duplicate-free version of an array, using\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons, in which only the first occurrence of each element\n         * is kept. The order of result values is determined by the order they occur\n         * in the array.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @returns {Array} Returns the new duplicate free array.\n         * @example\n         *\n         * _.uniq([2, 1, 2]);\n         * // => [2, 1]\n         */\n        function uniq(array) {\n            return (array && array.length) ? baseUniq(array) : [];\n        }\n        /**\n         * This method is like `_.uniq` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * uniqueness is computed. The order of result values is determined by the\n         * order they occur in the array. The iteratee is invoked with one argument:\n         * (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {Array} Returns the new duplicate free array.\n         * @example\n         *\n         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n         * // => [2.1, 1.2]\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 1 }, { 'x': 2 }]\n         */\n        function uniqBy(array, iteratee) {\n            return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n        }\n        /**\n         * This method is like `_.uniq` except that it accepts `comparator` which\n         * is invoked to compare elements of `array`. The order of result values is\n         * determined by the order they occur in the array.The comparator is invoked\n         * with two arguments: (arrVal, othVal).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new duplicate free array.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.uniqWith(objects, _.isEqual);\n         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n         */\n        function uniqWith(array, comparator) {\n            comparator = typeof comparator == 'function' ? comparator : undefined;\n            return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n        }\n        /**\n         * This method is like `_.zip` except that it accepts an array of grouped\n         * elements and creates an array regrouping the elements to their pre-zip\n         * configuration.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.2.0\n         * @category Array\n         * @param {Array} array The array of grouped elements to process.\n         * @returns {Array} Returns the new array of regrouped elements.\n         * @example\n         *\n         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n         * // => [['a', 1, true], ['b', 2, false]]\n         *\n         * _.unzip(zipped);\n         * // => [['a', 'b'], [1, 2], [true, false]]\n         */\n        function unzip(array) {\n            if (!(array && array.length)) {\n                return [];\n            }\n            var length = 0;\n            array = arrayFilter(array, function (group) {\n                if (isArrayLikeObject(group)) {\n                    length = nativeMax(group.length, length);\n                    return true;\n                }\n            });\n            return baseTimes(length, function (index) {\n                return arrayMap(array, baseProperty(index));\n            });\n        }\n        /**\n         * This method is like `_.unzip` except that it accepts `iteratee` to specify\n         * how regrouped values should be combined. The iteratee is invoked with the\n         * elements of each group: (...group).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.8.0\n         * @category Array\n         * @param {Array} array The array of grouped elements to process.\n         * @param {Function} [iteratee=_.identity] The function to combine\n         *  regrouped values.\n         * @returns {Array} Returns the new array of regrouped elements.\n         * @example\n         *\n         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n         * // => [[1, 10, 100], [2, 20, 200]]\n         *\n         * _.unzipWith(zipped, _.add);\n         * // => [3, 30, 300]\n         */\n        function unzipWith(array, iteratee) {\n            if (!(array && array.length)) {\n                return [];\n            }\n            var result = unzip(array);\n            if (iteratee == null) {\n                return result;\n            }\n            return arrayMap(result, function (group) {\n                return apply(iteratee, undefined, group);\n            });\n        }\n        /**\n         * Creates an array excluding all given values using\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * for equality comparisons.\n         *\n         * **Note:** Unlike `_.pull`, this method returns a new array.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {Array} array The array to inspect.\n         * @param {...*} [values] The values to exclude.\n         * @returns {Array} Returns the new array of filtered values.\n         * @see _.difference, _.xor\n         * @example\n         *\n         * _.without([2, 1, 2, 3], 1, 2);\n         * // => [3]\n         */\n        var without = baseRest(function (array, values) {\n            return isArrayLikeObject(array)\n                ? baseDifference(array, values)\n                : [];\n        });\n        /**\n         * Creates an array of unique values that is the\n         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n         * of the given arrays. The order of result values is determined by the order\n         * they occur in the arrays.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.4.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @returns {Array} Returns the new array of filtered values.\n         * @see _.difference, _.without\n         * @example\n         *\n         * _.xor([2, 1], [2, 3]);\n         * // => [1, 3]\n         */\n        var xor = baseRest(function (arrays) {\n            return baseXor(arrayFilter(arrays, isArrayLikeObject));\n        });\n        /**\n         * This method is like `_.xor` except that it accepts `iteratee` which is\n         * invoked for each element of each `arrays` to generate the criterion by\n         * which by which they're compared. The order of result values is determined\n         * by the order they occur in the arrays. The iteratee is invoked with one\n         * argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {Array} Returns the new array of filtered values.\n         * @example\n         *\n         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n         * // => [1.2, 3.4]\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n         * // => [{ 'x': 2 }]\n         */\n        var xorBy = baseRest(function (arrays) {\n            var iteratee = last(arrays);\n            if (isArrayLikeObject(iteratee)) {\n                iteratee = undefined;\n            }\n            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n        });\n        /**\n         * This method is like `_.xor` except that it accepts `comparator` which is\n         * invoked to compare elements of `arrays`. The order of result values is\n         * determined by the order they occur in the arrays. The comparator is invoked\n         * with two arguments: (arrVal, othVal).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to inspect.\n         * @param {Function} [comparator] The comparator invoked per element.\n         * @returns {Array} Returns the new array of filtered values.\n         * @example\n         *\n         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n         *\n         * _.xorWith(objects, others, _.isEqual);\n         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n         */\n        var xorWith = baseRest(function (arrays) {\n            var comparator = last(arrays);\n            comparator = typeof comparator == 'function' ? comparator : undefined;\n            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n        });\n        /**\n         * Creates an array of grouped elements, the first of which contains the\n         * first elements of the given arrays, the second of which contains the\n         * second elements of the given arrays, and so on.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to process.\n         * @returns {Array} Returns the new array of grouped elements.\n         * @example\n         *\n         * _.zip(['a', 'b'], [1, 2], [true, false]);\n         * // => [['a', 1, true], ['b', 2, false]]\n         */\n        var zip = baseRest(unzip);\n        /**\n         * This method is like `_.fromPairs` except that it accepts two arrays,\n         * one of property identifiers and one of corresponding values.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.4.0\n         * @category Array\n         * @param {Array} [props=[]] The property identifiers.\n         * @param {Array} [values=[]] The property values.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * _.zipObject(['a', 'b'], [1, 2]);\n         * // => { 'a': 1, 'b': 2 }\n         */\n        function zipObject(props, values) {\n            return baseZipObject(props || [], values || [], assignValue);\n        }\n        /**\n         * This method is like `_.zipObject` except that it supports property paths.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.1.0\n         * @category Array\n         * @param {Array} [props=[]] The property identifiers.\n         * @param {Array} [values=[]] The property values.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n         */\n        function zipObjectDeep(props, values) {\n            return baseZipObject(props || [], values || [], baseSet);\n        }\n        /**\n         * This method is like `_.zip` except that it accepts `iteratee` to specify\n         * how grouped values should be combined. The iteratee is invoked with the\n         * elements of each group: (...group).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.8.0\n         * @category Array\n         * @param {...Array} [arrays] The arrays to process.\n         * @param {Function} [iteratee=_.identity] The function to combine\n         *  grouped values.\n         * @returns {Array} Returns the new array of grouped elements.\n         * @example\n         *\n         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n         *   return a + b + c;\n         * });\n         * // => [111, 222]\n         */\n        var zipWith = baseRest(function (arrays) {\n            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;\n            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n            return unzipWith(arrays, iteratee);\n        });\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n         * chain sequences enabled. The result of such sequences must be unwrapped\n         * with `_#value`.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.3.0\n         * @category Seq\n         * @param {*} value The value to wrap.\n         * @returns {Object} Returns the new `lodash` wrapper instance.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'age': 36 },\n         *   { 'user': 'fred',    'age': 40 },\n         *   { 'user': 'pebbles', 'age': 1 }\n         * ];\n         *\n         * var youngest = _\n         *   .chain(users)\n         *   .sortBy('age')\n         *   .map(function(o) {\n         *     return o.user + ' is ' + o.age;\n         *   })\n         *   .head()\n         *   .value();\n         * // => 'pebbles is 1'\n         */\n        function chain(value) {\n            var result = lodash(value);\n            result.__chain__ = true;\n            return result;\n        }\n        /**\n         * This method invokes `interceptor` and returns `value`. The interceptor\n         * is invoked with one argument; (value). The purpose of this method is to\n         * \"tap into\" a method chain sequence in order to modify intermediate results.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Seq\n         * @param {*} value The value to provide to `interceptor`.\n         * @param {Function} interceptor The function to invoke.\n         * @returns {*} Returns `value`.\n         * @example\n         *\n         * _([1, 2, 3])\n         *  .tap(function(array) {\n         *    // Mutate input array.\n         *    array.pop();\n         *  })\n         *  .reverse()\n         *  .value();\n         * // => [2, 1]\n         */\n        function tap(value, interceptor) {\n            interceptor(value);\n            return value;\n        }\n        /**\n         * This method is like `_.tap` except that it returns the result of `interceptor`.\n         * The purpose of this method is to \"pass thru\" values replacing intermediate\n         * results in a method chain sequence.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Seq\n         * @param {*} value The value to provide to `interceptor`.\n         * @param {Function} interceptor The function to invoke.\n         * @returns {*} Returns the result of `interceptor`.\n         * @example\n         *\n         * _('  abc  ')\n         *  .chain()\n         *  .trim()\n         *  .thru(function(value) {\n         *    return [value];\n         *  })\n         *  .value();\n         * // => ['abc']\n         */\n        function thru(value, interceptor) {\n            return interceptor(value);\n        }\n        /**\n         * This method is the wrapper version of `_.at`.\n         *\n         * @name at\n         * @memberOf _\n         * @since 1.0.0\n         * @category Seq\n         * @param {...(string|string[])} [paths] The property paths to pick.\n         * @returns {Object} Returns the new `lodash` wrapper instance.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n         *\n         * _(object).at(['a[0].b.c', 'a[1]']).value();\n         * // => [3, 4]\n         */\n        var wrapperAt = flatRest(function (paths) {\n            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function (object) { return baseAt(object, paths); };\n            if (length > 1 || this.__actions__.length ||\n                !(value instanceof LazyWrapper) || !isIndex(start)) {\n                return this.thru(interceptor);\n            }\n            value = value.slice(start, +start + (length ? 1 : 0));\n            value.__actions__.push({\n                'func': thru,\n                'args': [interceptor],\n                'thisArg': undefined\n            });\n            return new LodashWrapper(value, this.__chain__).thru(function (array) {\n                if (length && !array.length) {\n                    array.push(undefined);\n                }\n                return array;\n            });\n        });\n        /**\n         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n         *\n         * @name chain\n         * @memberOf _\n         * @since 0.1.0\n         * @category Seq\n         * @returns {Object} Returns the new `lodash` wrapper instance.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney', 'age': 36 },\n         *   { 'user': 'fred',   'age': 40 }\n         * ];\n         *\n         * // A sequence without explicit chaining.\n         * _(users).head();\n         * // => { 'user': 'barney', 'age': 36 }\n         *\n         * // A sequence with explicit chaining.\n         * _(users)\n         *   .chain()\n         *   .head()\n         *   .pick('user')\n         *   .value();\n         * // => { 'user': 'barney' }\n         */\n        function wrapperChain() {\n            return chain(this);\n        }\n        /**\n         * Executes the chain sequence and returns the wrapped result.\n         *\n         * @name commit\n         * @memberOf _\n         * @since 3.2.0\n         * @category Seq\n         * @returns {Object} Returns the new `lodash` wrapper instance.\n         * @example\n         *\n         * var array = [1, 2];\n         * var wrapped = _(array).push(3);\n         *\n         * console.log(array);\n         * // => [1, 2]\n         *\n         * wrapped = wrapped.commit();\n         * console.log(array);\n         * // => [1, 2, 3]\n         *\n         * wrapped.last();\n         * // => 3\n         *\n         * console.log(array);\n         * // => [1, 2, 3]\n         */\n        function wrapperCommit() {\n            return new LodashWrapper(this.value(), this.__chain__);\n        }\n        /**\n         * Gets the next value on a wrapped object following the\n         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n         *\n         * @name next\n         * @memberOf _\n         * @since 4.0.0\n         * @category Seq\n         * @returns {Object} Returns the next iterator value.\n         * @example\n         *\n         * var wrapped = _([1, 2]);\n         *\n         * wrapped.next();\n         * // => { 'done': false, 'value': 1 }\n         *\n         * wrapped.next();\n         * // => { 'done': false, 'value': 2 }\n         *\n         * wrapped.next();\n         * // => { 'done': true, 'value': undefined }\n         */\n        function wrapperNext() {\n            if (this.__values__ === undefined) {\n                this.__values__ = toArray(this.value());\n            }\n            var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];\n            return { 'done': done, 'value': value };\n        }\n        /**\n         * Enables the wrapper to be iterable.\n         *\n         * @name Symbol.iterator\n         * @memberOf _\n         * @since 4.0.0\n         * @category Seq\n         * @returns {Object} Returns the wrapper object.\n         * @example\n         *\n         * var wrapped = _([1, 2]);\n         *\n         * wrapped[Symbol.iterator]() === wrapped;\n         * // => true\n         *\n         * Array.from(wrapped);\n         * // => [1, 2]\n         */\n        function wrapperToIterator() {\n            return this;\n        }\n        /**\n         * Creates a clone of the chain sequence planting `value` as the wrapped value.\n         *\n         * @name plant\n         * @memberOf _\n         * @since 3.2.0\n         * @category Seq\n         * @param {*} value The value to plant.\n         * @returns {Object} Returns the new `lodash` wrapper instance.\n         * @example\n         *\n         * function square(n) {\n         *   return n * n;\n         * }\n         *\n         * var wrapped = _([1, 2]).map(square);\n         * var other = wrapped.plant([3, 4]);\n         *\n         * other.value();\n         * // => [9, 16]\n         *\n         * wrapped.value();\n         * // => [1, 4]\n         */\n        function wrapperPlant(value) {\n            var result, parent = this;\n            while (parent instanceof baseLodash) {\n                var clone = wrapperClone(parent);\n                clone.__index__ = 0;\n                clone.__values__ = undefined;\n                if (result) {\n                    previous.__wrapped__ = clone;\n                }\n                else {\n                    result = clone;\n                }\n                var previous = clone;\n                parent = parent.__wrapped__;\n            }\n            previous.__wrapped__ = value;\n            return result;\n        }\n        /**\n         * This method is the wrapper version of `_.reverse`.\n         *\n         * **Note:** This method mutates the wrapped array.\n         *\n         * @name reverse\n         * @memberOf _\n         * @since 0.1.0\n         * @category Seq\n         * @returns {Object} Returns the new `lodash` wrapper instance.\n         * @example\n         *\n         * var array = [1, 2, 3];\n         *\n         * _(array).reverse().value()\n         * // => [3, 2, 1]\n         *\n         * console.log(array);\n         * // => [3, 2, 1]\n         */\n        function wrapperReverse() {\n            var value = this.__wrapped__;\n            if (value instanceof LazyWrapper) {\n                var wrapped = value;\n                if (this.__actions__.length) {\n                    wrapped = new LazyWrapper(this);\n                }\n                wrapped = wrapped.reverse();\n                wrapped.__actions__.push({\n                    'func': thru,\n                    'args': [reverse],\n                    'thisArg': undefined\n                });\n                return new LodashWrapper(wrapped, this.__chain__);\n            }\n            return this.thru(reverse);\n        }\n        /**\n         * Executes the chain sequence to resolve the unwrapped value.\n         *\n         * @name value\n         * @memberOf _\n         * @since 0.1.0\n         * @alias toJSON, valueOf\n         * @category Seq\n         * @returns {*} Returns the resolved unwrapped value.\n         * @example\n         *\n         * _([1, 2, 3]).value();\n         * // => [1, 2, 3]\n         */\n        function wrapperValue() {\n            return baseWrapperValue(this.__wrapped__, this.__actions__);\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Creates an object composed of keys generated from the results of running\n         * each element of `collection` thru `iteratee`. The corresponding value of\n         * each key is the number of times the key was returned by `iteratee`. The\n         * iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.5.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n         * @returns {Object} Returns the composed aggregate object.\n         * @example\n         *\n         * _.countBy([6.1, 4.2, 6.3], Math.floor);\n         * // => { '4': 1, '6': 2 }\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.countBy(['one', 'two', 'three'], 'length');\n         * // => { '3': 2, '5': 1 }\n         */\n        var countBy = createAggregator(function (result, value, key) {\n            if (hasOwnProperty.call(result, key)) {\n                ++result[key];\n            }\n            else {\n                baseAssignValue(result, key, 1);\n            }\n        });\n        /**\n         * Checks if `predicate` returns truthy for **all** elements of `collection`.\n         * Iteration is stopped once `predicate` returns falsey. The predicate is\n         * invoked with three arguments: (value, index|key, collection).\n         *\n         * **Note:** This method returns `true` for\n         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n         * elements of empty collections.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {boolean} Returns `true` if all elements pass the predicate check,\n         *  else `false`.\n         * @example\n         *\n         * _.every([true, 1, null, 'yes'], Boolean);\n         * // => false\n         *\n         * var users = [\n         *   { 'user': 'barney', 'age': 36, 'active': false },\n         *   { 'user': 'fred',   'age': 40, 'active': false }\n         * ];\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.every(users, { 'user': 'barney', 'active': false });\n         * // => false\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.every(users, ['active', false]);\n         * // => true\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.every(users, 'active');\n         * // => false\n         */\n        function every(collection, predicate, guard) {\n            var func = isArray(collection) ? arrayEvery : baseEvery;\n            if (guard && isIterateeCall(collection, predicate, guard)) {\n                predicate = undefined;\n            }\n            return func(collection, getIteratee(predicate, 3));\n        }\n        /**\n         * Iterates over elements of `collection`, returning an array of all elements\n         * `predicate` returns truthy for. The predicate is invoked with three\n         * arguments: (value, index|key, collection).\n         *\n         * **Note:** Unlike `_.remove`, this method returns a new array.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the new filtered array.\n         * @see _.reject\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney', 'age': 36, 'active': true },\n         *   { 'user': 'fred',   'age': 40, 'active': false }\n         * ];\n         *\n         * _.filter(users, function(o) { return !o.active; });\n         * // => objects for ['fred']\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.filter(users, { 'age': 36, 'active': true });\n         * // => objects for ['barney']\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.filter(users, ['active', false]);\n         * // => objects for ['fred']\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.filter(users, 'active');\n         * // => objects for ['barney']\n         */\n        function filter(collection, predicate) {\n            var func = isArray(collection) ? arrayFilter : baseFilter;\n            return func(collection, getIteratee(predicate, 3));\n        }\n        /**\n         * Iterates over elements of `collection`, returning the first element\n         * `predicate` returns truthy for. The predicate is invoked with three\n         * arguments: (value, index|key, collection).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to inspect.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @param {number} [fromIndex=0] The index to search from.\n         * @returns {*} Returns the matched element, else `undefined`.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'age': 36, 'active': true },\n         *   { 'user': 'fred',    'age': 40, 'active': false },\n         *   { 'user': 'pebbles', 'age': 1,  'active': true }\n         * ];\n         *\n         * _.find(users, function(o) { return o.age < 40; });\n         * // => object for 'barney'\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.find(users, { 'age': 1, 'active': true });\n         * // => object for 'pebbles'\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.find(users, ['active', false]);\n         * // => object for 'fred'\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.find(users, 'active');\n         * // => object for 'barney'\n         */\n        var find = createFind(findIndex);\n        /**\n         * This method is like `_.find` except that it iterates over elements of\n         * `collection` from right to left.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to inspect.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @param {number} [fromIndex=collection.length-1] The index to search from.\n         * @returns {*} Returns the matched element, else `undefined`.\n         * @example\n         *\n         * _.findLast([1, 2, 3, 4], function(n) {\n         *   return n % 2 == 1;\n         * });\n         * // => 3\n         */\n        var findLast = createFind(findLastIndex);\n        /**\n         * Creates a flattened array of values by running each element in `collection`\n         * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n         * with three arguments: (value, index|key, collection).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the new flattened array.\n         * @example\n         *\n         * function duplicate(n) {\n         *   return [n, n];\n         * }\n         *\n         * _.flatMap([1, 2], duplicate);\n         * // => [1, 1, 2, 2]\n         */\n        function flatMap(collection, iteratee) {\n            return baseFlatten(map(collection, iteratee), 1);\n        }\n        /**\n         * This method is like `_.flatMap` except that it recursively flattens the\n         * mapped results.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.7.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the new flattened array.\n         * @example\n         *\n         * function duplicate(n) {\n         *   return [[[n, n]]];\n         * }\n         *\n         * _.flatMapDeep([1, 2], duplicate);\n         * // => [1, 1, 2, 2]\n         */\n        function flatMapDeep(collection, iteratee) {\n            return baseFlatten(map(collection, iteratee), INFINITY);\n        }\n        /**\n         * This method is like `_.flatMap` except that it recursively flattens the\n         * mapped results up to `depth` times.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.7.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @param {number} [depth=1] The maximum recursion depth.\n         * @returns {Array} Returns the new flattened array.\n         * @example\n         *\n         * function duplicate(n) {\n         *   return [[[n, n]]];\n         * }\n         *\n         * _.flatMapDepth([1, 2], duplicate, 2);\n         * // => [[1, 1], [2, 2]]\n         */\n        function flatMapDepth(collection, iteratee, depth) {\n            depth = depth === undefined ? 1 : toInteger(depth);\n            return baseFlatten(map(collection, iteratee), depth);\n        }\n        /**\n         * Iterates over elements of `collection` and invokes `iteratee` for each element.\n         * The iteratee is invoked with three arguments: (value, index|key, collection).\n         * Iteratee functions may exit iteration early by explicitly returning `false`.\n         *\n         * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n         * property are iterated like arrays. To avoid this behavior use `_.forIn`\n         * or `_.forOwn` for object iteration.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @alias each\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Array|Object} Returns `collection`.\n         * @see _.forEachRight\n         * @example\n         *\n         * _.forEach([1, 2], function(value) {\n         *   console.log(value);\n         * });\n         * // => Logs `1` then `2`.\n         *\n         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n         *   console.log(key);\n         * });\n         * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n         */\n        function forEach(collection, iteratee) {\n            var func = isArray(collection) ? arrayEach : baseEach;\n            return func(collection, getIteratee(iteratee, 3));\n        }\n        /**\n         * This method is like `_.forEach` except that it iterates over elements of\n         * `collection` from right to left.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @alias eachRight\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Array|Object} Returns `collection`.\n         * @see _.forEach\n         * @example\n         *\n         * _.forEachRight([1, 2], function(value) {\n         *   console.log(value);\n         * });\n         * // => Logs `2` then `1`.\n         */\n        function forEachRight(collection, iteratee) {\n            var func = isArray(collection) ? arrayEachRight : baseEachRight;\n            return func(collection, getIteratee(iteratee, 3));\n        }\n        /**\n         * Creates an object composed of keys generated from the results of running\n         * each element of `collection` thru `iteratee`. The order of grouped values\n         * is determined by the order they occur in `collection`. The corresponding\n         * value of each key is an array of elements responsible for generating the\n         * key. The iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n         * @returns {Object} Returns the composed aggregate object.\n         * @example\n         *\n         * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n         * // => { '4': [4.2], '6': [6.1, 6.3] }\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.groupBy(['one', 'two', 'three'], 'length');\n         * // => { '3': ['one', 'two'], '5': ['three'] }\n         */\n        var groupBy = createAggregator(function (result, value, key) {\n            if (hasOwnProperty.call(result, key)) {\n                result[key].push(value);\n            }\n            else {\n                baseAssignValue(result, key, [value]);\n            }\n        });\n        /**\n         * Checks if `value` is in `collection`. If `collection` is a string, it's\n         * checked for a substring of `value`, otherwise\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * is used for equality comparisons. If `fromIndex` is negative, it's used as\n         * the offset from the end of `collection`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object|string} collection The collection to inspect.\n         * @param {*} value The value to search for.\n         * @param {number} [fromIndex=0] The index to search from.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n         * @returns {boolean} Returns `true` if `value` is found, else `false`.\n         * @example\n         *\n         * _.includes([1, 2, 3], 1);\n         * // => true\n         *\n         * _.includes([1, 2, 3], 1, 2);\n         * // => false\n         *\n         * _.includes({ 'a': 1, 'b': 2 }, 1);\n         * // => true\n         *\n         * _.includes('abcd', 'bc');\n         * // => true\n         */\n        function includes(collection, value, fromIndex, guard) {\n            collection = isArrayLike(collection) ? collection : values(collection);\n            fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n            var length = collection.length;\n            if (fromIndex < 0) {\n                fromIndex = nativeMax(length + fromIndex, 0);\n            }\n            return isString(collection)\n                ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n                : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n        }\n        /**\n         * Invokes the method at `path` of each element in `collection`, returning\n         * an array of the results of each invoked method. Any additional arguments\n         * are provided to each invoked method. If `path` is a function, it's invoked\n         * for, and `this` bound to, each element in `collection`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Array|Function|string} path The path of the method to invoke or\n         *  the function invoked per iteration.\n         * @param {...*} [args] The arguments to invoke each method with.\n         * @returns {Array} Returns the array of results.\n         * @example\n         *\n         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n         * // => [[1, 5, 7], [1, 2, 3]]\n         *\n         * _.invokeMap([123, 456], String.prototype.split, '');\n         * // => [['1', '2', '3'], ['4', '5', '6']]\n         */\n        var invokeMap = baseRest(function (collection, path, args) {\n            var index = -1, isFunc = typeof path == 'function', result = isArrayLike(collection) ? Array(collection.length) : [];\n            baseEach(collection, function (value) {\n                result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n            });\n            return result;\n        });\n        /**\n         * Creates an object composed of keys generated from the results of running\n         * each element of `collection` thru `iteratee`. The corresponding value of\n         * each key is the last element responsible for generating the key. The\n         * iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n         * @returns {Object} Returns the composed aggregate object.\n         * @example\n         *\n         * var array = [\n         *   { 'dir': 'left', 'code': 97 },\n         *   { 'dir': 'right', 'code': 100 }\n         * ];\n         *\n         * _.keyBy(array, function(o) {\n         *   return String.fromCharCode(o.code);\n         * });\n         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n         *\n         * _.keyBy(array, 'dir');\n         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n         */\n        var keyBy = createAggregator(function (result, value, key) {\n            baseAssignValue(result, key, value);\n        });\n        /**\n         * Creates an array of values by running each element in `collection` thru\n         * `iteratee`. The iteratee is invoked with three arguments:\n         * (value, index|key, collection).\n         *\n         * Many lodash methods are guarded to work as iteratees for methods like\n         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n         *\n         * The guarded methods are:\n         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the new mapped array.\n         * @example\n         *\n         * function square(n) {\n         *   return n * n;\n         * }\n         *\n         * _.map([4, 8], square);\n         * // => [16, 64]\n         *\n         * _.map({ 'a': 4, 'b': 8 }, square);\n         * // => [16, 64] (iteration order is not guaranteed)\n         *\n         * var users = [\n         *   { 'user': 'barney' },\n         *   { 'user': 'fred' }\n         * ];\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.map(users, 'user');\n         * // => ['barney', 'fred']\n         */\n        function map(collection, iteratee) {\n            var func = isArray(collection) ? arrayMap : baseMap;\n            return func(collection, getIteratee(iteratee, 3));\n        }\n        /**\n         * This method is like `_.sortBy` except that it allows specifying the sort\n         * orders of the iteratees to sort by. If `orders` is unspecified, all values\n         * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n         * descending or \"asc\" for ascending sort order of corresponding values.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n         *  The iteratees to sort by.\n         * @param {string[]} [orders] The sort orders of `iteratees`.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n         * @returns {Array} Returns the new sorted array.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'fred',   'age': 48 },\n         *   { 'user': 'barney', 'age': 34 },\n         *   { 'user': 'fred',   'age': 40 },\n         *   { 'user': 'barney', 'age': 36 }\n         * ];\n         *\n         * // Sort by `user` in ascending order and by `age` in descending order.\n         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n         */\n        function orderBy(collection, iteratees, orders, guard) {\n            if (collection == null) {\n                return [];\n            }\n            if (!isArray(iteratees)) {\n                iteratees = iteratees == null ? [] : [iteratees];\n            }\n            orders = guard ? undefined : orders;\n            if (!isArray(orders)) {\n                orders = orders == null ? [] : [orders];\n            }\n            return baseOrderBy(collection, iteratees, orders);\n        }\n        /**\n         * Creates an array of elements split into two groups, the first of which\n         * contains elements `predicate` returns truthy for, the second of which\n         * contains elements `predicate` returns falsey for. The predicate is\n         * invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the array of grouped elements.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney',  'age': 36, 'active': false },\n         *   { 'user': 'fred',    'age': 40, 'active': true },\n         *   { 'user': 'pebbles', 'age': 1,  'active': false }\n         * ];\n         *\n         * _.partition(users, function(o) { return o.active; });\n         * // => objects for [['fred'], ['barney', 'pebbles']]\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.partition(users, { 'age': 1, 'active': false });\n         * // => objects for [['pebbles'], ['barney', 'fred']]\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.partition(users, ['active', false]);\n         * // => objects for [['barney', 'pebbles'], ['fred']]\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.partition(users, 'active');\n         * // => objects for [['fred'], ['barney', 'pebbles']]\n         */\n        var partition = createAggregator(function (result, value, key) {\n            result[key ? 0 : 1].push(value);\n        }, function () { return [[], []]; });\n        /**\n         * Reduces `collection` to a value which is the accumulated result of running\n         * each element in `collection` thru `iteratee`, where each successive\n         * invocation is supplied the return value of the previous. If `accumulator`\n         * is not given, the first element of `collection` is used as the initial\n         * value. The iteratee is invoked with four arguments:\n         * (accumulator, value, index|key, collection).\n         *\n         * Many lodash methods are guarded to work as iteratees for methods like\n         * `_.reduce`, `_.reduceRight`, and `_.transform`.\n         *\n         * The guarded methods are:\n         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n         * and `sortBy`\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @param {*} [accumulator] The initial value.\n         * @returns {*} Returns the accumulated value.\n         * @see _.reduceRight\n         * @example\n         *\n         * _.reduce([1, 2], function(sum, n) {\n         *   return sum + n;\n         * }, 0);\n         * // => 3\n         *\n         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n         *   (result[value] || (result[value] = [])).push(key);\n         *   return result;\n         * }, {});\n         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n         */\n        function reduce(collection, iteratee, accumulator) {\n            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;\n            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n        }\n        /**\n         * This method is like `_.reduce` except that it iterates over elements of\n         * `collection` from right to left.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @param {*} [accumulator] The initial value.\n         * @returns {*} Returns the accumulated value.\n         * @see _.reduce\n         * @example\n         *\n         * var array = [[0, 1], [2, 3], [4, 5]];\n         *\n         * _.reduceRight(array, function(flattened, other) {\n         *   return flattened.concat(other);\n         * }, []);\n         * // => [4, 5, 2, 3, 0, 1]\n         */\n        function reduceRight(collection, iteratee, accumulator) {\n            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;\n            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n        }\n        /**\n         * The opposite of `_.filter`; this method returns the elements of `collection`\n         * that `predicate` does **not** return truthy for.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the new filtered array.\n         * @see _.filter\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney', 'age': 36, 'active': false },\n         *   { 'user': 'fred',   'age': 40, 'active': true }\n         * ];\n         *\n         * _.reject(users, function(o) { return !o.active; });\n         * // => objects for ['fred']\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.reject(users, { 'age': 40, 'active': true });\n         * // => objects for ['barney']\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.reject(users, ['active', false]);\n         * // => objects for ['fred']\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.reject(users, 'active');\n         * // => objects for ['barney']\n         */\n        function reject(collection, predicate) {\n            var func = isArray(collection) ? arrayFilter : baseFilter;\n            return func(collection, negate(getIteratee(predicate, 3)));\n        }\n        /**\n         * Gets a random element from `collection`.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to sample.\n         * @returns {*} Returns the random element.\n         * @example\n         *\n         * _.sample([1, 2, 3, 4]);\n         * // => 2\n         */\n        function sample(collection) {\n            var func = isArray(collection) ? arraySample : baseSample;\n            return func(collection);\n        }\n        /**\n         * Gets `n` random elements at unique keys from `collection` up to the\n         * size of `collection`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to sample.\n         * @param {number} [n=1] The number of elements to sample.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Array} Returns the random elements.\n         * @example\n         *\n         * _.sampleSize([1, 2, 3], 2);\n         * // => [3, 1]\n         *\n         * _.sampleSize([1, 2, 3], 4);\n         * // => [2, 3, 1]\n         */\n        function sampleSize(collection, n, guard) {\n            if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n                n = 1;\n            }\n            else {\n                n = toInteger(n);\n            }\n            var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n            return func(collection, n);\n        }\n        /**\n         * Creates an array of shuffled values, using a version of the\n         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to shuffle.\n         * @returns {Array} Returns the new shuffled array.\n         * @example\n         *\n         * _.shuffle([1, 2, 3, 4]);\n         * // => [4, 1, 3, 2]\n         */\n        function shuffle(collection) {\n            var func = isArray(collection) ? arrayShuffle : baseShuffle;\n            return func(collection);\n        }\n        /**\n         * Gets the size of `collection` by returning its length for array-like\n         * values or the number of own enumerable string keyed properties for objects.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object|string} collection The collection to inspect.\n         * @returns {number} Returns the collection size.\n         * @example\n         *\n         * _.size([1, 2, 3]);\n         * // => 3\n         *\n         * _.size({ 'a': 1, 'b': 2 });\n         * // => 2\n         *\n         * _.size('pebbles');\n         * // => 7\n         */\n        function size(collection) {\n            if (collection == null) {\n                return 0;\n            }\n            if (isArrayLike(collection)) {\n                return isString(collection) ? stringSize(collection) : collection.length;\n            }\n            var tag = getTag(collection);\n            if (tag == mapTag || tag == setTag) {\n                return collection.size;\n            }\n            return baseKeys(collection).length;\n        }\n        /**\n         * Checks if `predicate` returns truthy for **any** element of `collection`.\n         * Iteration is stopped once `predicate` returns truthy. The predicate is\n         * invoked with three arguments: (value, index|key, collection).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {boolean} Returns `true` if any element passes the predicate check,\n         *  else `false`.\n         * @example\n         *\n         * _.some([null, 0, 'yes', false], Boolean);\n         * // => true\n         *\n         * var users = [\n         *   { 'user': 'barney', 'active': true },\n         *   { 'user': 'fred',   'active': false }\n         * ];\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.some(users, { 'user': 'barney', 'active': false });\n         * // => false\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.some(users, ['active', false]);\n         * // => true\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.some(users, 'active');\n         * // => true\n         */\n        function some(collection, predicate, guard) {\n            var func = isArray(collection) ? arraySome : baseSome;\n            if (guard && isIterateeCall(collection, predicate, guard)) {\n                predicate = undefined;\n            }\n            return func(collection, getIteratee(predicate, 3));\n        }\n        /**\n         * Creates an array of elements, sorted in ascending order by the results of\n         * running each element in a collection thru each iteratee. This method\n         * performs a stable sort, that is, it preserves the original sort order of\n         * equal elements. The iteratees are invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Collection\n         * @param {Array|Object} collection The collection to iterate over.\n         * @param {...(Function|Function[])} [iteratees=[_.identity]]\n         *  The iteratees to sort by.\n         * @returns {Array} Returns the new sorted array.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'fred',   'age': 48 },\n         *   { 'user': 'barney', 'age': 36 },\n         *   { 'user': 'fred',   'age': 40 },\n         *   { 'user': 'barney', 'age': 34 }\n         * ];\n         *\n         * _.sortBy(users, [function(o) { return o.user; }]);\n         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n         *\n         * _.sortBy(users, ['user', 'age']);\n         * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n         */\n        var sortBy = baseRest(function (collection, iteratees) {\n            if (collection == null) {\n                return [];\n            }\n            var length = iteratees.length;\n            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n                iteratees = [];\n            }\n            else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n                iteratees = [iteratees[0]];\n            }\n            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n        });\n        /*------------------------------------------------------------------------*/\n        /**\n         * Gets the timestamp of the number of milliseconds that have elapsed since\n         * the Unix epoch (1 January 1970 00:00:00 UTC).\n         *\n         * @static\n         * @memberOf _\n         * @since 2.4.0\n         * @category Date\n         * @returns {number} Returns the timestamp.\n         * @example\n         *\n         * _.defer(function(stamp) {\n         *   console.log(_.now() - stamp);\n         * }, _.now());\n         * // => Logs the number of milliseconds it took for the deferred invocation.\n         */\n        var now = ctxNow || function () {\n            return root.Date.now();\n        };\n        /*------------------------------------------------------------------------*/\n        /**\n         * The opposite of `_.before`; this method creates a function that invokes\n         * `func` once it's called `n` or more times.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {number} n The number of calls before `func` is invoked.\n         * @param {Function} func The function to restrict.\n         * @returns {Function} Returns the new restricted function.\n         * @example\n         *\n         * var saves = ['profile', 'settings'];\n         *\n         * var done = _.after(saves.length, function() {\n         *   console.log('done saving!');\n         * });\n         *\n         * _.forEach(saves, function(type) {\n         *   asyncSave({ 'type': type, 'complete': done });\n         * });\n         * // => Logs 'done saving!' after the two async saves have completed.\n         */\n        function after(n, func) {\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            n = toInteger(n);\n            return function () {\n                if (--n < 1) {\n                    return func.apply(this, arguments);\n                }\n            };\n        }\n        /**\n         * Creates a function that invokes `func`, with up to `n` arguments,\n         * ignoring any additional arguments.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Function\n         * @param {Function} func The function to cap arguments for.\n         * @param {number} [n=func.length] The arity cap.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Function} Returns the new capped function.\n         * @example\n         *\n         * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n         * // => [6, 8, 10]\n         */\n        function ary(func, n, guard) {\n            n = guard ? undefined : n;\n            n = (func && n == null) ? func.length : n;\n            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n        }\n        /**\n         * Creates a function that invokes `func`, with the `this` binding and arguments\n         * of the created function, while it's called less than `n` times. Subsequent\n         * calls to the created function return the result of the last `func` invocation.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Function\n         * @param {number} n The number of calls at which `func` is no longer invoked.\n         * @param {Function} func The function to restrict.\n         * @returns {Function} Returns the new restricted function.\n         * @example\n         *\n         * jQuery(element).on('click', _.before(5, addContactToList));\n         * // => Allows adding up to 4 contacts to the list.\n         */\n        function before(n, func) {\n            var result;\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            n = toInteger(n);\n            return function () {\n                if (--n > 0) {\n                    result = func.apply(this, arguments);\n                }\n                if (n <= 1) {\n                    func = undefined;\n                }\n                return result;\n            };\n        }\n        /**\n         * Creates a function that invokes `func` with the `this` binding of `thisArg`\n         * and `partials` prepended to the arguments it receives.\n         *\n         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n         * may be used as a placeholder for partially applied arguments.\n         *\n         * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n         * property of bound functions.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {Function} func The function to bind.\n         * @param {*} thisArg The `this` binding of `func`.\n         * @param {...*} [partials] The arguments to be partially applied.\n         * @returns {Function} Returns the new bound function.\n         * @example\n         *\n         * function greet(greeting, punctuation) {\n         *   return greeting + ' ' + this.user + punctuation;\n         * }\n         *\n         * var object = { 'user': 'fred' };\n         *\n         * var bound = _.bind(greet, object, 'hi');\n         * bound('!');\n         * // => 'hi fred!'\n         *\n         * // Bound with placeholders.\n         * var bound = _.bind(greet, object, _, '!');\n         * bound('hi');\n         * // => 'hi fred!'\n         */\n        var bind = baseRest(function (func, thisArg, partials) {\n            var bitmask = WRAP_BIND_FLAG;\n            if (partials.length) {\n                var holders = replaceHolders(partials, getHolder(bind));\n                bitmask |= WRAP_PARTIAL_FLAG;\n            }\n            return createWrap(func, bitmask, thisArg, partials, holders);\n        });\n        /**\n         * Creates a function that invokes the method at `object[key]` with `partials`\n         * prepended to the arguments it receives.\n         *\n         * This method differs from `_.bind` by allowing bound functions to reference\n         * methods that may be redefined or don't yet exist. See\n         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n         * for more details.\n         *\n         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n         * builds, may be used as a placeholder for partially applied arguments.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.10.0\n         * @category Function\n         * @param {Object} object The object to invoke the method on.\n         * @param {string} key The key of the method.\n         * @param {...*} [partials] The arguments to be partially applied.\n         * @returns {Function} Returns the new bound function.\n         * @example\n         *\n         * var object = {\n         *   'user': 'fred',\n         *   'greet': function(greeting, punctuation) {\n         *     return greeting + ' ' + this.user + punctuation;\n         *   }\n         * };\n         *\n         * var bound = _.bindKey(object, 'greet', 'hi');\n         * bound('!');\n         * // => 'hi fred!'\n         *\n         * object.greet = function(greeting, punctuation) {\n         *   return greeting + 'ya ' + this.user + punctuation;\n         * };\n         *\n         * bound('!');\n         * // => 'hiya fred!'\n         *\n         * // Bound with placeholders.\n         * var bound = _.bindKey(object, 'greet', _, '!');\n         * bound('hi');\n         * // => 'hiya fred!'\n         */\n        var bindKey = baseRest(function (object, key, partials) {\n            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n            if (partials.length) {\n                var holders = replaceHolders(partials, getHolder(bindKey));\n                bitmask |= WRAP_PARTIAL_FLAG;\n            }\n            return createWrap(key, bitmask, object, partials, holders);\n        });\n        /**\n         * Creates a function that accepts arguments of `func` and either invokes\n         * `func` returning its result, if at least `arity` number of arguments have\n         * been provided, or returns a function that accepts the remaining `func`\n         * arguments, and so on. The arity of `func` may be specified if `func.length`\n         * is not sufficient.\n         *\n         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n         * may be used as a placeholder for provided arguments.\n         *\n         * **Note:** This method doesn't set the \"length\" property of curried functions.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Function\n         * @param {Function} func The function to curry.\n         * @param {number} [arity=func.length] The arity of `func`.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Function} Returns the new curried function.\n         * @example\n         *\n         * var abc = function(a, b, c) {\n         *   return [a, b, c];\n         * };\n         *\n         * var curried = _.curry(abc);\n         *\n         * curried(1)(2)(3);\n         * // => [1, 2, 3]\n         *\n         * curried(1, 2)(3);\n         * // => [1, 2, 3]\n         *\n         * curried(1, 2, 3);\n         * // => [1, 2, 3]\n         *\n         * // Curried with placeholders.\n         * curried(1)(_, 3)(2);\n         * // => [1, 2, 3]\n         */\n        function curry(func, arity, guard) {\n            arity = guard ? undefined : arity;\n            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n            result.placeholder = curry.placeholder;\n            return result;\n        }\n        /**\n         * This method is like `_.curry` except that arguments are applied to `func`\n         * in the manner of `_.partialRight` instead of `_.partial`.\n         *\n         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n         * builds, may be used as a placeholder for provided arguments.\n         *\n         * **Note:** This method doesn't set the \"length\" property of curried functions.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Function\n         * @param {Function} func The function to curry.\n         * @param {number} [arity=func.length] The arity of `func`.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Function} Returns the new curried function.\n         * @example\n         *\n         * var abc = function(a, b, c) {\n         *   return [a, b, c];\n         * };\n         *\n         * var curried = _.curryRight(abc);\n         *\n         * curried(3)(2)(1);\n         * // => [1, 2, 3]\n         *\n         * curried(2, 3)(1);\n         * // => [1, 2, 3]\n         *\n         * curried(1, 2, 3);\n         * // => [1, 2, 3]\n         *\n         * // Curried with placeholders.\n         * curried(3)(1, _)(2);\n         * // => [1, 2, 3]\n         */\n        function curryRight(func, arity, guard) {\n            arity = guard ? undefined : arity;\n            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n            result.placeholder = curryRight.placeholder;\n            return result;\n        }\n        /**\n         * Creates a debounced function that delays invoking `func` until after `wait`\n         * milliseconds have elapsed since the last time the debounced function was\n         * invoked. The debounced function comes with a `cancel` method to cancel\n         * delayed `func` invocations and a `flush` method to immediately invoke them.\n         * Provide `options` to indicate whether `func` should be invoked on the\n         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n         * with the last arguments provided to the debounced function. Subsequent\n         * calls to the debounced function return the result of the last `func`\n         * invocation.\n         *\n         * **Note:** If `leading` and `trailing` options are `true`, `func` is\n         * invoked on the trailing edge of the timeout only if the debounced function\n         * is invoked more than once during the `wait` timeout.\n         *\n         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n         * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n         *\n         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n         * for details over the differences between `_.debounce` and `_.throttle`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {Function} func The function to debounce.\n         * @param {number} [wait=0] The number of milliseconds to delay.\n         * @param {Object} [options={}] The options object.\n         * @param {boolean} [options.leading=false]\n         *  Specify invoking on the leading edge of the timeout.\n         * @param {number} [options.maxWait]\n         *  The maximum time `func` is allowed to be delayed before it's invoked.\n         * @param {boolean} [options.trailing=true]\n         *  Specify invoking on the trailing edge of the timeout.\n         * @returns {Function} Returns the new debounced function.\n         * @example\n         *\n         * // Avoid costly calculations while the window size is in flux.\n         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n         *\n         * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n         * jQuery(element).on('click', _.debounce(sendMail, 300, {\n         *   'leading': true,\n         *   'trailing': false\n         * }));\n         *\n         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n         * var source = new EventSource('/stream');\n         * jQuery(source).on('message', debounced);\n         *\n         * // Cancel the trailing debounced invocation.\n         * jQuery(window).on('popstate', debounced.cancel);\n         */\n        function debounce(func, wait, options) {\n            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            wait = toNumber(wait) || 0;\n            if (isObject(options)) {\n                leading = !!options.leading;\n                maxing = 'maxWait' in options;\n                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n                trailing = 'trailing' in options ? !!options.trailing : trailing;\n            }\n            function invokeFunc(time) {\n                var args = lastArgs, thisArg = lastThis;\n                lastArgs = lastThis = undefined;\n                lastInvokeTime = time;\n                result = func.apply(thisArg, args);\n                return result;\n            }\n            function leadingEdge(time) {\n                // Reset any `maxWait` timer.\n                lastInvokeTime = time;\n                // Start the timer for the trailing edge.\n                timerId = setTimeout(timerExpired, wait);\n                // Invoke the leading edge.\n                return leading ? invokeFunc(time) : result;\n            }\n            function remainingWait(time) {\n                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result = wait - timeSinceLastCall;\n                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n            }\n            function shouldInvoke(time) {\n                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n                // Either this is the first call, activity has stopped and we're at the\n                // trailing edge, the system time has gone backwards and we're treating\n                // it as the trailing edge, or we've hit the `maxWait` limit.\n                return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n                    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n            }\n            function timerExpired() {\n                var time = now();\n                if (shouldInvoke(time)) {\n                    return trailingEdge(time);\n                }\n                // Restart the timer.\n                timerId = setTimeout(timerExpired, remainingWait(time));\n            }\n            function trailingEdge(time) {\n                timerId = undefined;\n                // Only invoke if we have `lastArgs` which means `func` has been\n                // debounced at least once.\n                if (trailing && lastArgs) {\n                    return invokeFunc(time);\n                }\n                lastArgs = lastThis = undefined;\n                return result;\n            }\n            function cancel() {\n                if (timerId !== undefined) {\n                    clearTimeout(timerId);\n                }\n                lastInvokeTime = 0;\n                lastArgs = lastCallTime = lastThis = timerId = undefined;\n            }\n            function flush() {\n                return timerId === undefined ? result : trailingEdge(now());\n            }\n            function debounced() {\n                var time = now(), isInvoking = shouldInvoke(time);\n                lastArgs = arguments;\n                lastThis = this;\n                lastCallTime = time;\n                if (isInvoking) {\n                    if (timerId === undefined) {\n                        return leadingEdge(lastCallTime);\n                    }\n                    if (maxing) {\n                        // Handle invocations in a tight loop.\n                        timerId = setTimeout(timerExpired, wait);\n                        return invokeFunc(lastCallTime);\n                    }\n                }\n                if (timerId === undefined) {\n                    timerId = setTimeout(timerExpired, wait);\n                }\n                return result;\n            }\n            debounced.cancel = cancel;\n            debounced.flush = flush;\n            return debounced;\n        }\n        /**\n         * Defers invoking the `func` until the current call stack has cleared. Any\n         * additional arguments are provided to `func` when it's invoked.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {Function} func The function to defer.\n         * @param {...*} [args] The arguments to invoke `func` with.\n         * @returns {number} Returns the timer id.\n         * @example\n         *\n         * _.defer(function(text) {\n         *   console.log(text);\n         * }, 'deferred');\n         * // => Logs 'deferred' after one millisecond.\n         */\n        var defer = baseRest(function (func, args) {\n            return baseDelay(func, 1, args);\n        });\n        /**\n         * Invokes `func` after `wait` milliseconds. Any additional arguments are\n         * provided to `func` when it's invoked.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {Function} func The function to delay.\n         * @param {number} wait The number of milliseconds to delay invocation.\n         * @param {...*} [args] The arguments to invoke `func` with.\n         * @returns {number} Returns the timer id.\n         * @example\n         *\n         * _.delay(function(text) {\n         *   console.log(text);\n         * }, 1000, 'later');\n         * // => Logs 'later' after one second.\n         */\n        var delay = baseRest(function (func, wait, args) {\n            return baseDelay(func, toNumber(wait) || 0, args);\n        });\n        /**\n         * Creates a function that invokes `func` with arguments reversed.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Function\n         * @param {Function} func The function to flip arguments for.\n         * @returns {Function} Returns the new flipped function.\n         * @example\n         *\n         * var flipped = _.flip(function() {\n         *   return _.toArray(arguments);\n         * });\n         *\n         * flipped('a', 'b', 'c', 'd');\n         * // => ['d', 'c', 'b', 'a']\n         */\n        function flip(func) {\n            return createWrap(func, WRAP_FLIP_FLAG);\n        }\n        /**\n         * Creates a function that memoizes the result of `func`. If `resolver` is\n         * provided, it determines the cache key for storing the result based on the\n         * arguments provided to the memoized function. By default, the first argument\n         * provided to the memoized function is used as the map cache key. The `func`\n         * is invoked with the `this` binding of the memoized function.\n         *\n         * **Note:** The cache is exposed as the `cache` property on the memoized\n         * function. Its creation may be customized by replacing the `_.memoize.Cache`\n         * constructor with one whose instances implement the\n         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n         * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {Function} func The function to have its output memoized.\n         * @param {Function} [resolver] The function to resolve the cache key.\n         * @returns {Function} Returns the new memoized function.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': 2 };\n         * var other = { 'c': 3, 'd': 4 };\n         *\n         * var values = _.memoize(_.values);\n         * values(object);\n         * // => [1, 2]\n         *\n         * values(other);\n         * // => [3, 4]\n         *\n         * object.a = 2;\n         * values(object);\n         * // => [1, 2]\n         *\n         * // Modify the result cache.\n         * values.cache.set(object, ['a', 'b']);\n         * values(object);\n         * // => ['a', 'b']\n         *\n         * // Replace `_.memoize.Cache`.\n         * _.memoize.Cache = WeakMap;\n         */\n        function memoize(func, resolver) {\n            if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            var memoized = function () {\n                var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n                if (cache.has(key)) {\n                    return cache.get(key);\n                }\n                var result = func.apply(this, args);\n                memoized.cache = cache.set(key, result) || cache;\n                return result;\n            };\n            memoized.cache = new (memoize.Cache || MapCache);\n            return memoized;\n        }\n        // Expose `MapCache`.\n        memoize.Cache = MapCache;\n        /**\n         * Creates a function that negates the result of the predicate `func`. The\n         * `func` predicate is invoked with the `this` binding and arguments of the\n         * created function.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Function\n         * @param {Function} predicate The predicate to negate.\n         * @returns {Function} Returns the new negated function.\n         * @example\n         *\n         * function isEven(n) {\n         *   return n % 2 == 0;\n         * }\n         *\n         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n         * // => [1, 3, 5]\n         */\n        function negate(predicate) {\n            if (typeof predicate != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            return function () {\n                var args = arguments;\n                switch (args.length) {\n                    case 0: return !predicate.call(this);\n                    case 1: return !predicate.call(this, args[0]);\n                    case 2: return !predicate.call(this, args[0], args[1]);\n                    case 3: return !predicate.call(this, args[0], args[1], args[2]);\n                }\n                return !predicate.apply(this, args);\n            };\n        }\n        /**\n         * Creates a function that is restricted to invoking `func` once. Repeat calls\n         * to the function return the value of the first invocation. The `func` is\n         * invoked with the `this` binding and arguments of the created function.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {Function} func The function to restrict.\n         * @returns {Function} Returns the new restricted function.\n         * @example\n         *\n         * var initialize = _.once(createApplication);\n         * initialize();\n         * initialize();\n         * // => `createApplication` is invoked once\n         */\n        function once(func) {\n            return before(2, func);\n        }\n        /**\n         * Creates a function that invokes `func` with its arguments transformed.\n         *\n         * @static\n         * @since 4.0.0\n         * @memberOf _\n         * @category Function\n         * @param {Function} func The function to wrap.\n         * @param {...(Function|Function[])} [transforms=[_.identity]]\n         *  The argument transforms.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * function doubled(n) {\n         *   return n * 2;\n         * }\n         *\n         * function square(n) {\n         *   return n * n;\n         * }\n         *\n         * var func = _.overArgs(function(x, y) {\n         *   return [x, y];\n         * }, [square, doubled]);\n         *\n         * func(9, 3);\n         * // => [81, 6]\n         *\n         * func(10, 5);\n         * // => [100, 10]\n         */\n        var overArgs = castRest(function (func, transforms) {\n            transforms = (transforms.length == 1 && isArray(transforms[0]))\n                ? arrayMap(transforms[0], baseUnary(getIteratee()))\n                : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n            var funcsLength = transforms.length;\n            return baseRest(function (args) {\n                var index = -1, length = nativeMin(args.length, funcsLength);\n                while (++index < length) {\n                    args[index] = transforms[index].call(this, args[index]);\n                }\n                return apply(func, this, args);\n            });\n        });\n        /**\n         * Creates a function that invokes `func` with `partials` prepended to the\n         * arguments it receives. This method is like `_.bind` except it does **not**\n         * alter the `this` binding.\n         *\n         * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n         * builds, may be used as a placeholder for partially applied arguments.\n         *\n         * **Note:** This method doesn't set the \"length\" property of partially\n         * applied functions.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.2.0\n         * @category Function\n         * @param {Function} func The function to partially apply arguments to.\n         * @param {...*} [partials] The arguments to be partially applied.\n         * @returns {Function} Returns the new partially applied function.\n         * @example\n         *\n         * function greet(greeting, name) {\n         *   return greeting + ' ' + name;\n         * }\n         *\n         * var sayHelloTo = _.partial(greet, 'hello');\n         * sayHelloTo('fred');\n         * // => 'hello fred'\n         *\n         * // Partially applied with placeholders.\n         * var greetFred = _.partial(greet, _, 'fred');\n         * greetFred('hi');\n         * // => 'hi fred'\n         */\n        var partial = baseRest(function (func, partials) {\n            var holders = replaceHolders(partials, getHolder(partial));\n            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n        });\n        /**\n         * This method is like `_.partial` except that partially applied arguments\n         * are appended to the arguments it receives.\n         *\n         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n         * builds, may be used as a placeholder for partially applied arguments.\n         *\n         * **Note:** This method doesn't set the \"length\" property of partially\n         * applied functions.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.0.0\n         * @category Function\n         * @param {Function} func The function to partially apply arguments to.\n         * @param {...*} [partials] The arguments to be partially applied.\n         * @returns {Function} Returns the new partially applied function.\n         * @example\n         *\n         * function greet(greeting, name) {\n         *   return greeting + ' ' + name;\n         * }\n         *\n         * var greetFred = _.partialRight(greet, 'fred');\n         * greetFred('hi');\n         * // => 'hi fred'\n         *\n         * // Partially applied with placeholders.\n         * var sayHelloTo = _.partialRight(greet, 'hello', _);\n         * sayHelloTo('fred');\n         * // => 'hello fred'\n         */\n        var partialRight = baseRest(function (func, partials) {\n            var holders = replaceHolders(partials, getHolder(partialRight));\n            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n        });\n        /**\n         * Creates a function that invokes `func` with arguments arranged according\n         * to the specified `indexes` where the argument value at the first index is\n         * provided as the first argument, the argument value at the second index is\n         * provided as the second argument, and so on.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Function\n         * @param {Function} func The function to rearrange arguments for.\n         * @param {...(number|number[])} indexes The arranged argument indexes.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * var rearged = _.rearg(function(a, b, c) {\n         *   return [a, b, c];\n         * }, [2, 0, 1]);\n         *\n         * rearged('b', 'c', 'a')\n         * // => ['a', 'b', 'c']\n         */\n        var rearg = flatRest(function (func, indexes) {\n            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n        });\n        /**\n         * Creates a function that invokes `func` with the `this` binding of the\n         * created function and arguments from `start` and beyond provided as\n         * an array.\n         *\n         * **Note:** This method is based on the\n         * [rest parameter](https://mdn.io/rest_parameters).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Function\n         * @param {Function} func The function to apply a rest parameter to.\n         * @param {number} [start=func.length-1] The start position of the rest parameter.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * var say = _.rest(function(what, names) {\n         *   return what + ' ' + _.initial(names).join(', ') +\n         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n         * });\n         *\n         * say('hello', 'fred', 'barney', 'pebbles');\n         * // => 'hello fred, barney, & pebbles'\n         */\n        function rest(func, start) {\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            start = start === undefined ? start : toInteger(start);\n            return baseRest(func, start);\n        }\n        /**\n         * Creates a function that invokes `func` with the `this` binding of the\n         * create function and an array of arguments much like\n         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n         *\n         * **Note:** This method is based on the\n         * [spread operator](https://mdn.io/spread_operator).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.2.0\n         * @category Function\n         * @param {Function} func The function to spread arguments over.\n         * @param {number} [start=0] The start position of the spread.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * var say = _.spread(function(who, what) {\n         *   return who + ' says ' + what;\n         * });\n         *\n         * say(['fred', 'hello']);\n         * // => 'fred says hello'\n         *\n         * var numbers = Promise.all([\n         *   Promise.resolve(40),\n         *   Promise.resolve(36)\n         * ]);\n         *\n         * numbers.then(_.spread(function(x, y) {\n         *   return x + y;\n         * }));\n         * // => a Promise of 76\n         */\n        function spread(func, start) {\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            start = start === undefined ? 0 : nativeMax(toInteger(start), 0);\n            return baseRest(function (args) {\n                var array = args[start], otherArgs = castSlice(args, 0, start);\n                if (array) {\n                    arrayPush(otherArgs, array);\n                }\n                return apply(func, this, otherArgs);\n            });\n        }\n        /**\n         * Creates a throttled function that only invokes `func` at most once per\n         * every `wait` milliseconds. The throttled function comes with a `cancel`\n         * method to cancel delayed `func` invocations and a `flush` method to\n         * immediately invoke them. Provide `options` to indicate whether `func`\n         * should be invoked on the leading and/or trailing edge of the `wait`\n         * timeout. The `func` is invoked with the last arguments provided to the\n         * throttled function. Subsequent calls to the throttled function return the\n         * result of the last `func` invocation.\n         *\n         * **Note:** If `leading` and `trailing` options are `true`, `func` is\n         * invoked on the trailing edge of the timeout only if the throttled function\n         * is invoked more than once during the `wait` timeout.\n         *\n         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n         * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n         *\n         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n         * for details over the differences between `_.throttle` and `_.debounce`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {Function} func The function to throttle.\n         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n         * @param {Object} [options={}] The options object.\n         * @param {boolean} [options.leading=true]\n         *  Specify invoking on the leading edge of the timeout.\n         * @param {boolean} [options.trailing=true]\n         *  Specify invoking on the trailing edge of the timeout.\n         * @returns {Function} Returns the new throttled function.\n         * @example\n         *\n         * // Avoid excessively updating the position while scrolling.\n         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n         *\n         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n         * jQuery(element).on('click', throttled);\n         *\n         * // Cancel the trailing throttled invocation.\n         * jQuery(window).on('popstate', throttled.cancel);\n         */\n        function throttle(func, wait, options) {\n            var leading = true, trailing = true;\n            if (typeof func != 'function') {\n                throw new TypeError(FUNC_ERROR_TEXT);\n            }\n            if (isObject(options)) {\n                leading = 'leading' in options ? !!options.leading : leading;\n                trailing = 'trailing' in options ? !!options.trailing : trailing;\n            }\n            return debounce(func, wait, {\n                'leading': leading,\n                'maxWait': wait,\n                'trailing': trailing\n            });\n        }\n        /**\n         * Creates a function that accepts up to one argument, ignoring any\n         * additional arguments.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Function\n         * @param {Function} func The function to cap arguments for.\n         * @returns {Function} Returns the new capped function.\n         * @example\n         *\n         * _.map(['6', '8', '10'], _.unary(parseInt));\n         * // => [6, 8, 10]\n         */\n        function unary(func) {\n            return ary(func, 1);\n        }\n        /**\n         * Creates a function that provides `value` to `wrapper` as its first\n         * argument. Any additional arguments provided to the function are appended\n         * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n         * binding of the created function.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Function\n         * @param {*} value The value to wrap.\n         * @param {Function} [wrapper=identity] The wrapper function.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * var p = _.wrap(_.escape, function(func, text) {\n         *   return '<p>' + func(text) + '</p>';\n         * });\n         *\n         * p('fred, barney, & pebbles');\n         * // => '<p>fred, barney, &amp; pebbles</p>'\n         */\n        function wrap(value, wrapper) {\n            return partial(castFunction(wrapper), value);\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Casts `value` as an array if it's not one.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.4.0\n         * @category Lang\n         * @param {*} value The value to inspect.\n         * @returns {Array} Returns the cast array.\n         * @example\n         *\n         * _.castArray(1);\n         * // => [1]\n         *\n         * _.castArray({ 'a': 1 });\n         * // => [{ 'a': 1 }]\n         *\n         * _.castArray('abc');\n         * // => ['abc']\n         *\n         * _.castArray(null);\n         * // => [null]\n         *\n         * _.castArray(undefined);\n         * // => [undefined]\n         *\n         * _.castArray();\n         * // => []\n         *\n         * var array = [1, 2, 3];\n         * console.log(_.castArray(array) === array);\n         * // => true\n         */\n        function castArray() {\n            if (!arguments.length) {\n                return [];\n            }\n            var value = arguments[0];\n            return isArray(value) ? value : [value];\n        }\n        /**\n         * Creates a shallow clone of `value`.\n         *\n         * **Note:** This method is loosely based on the\n         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n         * and supports cloning arrays, array buffers, booleans, date objects, maps,\n         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n         * arrays. The own enumerable properties of `arguments` objects are cloned\n         * as plain objects. An empty object is returned for uncloneable values such\n         * as error objects, functions, DOM nodes, and WeakMaps.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to clone.\n         * @returns {*} Returns the cloned value.\n         * @see _.cloneDeep\n         * @example\n         *\n         * var objects = [{ 'a': 1 }, { 'b': 2 }];\n         *\n         * var shallow = _.clone(objects);\n         * console.log(shallow[0] === objects[0]);\n         * // => true\n         */\n        function clone(value) {\n            return baseClone(value, CLONE_SYMBOLS_FLAG);\n        }\n        /**\n         * This method is like `_.clone` except that it accepts `customizer` which\n         * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n         * cloning is handled by the method instead. The `customizer` is invoked with\n         * up to four arguments; (value [, index|key, object, stack]).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to clone.\n         * @param {Function} [customizer] The function to customize cloning.\n         * @returns {*} Returns the cloned value.\n         * @see _.cloneDeepWith\n         * @example\n         *\n         * function customizer(value) {\n         *   if (_.isElement(value)) {\n         *     return value.cloneNode(false);\n         *   }\n         * }\n         *\n         * var el = _.cloneWith(document.body, customizer);\n         *\n         * console.log(el === document.body);\n         * // => false\n         * console.log(el.nodeName);\n         * // => 'BODY'\n         * console.log(el.childNodes.length);\n         * // => 0\n         */\n        function cloneWith(value, customizer) {\n            customizer = typeof customizer == 'function' ? customizer : undefined;\n            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n        }\n        /**\n         * This method is like `_.clone` except that it recursively clones `value`.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.0.0\n         * @category Lang\n         * @param {*} value The value to recursively clone.\n         * @returns {*} Returns the deep cloned value.\n         * @see _.clone\n         * @example\n         *\n         * var objects = [{ 'a': 1 }, { 'b': 2 }];\n         *\n         * var deep = _.cloneDeep(objects);\n         * console.log(deep[0] === objects[0]);\n         * // => false\n         */\n        function cloneDeep(value) {\n            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n        }\n        /**\n         * This method is like `_.cloneWith` except that it recursively clones `value`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to recursively clone.\n         * @param {Function} [customizer] The function to customize cloning.\n         * @returns {*} Returns the deep cloned value.\n         * @see _.cloneWith\n         * @example\n         *\n         * function customizer(value) {\n         *   if (_.isElement(value)) {\n         *     return value.cloneNode(true);\n         *   }\n         * }\n         *\n         * var el = _.cloneDeepWith(document.body, customizer);\n         *\n         * console.log(el === document.body);\n         * // => false\n         * console.log(el.nodeName);\n         * // => 'BODY'\n         * console.log(el.childNodes.length);\n         * // => 20\n         */\n        function cloneDeepWith(value, customizer) {\n            customizer = typeof customizer == 'function' ? customizer : undefined;\n            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n        }\n        /**\n         * Checks if `object` conforms to `source` by invoking the predicate\n         * properties of `source` with the corresponding property values of `object`.\n         *\n         * **Note:** This method is equivalent to `_.conforms` when `source` is\n         * partially applied.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.14.0\n         * @category Lang\n         * @param {Object} object The object to inspect.\n         * @param {Object} source The object of property predicates to conform to.\n         * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': 2 };\n         *\n         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n         * // => true\n         *\n         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n         * // => false\n         */\n        function conformsTo(object, source) {\n            return source == null || baseConformsTo(object, source, keys(source));\n        }\n        /**\n         * Performs a\n         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n         * comparison between two values to determine if they are equivalent.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * var object = { 'a': 1 };\n         * var other = { 'a': 1 };\n         *\n         * _.eq(object, object);\n         * // => true\n         *\n         * _.eq(object, other);\n         * // => false\n         *\n         * _.eq('a', 'a');\n         * // => true\n         *\n         * _.eq('a', Object('a'));\n         * // => false\n         *\n         * _.eq(NaN, NaN);\n         * // => true\n         */\n        function eq(value, other) {\n            return value === other || (value !== value && other !== other);\n        }\n        /**\n         * Checks if `value` is greater than `other`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.9.0\n         * @category Lang\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if `value` is greater than `other`,\n         *  else `false`.\n         * @see _.lt\n         * @example\n         *\n         * _.gt(3, 1);\n         * // => true\n         *\n         * _.gt(3, 3);\n         * // => false\n         *\n         * _.gt(1, 3);\n         * // => false\n         */\n        var gt = createRelationalOperation(baseGt);\n        /**\n         * Checks if `value` is greater than or equal to `other`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.9.0\n         * @category Lang\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if `value` is greater than or equal to\n         *  `other`, else `false`.\n         * @see _.lte\n         * @example\n         *\n         * _.gte(3, 1);\n         * // => true\n         *\n         * _.gte(3, 3);\n         * // => true\n         *\n         * _.gte(1, 3);\n         * // => false\n         */\n        var gte = createRelationalOperation(function (value, other) {\n            return value >= other;\n        });\n        /**\n         * Checks if `value` is likely an `arguments` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n         *  else `false`.\n         * @example\n         *\n         * _.isArguments(function() { return arguments; }());\n         * // => true\n         *\n         * _.isArguments([1, 2, 3]);\n         * // => false\n         */\n        var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) {\n            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n                !propertyIsEnumerable.call(value, 'callee');\n        };\n        /**\n         * Checks if `value` is classified as an `Array` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n         * @example\n         *\n         * _.isArray([1, 2, 3]);\n         * // => true\n         *\n         * _.isArray(document.body.children);\n         * // => false\n         *\n         * _.isArray('abc');\n         * // => false\n         *\n         * _.isArray(_.noop);\n         * // => false\n         */\n        var isArray = Array.isArray;\n        /**\n         * Checks if `value` is classified as an `ArrayBuffer` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.3.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n         * @example\n         *\n         * _.isArrayBuffer(new ArrayBuffer(2));\n         * // => true\n         *\n         * _.isArrayBuffer(new Array(2));\n         * // => false\n         */\n        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n        /**\n         * Checks if `value` is array-like. A value is considered array-like if it's\n         * not a function and has a `value.length` that's an integer greater than or\n         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n         * @example\n         *\n         * _.isArrayLike([1, 2, 3]);\n         * // => true\n         *\n         * _.isArrayLike(document.body.children);\n         * // => true\n         *\n         * _.isArrayLike('abc');\n         * // => true\n         *\n         * _.isArrayLike(_.noop);\n         * // => false\n         */\n        function isArrayLike(value) {\n            return value != null && isLength(value.length) && !isFunction(value);\n        }\n        /**\n         * This method is like `_.isArrayLike` except that it also checks if `value`\n         * is an object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an array-like object,\n         *  else `false`.\n         * @example\n         *\n         * _.isArrayLikeObject([1, 2, 3]);\n         * // => true\n         *\n         * _.isArrayLikeObject(document.body.children);\n         * // => true\n         *\n         * _.isArrayLikeObject('abc');\n         * // => false\n         *\n         * _.isArrayLikeObject(_.noop);\n         * // => false\n         */\n        function isArrayLikeObject(value) {\n            return isObjectLike(value) && isArrayLike(value);\n        }\n        /**\n         * Checks if `value` is classified as a boolean primitive or object.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n         * @example\n         *\n         * _.isBoolean(false);\n         * // => true\n         *\n         * _.isBoolean(null);\n         * // => false\n         */\n        function isBoolean(value) {\n            return value === true || value === false ||\n                (isObjectLike(value) && baseGetTag(value) == boolTag);\n        }\n        /**\n         * Checks if `value` is a buffer.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.3.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n         * @example\n         *\n         * _.isBuffer(new Buffer(2));\n         * // => true\n         *\n         * _.isBuffer(new Uint8Array(2));\n         * // => false\n         */\n        var isBuffer = nativeIsBuffer || stubFalse;\n        /**\n         * Checks if `value` is classified as a `Date` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n         * @example\n         *\n         * _.isDate(new Date);\n         * // => true\n         *\n         * _.isDate('Mon April 23 2012');\n         * // => false\n         */\n        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n        /**\n         * Checks if `value` is likely a DOM element.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n         * @example\n         *\n         * _.isElement(document.body);\n         * // => true\n         *\n         * _.isElement('<body>');\n         * // => false\n         */\n        function isElement(value) {\n            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n        }\n        /**\n         * Checks if `value` is an empty object, collection, map, or set.\n         *\n         * Objects are considered empty if they have no own enumerable string keyed\n         * properties.\n         *\n         * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n         * jQuery-like collections are considered empty if they have a `length` of `0`.\n         * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n         * @example\n         *\n         * _.isEmpty(null);\n         * // => true\n         *\n         * _.isEmpty(true);\n         * // => true\n         *\n         * _.isEmpty(1);\n         * // => true\n         *\n         * _.isEmpty([1, 2, 3]);\n         * // => false\n         *\n         * _.isEmpty({ 'a': 1 });\n         * // => false\n         */\n        function isEmpty(value) {\n            if (value == null) {\n                return true;\n            }\n            if (isArrayLike(value) &&\n                (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n                    isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n                return !value.length;\n            }\n            var tag = getTag(value);\n            if (tag == mapTag || tag == setTag) {\n                return !value.size;\n            }\n            if (isPrototype(value)) {\n                return !baseKeys(value).length;\n            }\n            for (var key in value) {\n                if (hasOwnProperty.call(value, key)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /**\n         * Performs a deep comparison between two values to determine if they are\n         * equivalent.\n         *\n         * **Note:** This method supports comparing arrays, array buffers, booleans,\n         * date objects, error objects, maps, numbers, `Object` objects, regexes,\n         * sets, strings, symbols, and typed arrays. `Object` objects are compared\n         * by their own, not inherited, enumerable properties. Functions and DOM\n         * nodes are **not** supported.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * var object = { 'a': 1 };\n         * var other = { 'a': 1 };\n         *\n         * _.isEqual(object, other);\n         * // => true\n         *\n         * object === other;\n         * // => false\n         */\n        function isEqual(value, other) {\n            return baseIsEqual(value, other);\n        }\n        /**\n         * This method is like `_.isEqual` except that it accepts `customizer` which\n         * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n         * are handled by the method instead. The `customizer` is invoked with up to\n         * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @param {Function} [customizer] The function to customize comparisons.\n         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n         * @example\n         *\n         * function isGreeting(value) {\n         *   return /^h(?:i|ello)$/.test(value);\n         * }\n         *\n         * function customizer(objValue, othValue) {\n         *   if (isGreeting(objValue) && isGreeting(othValue)) {\n         *     return true;\n         *   }\n         * }\n         *\n         * var array = ['hello', 'goodbye'];\n         * var other = ['hi', 'goodbye'];\n         *\n         * _.isEqualWith(array, other, customizer);\n         * // => true\n         */\n        function isEqualWith(value, other, customizer) {\n            customizer = typeof customizer == 'function' ? customizer : undefined;\n            var result = customizer ? customizer(value, other) : undefined;\n            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n        }\n        /**\n         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n         * `SyntaxError`, `TypeError`, or `URIError` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n         * @example\n         *\n         * _.isError(new Error);\n         * // => true\n         *\n         * _.isError(Error);\n         * // => false\n         */\n        function isError(value) {\n            if (!isObjectLike(value)) {\n                return false;\n            }\n            var tag = baseGetTag(value);\n            return tag == errorTag || tag == domExcTag ||\n                (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n        }\n        /**\n         * Checks if `value` is a finite primitive number.\n         *\n         * **Note:** This method is based on\n         * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n         * @example\n         *\n         * _.isFinite(3);\n         * // => true\n         *\n         * _.isFinite(Number.MIN_VALUE);\n         * // => true\n         *\n         * _.isFinite(Infinity);\n         * // => false\n         *\n         * _.isFinite('3');\n         * // => false\n         */\n        function isFinite(value) {\n            return typeof value == 'number' && nativeIsFinite(value);\n        }\n        /**\n         * Checks if `value` is classified as a `Function` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n         * @example\n         *\n         * _.isFunction(_);\n         * // => true\n         *\n         * _.isFunction(/abc/);\n         * // => false\n         */\n        function isFunction(value) {\n            if (!isObject(value)) {\n                return false;\n            }\n            // The use of `Object#toString` avoids issues with the `typeof` operator\n            // in Safari 9 which returns 'object' for typed arrays and other constructors.\n            var tag = baseGetTag(value);\n            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n        }\n        /**\n         * Checks if `value` is an integer.\n         *\n         * **Note:** This method is based on\n         * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n         * @example\n         *\n         * _.isInteger(3);\n         * // => true\n         *\n         * _.isInteger(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isInteger(Infinity);\n         * // => false\n         *\n         * _.isInteger('3');\n         * // => false\n         */\n        function isInteger(value) {\n            return typeof value == 'number' && value == toInteger(value);\n        }\n        /**\n         * Checks if `value` is a valid array-like length.\n         *\n         * **Note:** This method is loosely based on\n         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n         * @example\n         *\n         * _.isLength(3);\n         * // => true\n         *\n         * _.isLength(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isLength(Infinity);\n         * // => false\n         *\n         * _.isLength('3');\n         * // => false\n         */\n        function isLength(value) {\n            return typeof value == 'number' &&\n                value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n        }\n        /**\n         * Checks if `value` is the\n         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n         * @example\n         *\n         * _.isObject({});\n         * // => true\n         *\n         * _.isObject([1, 2, 3]);\n         * // => true\n         *\n         * _.isObject(_.noop);\n         * // => true\n         *\n         * _.isObject(null);\n         * // => false\n         */\n        function isObject(value) {\n            var type = typeof value;\n            return value != null && (type == 'object' || type == 'function');\n        }\n        /**\n         * Checks if `value` is object-like. A value is object-like if it's not `null`\n         * and has a `typeof` result of \"object\".\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n         * @example\n         *\n         * _.isObjectLike({});\n         * // => true\n         *\n         * _.isObjectLike([1, 2, 3]);\n         * // => true\n         *\n         * _.isObjectLike(_.noop);\n         * // => false\n         *\n         * _.isObjectLike(null);\n         * // => false\n         */\n        function isObjectLike(value) {\n            return value != null && typeof value == 'object';\n        }\n        /**\n         * Checks if `value` is classified as a `Map` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.3.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n         * @example\n         *\n         * _.isMap(new Map);\n         * // => true\n         *\n         * _.isMap(new WeakMap);\n         * // => false\n         */\n        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n        /**\n         * Performs a partial deep comparison between `object` and `source` to\n         * determine if `object` contains equivalent property values.\n         *\n         * **Note:** This method is equivalent to `_.matches` when `source` is\n         * partially applied.\n         *\n         * Partial comparisons will match empty array and empty object `source`\n         * values against any array or object value, respectively. See `_.isEqual`\n         * for a list of supported value comparisons.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Lang\n         * @param {Object} object The object to inspect.\n         * @param {Object} source The object of property values to match.\n         * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': 2 };\n         *\n         * _.isMatch(object, { 'b': 2 });\n         * // => true\n         *\n         * _.isMatch(object, { 'b': 1 });\n         * // => false\n         */\n        function isMatch(object, source) {\n            return object === source || baseIsMatch(object, source, getMatchData(source));\n        }\n        /**\n         * This method is like `_.isMatch` except that it accepts `customizer` which\n         * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n         * are handled by the method instead. The `customizer` is invoked with five\n         * arguments: (objValue, srcValue, index|key, object, source).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {Object} object The object to inspect.\n         * @param {Object} source The object of property values to match.\n         * @param {Function} [customizer] The function to customize comparisons.\n         * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n         * @example\n         *\n         * function isGreeting(value) {\n         *   return /^h(?:i|ello)$/.test(value);\n         * }\n         *\n         * function customizer(objValue, srcValue) {\n         *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n         *     return true;\n         *   }\n         * }\n         *\n         * var object = { 'greeting': 'hello' };\n         * var source = { 'greeting': 'hi' };\n         *\n         * _.isMatchWith(object, source, customizer);\n         * // => true\n         */\n        function isMatchWith(object, source, customizer) {\n            customizer = typeof customizer == 'function' ? customizer : undefined;\n            return baseIsMatch(object, source, getMatchData(source), customizer);\n        }\n        /**\n         * Checks if `value` is `NaN`.\n         *\n         * **Note:** This method is based on\n         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n         * `undefined` and other non-number values.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n         * @example\n         *\n         * _.isNaN(NaN);\n         * // => true\n         *\n         * _.isNaN(new Number(NaN));\n         * // => true\n         *\n         * isNaN(undefined);\n         * // => true\n         *\n         * _.isNaN(undefined);\n         * // => false\n         */\n        function isNaN(value) {\n            // An `NaN` primitive is the only value that is not equal to itself.\n            // Perform the `toStringTag` check first to avoid errors with some\n            // ActiveX objects in IE.\n            return isNumber(value) && value != +value;\n        }\n        /**\n         * Checks if `value` is a pristine native function.\n         *\n         * **Note:** This method can't reliably detect native functions in the presence\n         * of the core-js package because core-js circumvents this kind of detection.\n         * Despite multiple requests, the core-js maintainer has made it clear: any\n         * attempt to fix the detection will be obstructed. As a result, we're left\n         * with little choice but to throw an error. Unfortunately, this also affects\n         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n         * which rely on core-js.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a native function,\n         *  else `false`.\n         * @example\n         *\n         * _.isNative(Array.prototype.push);\n         * // => true\n         *\n         * _.isNative(_);\n         * // => false\n         */\n        function isNative(value) {\n            if (isMaskable(value)) {\n                throw new Error(CORE_ERROR_TEXT);\n            }\n            return baseIsNative(value);\n        }\n        /**\n         * Checks if `value` is `null`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n         * @example\n         *\n         * _.isNull(null);\n         * // => true\n         *\n         * _.isNull(void 0);\n         * // => false\n         */\n        function isNull(value) {\n            return value === null;\n        }\n        /**\n         * Checks if `value` is `null` or `undefined`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n         * @example\n         *\n         * _.isNil(null);\n         * // => true\n         *\n         * _.isNil(void 0);\n         * // => true\n         *\n         * _.isNil(NaN);\n         * // => false\n         */\n        function isNil(value) {\n            return value == null;\n        }\n        /**\n         * Checks if `value` is classified as a `Number` primitive or object.\n         *\n         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n         * classified as numbers, use the `_.isFinite` method.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n         * @example\n         *\n         * _.isNumber(3);\n         * // => true\n         *\n         * _.isNumber(Number.MIN_VALUE);\n         * // => true\n         *\n         * _.isNumber(Infinity);\n         * // => true\n         *\n         * _.isNumber('3');\n         * // => false\n         */\n        function isNumber(value) {\n            return typeof value == 'number' ||\n                (isObjectLike(value) && baseGetTag(value) == numberTag);\n        }\n        /**\n         * Checks if `value` is a plain object, that is, an object created by the\n         * `Object` constructor or one with a `[[Prototype]]` of `null`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.8.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         * }\n         *\n         * _.isPlainObject(new Foo);\n         * // => false\n         *\n         * _.isPlainObject([1, 2, 3]);\n         * // => false\n         *\n         * _.isPlainObject({ 'x': 0, 'y': 0 });\n         * // => true\n         *\n         * _.isPlainObject(Object.create(null));\n         * // => true\n         */\n        function isPlainObject(value) {\n            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n                return false;\n            }\n            var proto = getPrototype(value);\n            if (proto === null) {\n                return true;\n            }\n            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n            return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n                funcToString.call(Ctor) == objectCtorString;\n        }\n        /**\n         * Checks if `value` is classified as a `RegExp` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.1.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n         * @example\n         *\n         * _.isRegExp(/abc/);\n         * // => true\n         *\n         * _.isRegExp('/abc/');\n         * // => false\n         */\n        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n        /**\n         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n         * double precision number which isn't the result of a rounded unsafe integer.\n         *\n         * **Note:** This method is based on\n         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n         * @example\n         *\n         * _.isSafeInteger(3);\n         * // => true\n         *\n         * _.isSafeInteger(Number.MIN_VALUE);\n         * // => false\n         *\n         * _.isSafeInteger(Infinity);\n         * // => false\n         *\n         * _.isSafeInteger('3');\n         * // => false\n         */\n        function isSafeInteger(value) {\n            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n        }\n        /**\n         * Checks if `value` is classified as a `Set` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.3.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n         * @example\n         *\n         * _.isSet(new Set);\n         * // => true\n         *\n         * _.isSet(new WeakSet);\n         * // => false\n         */\n        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n        /**\n         * Checks if `value` is classified as a `String` primitive or object.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n         * @example\n         *\n         * _.isString('abc');\n         * // => true\n         *\n         * _.isString(1);\n         * // => false\n         */\n        function isString(value) {\n            return typeof value == 'string' ||\n                (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n        }\n        /**\n         * Checks if `value` is classified as a `Symbol` primitive or object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n         * @example\n         *\n         * _.isSymbol(Symbol.iterator);\n         * // => true\n         *\n         * _.isSymbol('abc');\n         * // => false\n         */\n        function isSymbol(value) {\n            return typeof value == 'symbol' ||\n                (isObjectLike(value) && baseGetTag(value) == symbolTag);\n        }\n        /**\n         * Checks if `value` is classified as a typed array.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n         * @example\n         *\n         * _.isTypedArray(new Uint8Array);\n         * // => true\n         *\n         * _.isTypedArray([]);\n         * // => false\n         */\n        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n        /**\n         * Checks if `value` is `undefined`.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n         * @example\n         *\n         * _.isUndefined(void 0);\n         * // => true\n         *\n         * _.isUndefined(null);\n         * // => false\n         */\n        function isUndefined(value) {\n            return value === undefined;\n        }\n        /**\n         * Checks if `value` is classified as a `WeakMap` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.3.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n         * @example\n         *\n         * _.isWeakMap(new WeakMap);\n         * // => true\n         *\n         * _.isWeakMap(new Map);\n         * // => false\n         */\n        function isWeakMap(value) {\n            return isObjectLike(value) && getTag(value) == weakMapTag;\n        }\n        /**\n         * Checks if `value` is classified as a `WeakSet` object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.3.0\n         * @category Lang\n         * @param {*} value The value to check.\n         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n         * @example\n         *\n         * _.isWeakSet(new WeakSet);\n         * // => true\n         *\n         * _.isWeakSet(new Set);\n         * // => false\n         */\n        function isWeakSet(value) {\n            return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n        }\n        /**\n         * Checks if `value` is less than `other`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.9.0\n         * @category Lang\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if `value` is less than `other`,\n         *  else `false`.\n         * @see _.gt\n         * @example\n         *\n         * _.lt(1, 3);\n         * // => true\n         *\n         * _.lt(3, 3);\n         * // => false\n         *\n         * _.lt(3, 1);\n         * // => false\n         */\n        var lt = createRelationalOperation(baseLt);\n        /**\n         * Checks if `value` is less than or equal to `other`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.9.0\n         * @category Lang\n         * @param {*} value The value to compare.\n         * @param {*} other The other value to compare.\n         * @returns {boolean} Returns `true` if `value` is less than or equal to\n         *  `other`, else `false`.\n         * @see _.gte\n         * @example\n         *\n         * _.lte(1, 3);\n         * // => true\n         *\n         * _.lte(3, 3);\n         * // => true\n         *\n         * _.lte(3, 1);\n         * // => false\n         */\n        var lte = createRelationalOperation(function (value, other) {\n            return value <= other;\n        });\n        /**\n         * Converts `value` to an array.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Lang\n         * @param {*} value The value to convert.\n         * @returns {Array} Returns the converted array.\n         * @example\n         *\n         * _.toArray({ 'a': 1, 'b': 2 });\n         * // => [1, 2]\n         *\n         * _.toArray('abc');\n         * // => ['a', 'b', 'c']\n         *\n         * _.toArray(1);\n         * // => []\n         *\n         * _.toArray(null);\n         * // => []\n         */\n        function toArray(value) {\n            if (!value) {\n                return [];\n            }\n            if (isArrayLike(value)) {\n                return isString(value) ? stringToArray(value) : copyArray(value);\n            }\n            if (symIterator && value[symIterator]) {\n                return iteratorToArray(value[symIterator]());\n            }\n            var tag = getTag(value), func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n            return func(value);\n        }\n        /**\n         * Converts `value` to a finite number.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.12.0\n         * @category Lang\n         * @param {*} value The value to convert.\n         * @returns {number} Returns the converted number.\n         * @example\n         *\n         * _.toFinite(3.2);\n         * // => 3.2\n         *\n         * _.toFinite(Number.MIN_VALUE);\n         * // => 5e-324\n         *\n         * _.toFinite(Infinity);\n         * // => 1.7976931348623157e+308\n         *\n         * _.toFinite('3.2');\n         * // => 3.2\n         */\n        function toFinite(value) {\n            if (!value) {\n                return value === 0 ? value : 0;\n            }\n            value = toNumber(value);\n            if (value === INFINITY || value === -INFINITY) {\n                var sign = (value < 0 ? -1 : 1);\n                return sign * MAX_INTEGER;\n            }\n            return value === value ? value : 0;\n        }\n        /**\n         * Converts `value` to an integer.\n         *\n         * **Note:** This method is loosely based on\n         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to convert.\n         * @returns {number} Returns the converted integer.\n         * @example\n         *\n         * _.toInteger(3.2);\n         * // => 3\n         *\n         * _.toInteger(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toInteger(Infinity);\n         * // => 1.7976931348623157e+308\n         *\n         * _.toInteger('3.2');\n         * // => 3\n         */\n        function toInteger(value) {\n            var result = toFinite(value), remainder = result % 1;\n            return result === result ? (remainder ? result - remainder : result) : 0;\n        }\n        /**\n         * Converts `value` to an integer suitable for use as the length of an\n         * array-like object.\n         *\n         * **Note:** This method is based on\n         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to convert.\n         * @returns {number} Returns the converted integer.\n         * @example\n         *\n         * _.toLength(3.2);\n         * // => 3\n         *\n         * _.toLength(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toLength(Infinity);\n         * // => 4294967295\n         *\n         * _.toLength('3.2');\n         * // => 3\n         */\n        function toLength(value) {\n            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n        }\n        /**\n         * Converts `value` to a number.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to process.\n         * @returns {number} Returns the number.\n         * @example\n         *\n         * _.toNumber(3.2);\n         * // => 3.2\n         *\n         * _.toNumber(Number.MIN_VALUE);\n         * // => 5e-324\n         *\n         * _.toNumber(Infinity);\n         * // => Infinity\n         *\n         * _.toNumber('3.2');\n         * // => 3.2\n         */\n        function toNumber(value) {\n            if (typeof value == 'number') {\n                return value;\n            }\n            if (isSymbol(value)) {\n                return NAN;\n            }\n            if (isObject(value)) {\n                var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n                value = isObject(other) ? (other + '') : other;\n            }\n            if (typeof value != 'string') {\n                return value === 0 ? value : +value;\n            }\n            value = value.replace(reTrim, '');\n            var isBinary = reIsBinary.test(value);\n            return (isBinary || reIsOctal.test(value))\n                ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n                : (reIsBadHex.test(value) ? NAN : +value);\n        }\n        /**\n         * Converts `value` to a plain object flattening inherited enumerable string\n         * keyed properties of `value` to own properties of the plain object.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Lang\n         * @param {*} value The value to convert.\n         * @returns {Object} Returns the converted plain object.\n         * @example\n         *\n         * function Foo() {\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.assign({ 'a': 1 }, new Foo);\n         * // => { 'a': 1, 'b': 2 }\n         *\n         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n         * // => { 'a': 1, 'b': 2, 'c': 3 }\n         */\n        function toPlainObject(value) {\n            return copyObject(value, keysIn(value));\n        }\n        /**\n         * Converts `value` to a safe integer. A safe integer can be compared and\n         * represented correctly.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to convert.\n         * @returns {number} Returns the converted integer.\n         * @example\n         *\n         * _.toSafeInteger(3.2);\n         * // => 3\n         *\n         * _.toSafeInteger(Number.MIN_VALUE);\n         * // => 0\n         *\n         * _.toSafeInteger(Infinity);\n         * // => 9007199254740991\n         *\n         * _.toSafeInteger('3.2');\n         * // => 3\n         */\n        function toSafeInteger(value) {\n            return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n        }\n        /**\n         * Converts `value` to a string. An empty string is returned for `null`\n         * and `undefined` values. The sign of `-0` is preserved.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Lang\n         * @param {*} value The value to convert.\n         * @returns {string} Returns the converted string.\n         * @example\n         *\n         * _.toString(null);\n         * // => ''\n         *\n         * _.toString(-0);\n         * // => '-0'\n         *\n         * _.toString([1, 2, 3]);\n         * // => '1,2,3'\n         */\n        function toString(value) {\n            return value == null ? '' : baseToString(value);\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Assigns own enumerable string keyed properties of source objects to the\n         * destination object. Source objects are applied from left to right.\n         * Subsequent sources overwrite property assignments of previous sources.\n         *\n         * **Note:** This method mutates `object` and is loosely based on\n         * [`Object.assign`](https://mdn.io/Object/assign).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.10.0\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} [sources] The source objects.\n         * @returns {Object} Returns `object`.\n         * @see _.assignIn\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         * }\n         *\n         * function Bar() {\n         *   this.c = 3;\n         * }\n         *\n         * Foo.prototype.b = 2;\n         * Bar.prototype.d = 4;\n         *\n         * _.assign({ 'a': 0 }, new Foo, new Bar);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        var assign = createAssigner(function (object, source) {\n            if (isPrototype(source) || isArrayLike(source)) {\n                copyObject(source, keys(source), object);\n                return;\n            }\n            for (var key in source) {\n                if (hasOwnProperty.call(source, key)) {\n                    assignValue(object, key, source[key]);\n                }\n            }\n        });\n        /**\n         * This method is like `_.assign` except that it iterates over own and\n         * inherited source properties.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @alias extend\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} [sources] The source objects.\n         * @returns {Object} Returns `object`.\n         * @see _.assign\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         * }\n         *\n         * function Bar() {\n         *   this.c = 3;\n         * }\n         *\n         * Foo.prototype.b = 2;\n         * Bar.prototype.d = 4;\n         *\n         * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n         */\n        var assignIn = createAssigner(function (object, source) {\n            copyObject(source, keysIn(source), object);\n        });\n        /**\n         * This method is like `_.assignIn` except that it accepts `customizer`\n         * which is invoked to produce the assigned values. If `customizer` returns\n         * `undefined`, assignment is handled by the method instead. The `customizer`\n         * is invoked with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @alias extendWith\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} sources The source objects.\n         * @param {Function} [customizer] The function to customize assigned values.\n         * @returns {Object} Returns `object`.\n         * @see _.assignWith\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignInWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {\n            copyObject(source, keysIn(source), object, customizer);\n        });\n        /**\n         * This method is like `_.assign` except that it accepts `customizer`\n         * which is invoked to produce the assigned values. If `customizer` returns\n         * `undefined`, assignment is handled by the method instead. The `customizer`\n         * is invoked with five arguments: (objValue, srcValue, key, object, source).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} sources The source objects.\n         * @param {Function} [customizer] The function to customize assigned values.\n         * @returns {Object} Returns `object`.\n         * @see _.assignInWith\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   return _.isUndefined(objValue) ? srcValue : objValue;\n         * }\n         *\n         * var defaults = _.partialRight(_.assignWith, customizer);\n         *\n         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        var assignWith = createAssigner(function (object, source, srcIndex, customizer) {\n            copyObject(source, keys(source), object, customizer);\n        });\n        /**\n         * Creates an array of values corresponding to `paths` of `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.0.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {...(string|string[])} [paths] The property paths to pick.\n         * @returns {Array} Returns the picked values.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n         *\n         * _.at(object, ['a[0].b.c', 'a[1]']);\n         * // => [3, 4]\n         */\n        var at = flatRest(baseAt);\n        /**\n         * Creates an object that inherits from the `prototype` object. If a\n         * `properties` object is given, its own enumerable string keyed properties\n         * are assigned to the created object.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.3.0\n         * @category Object\n         * @param {Object} prototype The object to inherit from.\n         * @param {Object} [properties] The properties to assign to the object.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * function Shape() {\n         *   this.x = 0;\n         *   this.y = 0;\n         * }\n         *\n         * function Circle() {\n         *   Shape.call(this);\n         * }\n         *\n         * Circle.prototype = _.create(Shape.prototype, {\n         *   'constructor': Circle\n         * });\n         *\n         * var circle = new Circle;\n         * circle instanceof Circle;\n         * // => true\n         *\n         * circle instanceof Shape;\n         * // => true\n         */\n        function create(prototype, properties) {\n            var result = baseCreate(prototype);\n            return properties == null ? result : baseAssign(result, properties);\n        }\n        /**\n         * Assigns own and inherited enumerable string keyed properties of source\n         * objects to the destination object for all destination properties that\n         * resolve to `undefined`. Source objects are applied from left to right.\n         * Once a property is set, additional values of the same property are ignored.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} [sources] The source objects.\n         * @returns {Object} Returns `object`.\n         * @see _.defaultsDeep\n         * @example\n         *\n         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n         * // => { 'a': 1, 'b': 2 }\n         */\n        var defaults = baseRest(function (args) {\n            args.push(undefined, assignInDefaults);\n            return apply(assignInWith, undefined, args);\n        });\n        /**\n         * This method is like `_.defaults` except that it recursively assigns\n         * default properties.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.10.0\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} [sources] The source objects.\n         * @returns {Object} Returns `object`.\n         * @see _.defaults\n         * @example\n         *\n         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n         * // => { 'a': { 'b': 2, 'c': 3 } }\n         */\n        var defaultsDeep = baseRest(function (args) {\n            args.push(undefined, mergeDefaults);\n            return apply(mergeWith, undefined, args);\n        });\n        /**\n         * This method is like `_.find` except that it returns the key of the first\n         * element `predicate` returns truthy for instead of the element itself.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.1.0\n         * @category Object\n         * @param {Object} object The object to inspect.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {string|undefined} Returns the key of the matched element,\n         *  else `undefined`.\n         * @example\n         *\n         * var users = {\n         *   'barney':  { 'age': 36, 'active': true },\n         *   'fred':    { 'age': 40, 'active': false },\n         *   'pebbles': { 'age': 1,  'active': true }\n         * };\n         *\n         * _.findKey(users, function(o) { return o.age < 40; });\n         * // => 'barney' (iteration order is not guaranteed)\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.findKey(users, { 'age': 1, 'active': true });\n         * // => 'pebbles'\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.findKey(users, ['active', false]);\n         * // => 'fred'\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.findKey(users, 'active');\n         * // => 'barney'\n         */\n        function findKey(object, predicate) {\n            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n        }\n        /**\n         * This method is like `_.findKey` except that it iterates over elements of\n         * a collection in the opposite order.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Object\n         * @param {Object} object The object to inspect.\n         * @param {Function} [predicate=_.identity] The function invoked per iteration.\n         * @returns {string|undefined} Returns the key of the matched element,\n         *  else `undefined`.\n         * @example\n         *\n         * var users = {\n         *   'barney':  { 'age': 36, 'active': true },\n         *   'fred':    { 'age': 40, 'active': false },\n         *   'pebbles': { 'age': 1,  'active': true }\n         * };\n         *\n         * _.findLastKey(users, function(o) { return o.age < 40; });\n         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.findLastKey(users, { 'age': 36, 'active': true });\n         * // => 'barney'\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.findLastKey(users, ['active', false]);\n         * // => 'fred'\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.findLastKey(users, 'active');\n         * // => 'pebbles'\n         */\n        function findLastKey(object, predicate) {\n            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n        }\n        /**\n         * Iterates over own and inherited enumerable string keyed properties of an\n         * object and invokes `iteratee` for each property. The iteratee is invoked\n         * with three arguments: (value, key, object). Iteratee functions may exit\n         * iteration early by explicitly returning `false`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.3.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Object} Returns `object`.\n         * @see _.forInRight\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.forIn(new Foo, function(value, key) {\n         *   console.log(key);\n         * });\n         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n         */\n        function forIn(object, iteratee) {\n            return object == null\n                ? object\n                : baseFor(object, getIteratee(iteratee, 3), keysIn);\n        }\n        /**\n         * This method is like `_.forIn` except that it iterates over properties of\n         * `object` in the opposite order.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Object} Returns `object`.\n         * @see _.forIn\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.forInRight(new Foo, function(value, key) {\n         *   console.log(key);\n         * });\n         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n         */\n        function forInRight(object, iteratee) {\n            return object == null\n                ? object\n                : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n        }\n        /**\n         * Iterates over own enumerable string keyed properties of an object and\n         * invokes `iteratee` for each property. The iteratee is invoked with three\n         * arguments: (value, key, object). Iteratee functions may exit iteration\n         * early by explicitly returning `false`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.3.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Object} Returns `object`.\n         * @see _.forOwnRight\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.forOwn(new Foo, function(value, key) {\n         *   console.log(key);\n         * });\n         * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n         */\n        function forOwn(object, iteratee) {\n            return object && baseForOwn(object, getIteratee(iteratee, 3));\n        }\n        /**\n         * This method is like `_.forOwn` except that it iterates over properties of\n         * `object` in the opposite order.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.0.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Object} Returns `object`.\n         * @see _.forOwn\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.forOwnRight(new Foo, function(value, key) {\n         *   console.log(key);\n         * });\n         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n         */\n        function forOwnRight(object, iteratee) {\n            return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n        }\n        /**\n         * Creates an array of function property names from own enumerable properties\n         * of `object`.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The object to inspect.\n         * @returns {Array} Returns the function names.\n         * @see _.functionsIn\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functions(new Foo);\n         * // => ['a', 'b']\n         */\n        function functions(object) {\n            return object == null ? [] : baseFunctions(object, keys(object));\n        }\n        /**\n         * Creates an array of function property names from own and inherited\n         * enumerable properties of `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The object to inspect.\n         * @returns {Array} Returns the function names.\n         * @see _.functions\n         * @example\n         *\n         * function Foo() {\n         *   this.a = _.constant('a');\n         *   this.b = _.constant('b');\n         * }\n         *\n         * Foo.prototype.c = _.constant('c');\n         *\n         * _.functionsIn(new Foo);\n         * // => ['a', 'b', 'c']\n         */\n        function functionsIn(object) {\n            return object == null ? [] : baseFunctions(object, keysIn(object));\n        }\n        /**\n         * Gets the value at `path` of `object`. If the resolved value is\n         * `undefined`, the `defaultValue` is returned in its place.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.7.0\n         * @category Object\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path of the property to get.\n         * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n         * @returns {*} Returns the resolved value.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n         *\n         * _.get(object, 'a[0].b.c');\n         * // => 3\n         *\n         * _.get(object, ['a', '0', 'b', 'c']);\n         * // => 3\n         *\n         * _.get(object, 'a.b.c', 'default');\n         * // => 'default'\n         */\n        function get(object, path, defaultValue) {\n            var result = object == null ? undefined : baseGet(object, path);\n            return result === undefined ? defaultValue : result;\n        }\n        /**\n         * Checks if `path` is a direct property of `object`.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path to check.\n         * @returns {boolean} Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = { 'a': { 'b': 2 } };\n         * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n         *\n         * _.has(object, 'a');\n         * // => true\n         *\n         * _.has(object, 'a.b');\n         * // => true\n         *\n         * _.has(object, ['a', 'b']);\n         * // => true\n         *\n         * _.has(other, 'a');\n         * // => false\n         */\n        function has(object, path) {\n            return object != null && hasPath(object, path, baseHas);\n        }\n        /**\n         * Checks if `path` is a direct or inherited property of `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path to check.\n         * @returns {boolean} Returns `true` if `path` exists, else `false`.\n         * @example\n         *\n         * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n         *\n         * _.hasIn(object, 'a');\n         * // => true\n         *\n         * _.hasIn(object, 'a.b');\n         * // => true\n         *\n         * _.hasIn(object, ['a', 'b']);\n         * // => true\n         *\n         * _.hasIn(object, 'b');\n         * // => false\n         */\n        function hasIn(object, path) {\n            return object != null && hasPath(object, path, baseHasIn);\n        }\n        /**\n         * Creates an object composed of the inverted keys and values of `object`.\n         * If `object` contains duplicate values, subsequent values overwrite\n         * property assignments of previous values.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.7.0\n         * @category Object\n         * @param {Object} object The object to invert.\n         * @returns {Object} Returns the new inverted object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': 2, 'c': 1 };\n         *\n         * _.invert(object);\n         * // => { '1': 'c', '2': 'b' }\n         */\n        var invert = createInverter(function (result, value, key) {\n            result[value] = key;\n        }, constant(identity));\n        /**\n         * This method is like `_.invert` except that the inverted object is generated\n         * from the results of running each element of `object` thru `iteratee`. The\n         * corresponding inverted value of each inverted key is an array of keys\n         * responsible for generating the inverted value. The iteratee is invoked\n         * with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.1.0\n         * @category Object\n         * @param {Object} object The object to invert.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {Object} Returns the new inverted object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': 2, 'c': 1 };\n         *\n         * _.invertBy(object);\n         * // => { '1': ['a', 'c'], '2': ['b'] }\n         *\n         * _.invertBy(object, function(value) {\n         *   return 'group' + value;\n         * });\n         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n         */\n        var invertBy = createInverter(function (result, value, key) {\n            if (hasOwnProperty.call(result, value)) {\n                result[value].push(key);\n            }\n            else {\n                result[value] = [key];\n            }\n        }, getIteratee);\n        /**\n         * Invokes the method at `path` of `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path of the method to invoke.\n         * @param {...*} [args] The arguments to invoke the method with.\n         * @returns {*} Returns the result of the invoked method.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n         *\n         * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n         * // => [2, 3]\n         */\n        var invoke = baseRest(baseInvoke);\n        /**\n         * Creates an array of the own enumerable property names of `object`.\n         *\n         * **Note:** Non-object values are coerced to objects. See the\n         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n         * for more details.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.keys(new Foo);\n         * // => ['a', 'b'] (iteration order is not guaranteed)\n         *\n         * _.keys('hi');\n         * // => ['0', '1']\n         */\n        function keys(object) {\n            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n        }\n        /**\n         * Creates an array of the own and inherited enumerable property names of `object`.\n         *\n         * **Note:** Non-object values are coerced to objects.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Object\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property names.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.keysIn(new Foo);\n         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n         */\n        function keysIn(object) {\n            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n        }\n        /**\n         * The opposite of `_.mapValues`; this method creates an object with the\n         * same values as `object` and keys generated by running each own enumerable\n         * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n         * with three arguments: (value, key, object).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.8.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Object} Returns the new mapped object.\n         * @see _.mapValues\n         * @example\n         *\n         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n         *   return key + value;\n         * });\n         * // => { 'a1': 1, 'b2': 2 }\n         */\n        function mapKeys(object, iteratee) {\n            var result = {};\n            iteratee = getIteratee(iteratee, 3);\n            baseForOwn(object, function (value, key, object) {\n                baseAssignValue(result, iteratee(value, key, object), value);\n            });\n            return result;\n        }\n        /**\n         * Creates an object with the same keys as `object` and values generated\n         * by running each own enumerable string keyed property of `object` thru\n         * `iteratee`. The iteratee is invoked with three arguments:\n         * (value, key, object).\n         *\n         * @static\n         * @memberOf _\n         * @since 2.4.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Object} Returns the new mapped object.\n         * @see _.mapKeys\n         * @example\n         *\n         * var users = {\n         *   'fred':    { 'user': 'fred',    'age': 40 },\n         *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n         * };\n         *\n         * _.mapValues(users, function(o) { return o.age; });\n         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.mapValues(users, 'age');\n         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n         */\n        function mapValues(object, iteratee) {\n            var result = {};\n            iteratee = getIteratee(iteratee, 3);\n            baseForOwn(object, function (value, key, object) {\n                baseAssignValue(result, key, iteratee(value, key, object));\n            });\n            return result;\n        }\n        /**\n         * This method is like `_.assign` except that it recursively merges own and\n         * inherited enumerable string keyed properties of source objects into the\n         * destination object. Source properties that resolve to `undefined` are\n         * skipped if a destination value exists. Array and plain object properties\n         * are merged recursively. Other objects and value types are overridden by\n         * assignment. Source objects are applied from left to right. Subsequent\n         * sources overwrite property assignments of previous sources.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.5.0\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} [sources] The source objects.\n         * @returns {Object} Returns `object`.\n         * @example\n         *\n         * var object = {\n         *   'a': [{ 'b': 2 }, { 'd': 4 }]\n         * };\n         *\n         * var other = {\n         *   'a': [{ 'c': 3 }, { 'e': 5 }]\n         * };\n         *\n         * _.merge(object, other);\n         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n         */\n        var merge = createAssigner(function (object, source, srcIndex) {\n            baseMerge(object, source, srcIndex);\n        });\n        /**\n         * This method is like `_.merge` except that it accepts `customizer` which\n         * is invoked to produce the merged values of the destination and source\n         * properties. If `customizer` returns `undefined`, merging is handled by the\n         * method instead. The `customizer` is invoked with six arguments:\n         * (objValue, srcValue, key, object, source, stack).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The destination object.\n         * @param {...Object} sources The source objects.\n         * @param {Function} customizer The function to customize assigned values.\n         * @returns {Object} Returns `object`.\n         * @example\n         *\n         * function customizer(objValue, srcValue) {\n         *   if (_.isArray(objValue)) {\n         *     return objValue.concat(srcValue);\n         *   }\n         * }\n         *\n         * var object = { 'a': [1], 'b': [2] };\n         * var other = { 'a': [3], 'b': [4] };\n         *\n         * _.mergeWith(object, other, customizer);\n         * // => { 'a': [1, 3], 'b': [2, 4] }\n         */\n        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {\n            baseMerge(object, source, srcIndex, customizer);\n        });\n        /**\n         * The opposite of `_.pick`; this method creates an object composed of the\n         * own and inherited enumerable property paths of `object` that are not omitted.\n         *\n         * **Note:** This method is considerably slower than `_.pick`.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The source object.\n         * @param {...(string|string[])} [paths] The property paths to omit.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omit(object, ['a', 'c']);\n         * // => { 'b': '2' }\n         */\n        var omit = flatRest(function (object, paths) {\n            var result = {};\n            if (object == null) {\n                return result;\n            }\n            var isDeep = false;\n            paths = arrayMap(paths, function (path) {\n                path = castPath(path, object);\n                isDeep || (isDeep = path.length > 1);\n                return path;\n            });\n            copyObject(object, getAllKeysIn(object), result);\n            if (isDeep) {\n                result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG);\n            }\n            var length = paths.length;\n            while (length--) {\n                baseUnset(result, paths[length]);\n            }\n            return result;\n        });\n        /**\n         * The opposite of `_.pickBy`; this method creates an object composed of\n         * the own and inherited enumerable string keyed properties of `object` that\n         * `predicate` doesn't return truthy for. The predicate is invoked with two\n         * arguments: (value, key).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The source object.\n         * @param {Function} [predicate=_.identity] The function invoked per property.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.omitBy(object, _.isNumber);\n         * // => { 'b': '2' }\n         */\n        function omitBy(object, predicate) {\n            return pickBy(object, negate(getIteratee(predicate)));\n        }\n        /**\n         * Creates an object composed of the picked `object` properties.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The source object.\n         * @param {...(string|string[])} [paths] The property paths to pick.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pick(object, ['a', 'c']);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        var pick = flatRest(function (object, paths) {\n            return object == null ? {} : basePick(object, paths);\n        });\n        /**\n         * Creates an object composed of the `object` properties `predicate` returns\n         * truthy for. The predicate is invoked with two arguments: (value, key).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The source object.\n         * @param {Function} [predicate=_.identity] The function invoked per property.\n         * @returns {Object} Returns the new object.\n         * @example\n         *\n         * var object = { 'a': 1, 'b': '2', 'c': 3 };\n         *\n         * _.pickBy(object, _.isNumber);\n         * // => { 'a': 1, 'c': 3 }\n         */\n        function pickBy(object, predicate) {\n            if (object == null) {\n                return {};\n            }\n            var props = arrayMap(getAllKeysIn(object), function (prop) {\n                return [prop];\n            });\n            predicate = getIteratee(predicate);\n            return basePickBy(object, props, function (value, path) {\n                return predicate(value, path[0]);\n            });\n        }\n        /**\n         * This method is like `_.get` except that if the resolved value is a\n         * function it's invoked with the `this` binding of its parent object and\n         * its result is returned.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The object to query.\n         * @param {Array|string} path The path of the property to resolve.\n         * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n         * @returns {*} Returns the resolved value.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n         *\n         * _.result(object, 'a[0].b.c1');\n         * // => 3\n         *\n         * _.result(object, 'a[0].b.c2');\n         * // => 4\n         *\n         * _.result(object, 'a[0].b.c3', 'default');\n         * // => 'default'\n         *\n         * _.result(object, 'a[0].b.c3', _.constant('default'));\n         * // => 'default'\n         */\n        function result(object, path, defaultValue) {\n            path = castPath(path, object);\n            var index = -1, length = path.length;\n            // Ensure the loop is entered when path is empty.\n            if (!length) {\n                length = 1;\n                object = undefined;\n            }\n            while (++index < length) {\n                var value = object == null ? undefined : object[toKey(path[index])];\n                if (value === undefined) {\n                    index = length;\n                    value = defaultValue;\n                }\n                object = isFunction(value) ? value.call(object) : value;\n            }\n            return object;\n        }\n        /**\n         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n         * it's created. Arrays are created for missing index properties while objects\n         * are created for all other missing properties. Use `_.setWith` to customize\n         * `path` creation.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.7.0\n         * @category Object\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The path of the property to set.\n         * @param {*} value The value to set.\n         * @returns {Object} Returns `object`.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n         *\n         * _.set(object, 'a[0].b.c', 4);\n         * console.log(object.a[0].b.c);\n         * // => 4\n         *\n         * _.set(object, ['x', '0', 'y', 'z'], 5);\n         * console.log(object.x[0].y.z);\n         * // => 5\n         */\n        function set(object, path, value) {\n            return object == null ? object : baseSet(object, path, value);\n        }\n        /**\n         * This method is like `_.set` except that it accepts `customizer` which is\n         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n         * path creation is handled by the method instead. The `customizer` is invoked\n         * with three arguments: (nsValue, key, nsObject).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The path of the property to set.\n         * @param {*} value The value to set.\n         * @param {Function} [customizer] The function to customize assigned values.\n         * @returns {Object} Returns `object`.\n         * @example\n         *\n         * var object = {};\n         *\n         * _.setWith(object, '[0][1]', 'a', Object);\n         * // => { '0': { '1': 'a' } }\n         */\n        function setWith(object, path, value, customizer) {\n            customizer = typeof customizer == 'function' ? customizer : undefined;\n            return object == null ? object : baseSet(object, path, value, customizer);\n        }\n        /**\n         * Creates an array of own enumerable string keyed-value pairs for `object`\n         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n         * entries are returned.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @alias entries\n         * @category Object\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the key-value pairs.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.toPairs(new Foo);\n         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n         */\n        var toPairs = createToPairs(keys);\n        /**\n         * Creates an array of own and inherited enumerable string keyed-value pairs\n         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n         * or set, its entries are returned.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @alias entriesIn\n         * @category Object\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the key-value pairs.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.toPairsIn(new Foo);\n         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n         */\n        var toPairsIn = createToPairs(keysIn);\n        /**\n         * An alternative to `_.reduce`; this method transforms `object` to a new\n         * `accumulator` object which is the result of running each of its own\n         * enumerable string keyed properties thru `iteratee`, with each invocation\n         * potentially mutating the `accumulator` object. If `accumulator` is not\n         * provided, a new object with the same `[[Prototype]]` will be used. The\n         * iteratee is invoked with four arguments: (accumulator, value, key, object).\n         * Iteratee functions may exit iteration early by explicitly returning `false`.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.3.0\n         * @category Object\n         * @param {Object} object The object to iterate over.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @param {*} [accumulator] The custom accumulator value.\n         * @returns {*} Returns the accumulated value.\n         * @example\n         *\n         * _.transform([2, 3, 4], function(result, n) {\n         *   result.push(n *= n);\n         *   return n % 2 == 0;\n         * }, []);\n         * // => [4, 9]\n         *\n         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n         *   (result[value] || (result[value] = [])).push(key);\n         * }, {});\n         * // => { '1': ['a', 'c'], '2': ['b'] }\n         */\n        function transform(object, iteratee, accumulator) {\n            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n            iteratee = getIteratee(iteratee, 4);\n            if (accumulator == null) {\n                var Ctor = object && object.constructor;\n                if (isArrLike) {\n                    accumulator = isArr ? new Ctor : [];\n                }\n                else if (isObject(object)) {\n                    accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n                }\n                else {\n                    accumulator = {};\n                }\n            }\n            (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {\n                return iteratee(accumulator, value, index, object);\n            });\n            return accumulator;\n        }\n        /**\n         * Removes the property at `path` of `object`.\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Object\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The path of the property to unset.\n         * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n         * _.unset(object, 'a[0].b.c');\n         * // => true\n         *\n         * console.log(object);\n         * // => { 'a': [{ 'b': {} }] };\n         *\n         * _.unset(object, ['a', '0', 'b', 'c']);\n         * // => true\n         *\n         * console.log(object);\n         * // => { 'a': [{ 'b': {} }] };\n         */\n        function unset(object, path) {\n            return object == null ? true : baseUnset(object, path);\n        }\n        /**\n         * This method is like `_.set` except that accepts `updater` to produce the\n         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n         * is invoked with one argument: (value).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.6.0\n         * @category Object\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The path of the property to set.\n         * @param {Function} updater The function to produce the updated value.\n         * @returns {Object} Returns `object`.\n         * @example\n         *\n         * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n         *\n         * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n         * console.log(object.a[0].b.c);\n         * // => 9\n         *\n         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n         * console.log(object.x[0].y.z);\n         * // => 0\n         */\n        function update(object, path, updater) {\n            return object == null ? object : baseUpdate(object, path, castFunction(updater));\n        }\n        /**\n         * This method is like `_.update` except that it accepts `customizer` which is\n         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n         * path creation is handled by the method instead. The `customizer` is invoked\n         * with three arguments: (nsValue, key, nsObject).\n         *\n         * **Note:** This method mutates `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.6.0\n         * @category Object\n         * @param {Object} object The object to modify.\n         * @param {Array|string} path The path of the property to set.\n         * @param {Function} updater The function to produce the updated value.\n         * @param {Function} [customizer] The function to customize assigned values.\n         * @returns {Object} Returns `object`.\n         * @example\n         *\n         * var object = {};\n         *\n         * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n         * // => { '0': { '1': 'a' } }\n         */\n        function updateWith(object, path, updater, customizer) {\n            customizer = typeof customizer == 'function' ? customizer : undefined;\n            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n        }\n        /**\n         * Creates an array of the own enumerable string keyed property values of `object`.\n         *\n         * **Note:** Non-object values are coerced to objects.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Object\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property values.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.values(new Foo);\n         * // => [1, 2] (iteration order is not guaranteed)\n         *\n         * _.values('hi');\n         * // => ['h', 'i']\n         */\n        function values(object) {\n            return object == null ? [] : baseValues(object, keys(object));\n        }\n        /**\n         * Creates an array of the own and inherited enumerable string keyed property\n         * values of `object`.\n         *\n         * **Note:** Non-object values are coerced to objects.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Object\n         * @param {Object} object The object to query.\n         * @returns {Array} Returns the array of property values.\n         * @example\n         *\n         * function Foo() {\n         *   this.a = 1;\n         *   this.b = 2;\n         * }\n         *\n         * Foo.prototype.c = 3;\n         *\n         * _.valuesIn(new Foo);\n         * // => [1, 2, 3] (iteration order is not guaranteed)\n         */\n        function valuesIn(object) {\n            return object == null ? [] : baseValues(object, keysIn(object));\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Clamps `number` within the inclusive `lower` and `upper` bounds.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Number\n         * @param {number} number The number to clamp.\n         * @param {number} [lower] The lower bound.\n         * @param {number} upper The upper bound.\n         * @returns {number} Returns the clamped number.\n         * @example\n         *\n         * _.clamp(-10, -5, 5);\n         * // => -5\n         *\n         * _.clamp(10, -5, 5);\n         * // => 5\n         */\n        function clamp(number, lower, upper) {\n            if (upper === undefined) {\n                upper = lower;\n                lower = undefined;\n            }\n            if (upper !== undefined) {\n                upper = toNumber(upper);\n                upper = upper === upper ? upper : 0;\n            }\n            if (lower !== undefined) {\n                lower = toNumber(lower);\n                lower = lower === lower ? lower : 0;\n            }\n            return baseClamp(toNumber(number), lower, upper);\n        }\n        /**\n         * Checks if `n` is between `start` and up to, but not including, `end`. If\n         * `end` is not specified, it's set to `start` with `start` then set to `0`.\n         * If `start` is greater than `end` the params are swapped to support\n         * negative ranges.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.3.0\n         * @category Number\n         * @param {number} number The number to check.\n         * @param {number} [start=0] The start of the range.\n         * @param {number} end The end of the range.\n         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n         * @see _.range, _.rangeRight\n         * @example\n         *\n         * _.inRange(3, 2, 4);\n         * // => true\n         *\n         * _.inRange(4, 8);\n         * // => true\n         *\n         * _.inRange(4, 2);\n         * // => false\n         *\n         * _.inRange(2, 2);\n         * // => false\n         *\n         * _.inRange(1.2, 2);\n         * // => true\n         *\n         * _.inRange(5.2, 4);\n         * // => false\n         *\n         * _.inRange(-3, -2, -6);\n         * // => true\n         */\n        function inRange(number, start, end) {\n            start = toFinite(start);\n            if (end === undefined) {\n                end = start;\n                start = 0;\n            }\n            else {\n                end = toFinite(end);\n            }\n            number = toNumber(number);\n            return baseInRange(number, start, end);\n        }\n        /**\n         * Produces a random number between the inclusive `lower` and `upper` bounds.\n         * If only one argument is provided a number between `0` and the given number\n         * is returned. If `floating` is `true`, or either `lower` or `upper` are\n         * floats, a floating-point number is returned instead of an integer.\n         *\n         * **Note:** JavaScript follows the IEEE-754 standard for resolving\n         * floating-point values which can produce unexpected results.\n         *\n         * @static\n         * @memberOf _\n         * @since 0.7.0\n         * @category Number\n         * @param {number} [lower=0] The lower bound.\n         * @param {number} [upper=1] The upper bound.\n         * @param {boolean} [floating] Specify returning a floating-point number.\n         * @returns {number} Returns the random number.\n         * @example\n         *\n         * _.random(0, 5);\n         * // => an integer between 0 and 5\n         *\n         * _.random(5);\n         * // => also an integer between 0 and 5\n         *\n         * _.random(5, true);\n         * // => a floating-point number between 0 and 5\n         *\n         * _.random(1.2, 5.2);\n         * // => a floating-point number between 1.2 and 5.2\n         */\n        function random(lower, upper, floating) {\n            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n                upper = floating = undefined;\n            }\n            if (floating === undefined) {\n                if (typeof upper == 'boolean') {\n                    floating = upper;\n                    upper = undefined;\n                }\n                else if (typeof lower == 'boolean') {\n                    floating = lower;\n                    lower = undefined;\n                }\n            }\n            if (lower === undefined && upper === undefined) {\n                lower = 0;\n                upper = 1;\n            }\n            else {\n                lower = toFinite(lower);\n                if (upper === undefined) {\n                    upper = lower;\n                    lower = 0;\n                }\n                else {\n                    upper = toFinite(upper);\n                }\n            }\n            if (lower > upper) {\n                var temp = lower;\n                lower = upper;\n                upper = temp;\n            }\n            if (floating || lower % 1 || upper % 1) {\n                var rand = nativeRandom();\n                return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n            }\n            return baseRandom(lower, upper);\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the camel cased string.\n         * @example\n         *\n         * _.camelCase('Foo Bar');\n         * // => 'fooBar'\n         *\n         * _.camelCase('--foo-bar--');\n         * // => 'fooBar'\n         *\n         * _.camelCase('__FOO_BAR__');\n         * // => 'fooBar'\n         */\n        var camelCase = createCompounder(function (result, word, index) {\n            word = word.toLowerCase();\n            return result + (index ? capitalize(word) : word);\n        });\n        /**\n         * Converts the first character of `string` to upper case and the remaining\n         * to lower case.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to capitalize.\n         * @returns {string} Returns the capitalized string.\n         * @example\n         *\n         * _.capitalize('FRED');\n         * // => 'Fred'\n         */\n        function capitalize(string) {\n            return upperFirst(toString(string).toLowerCase());\n        }\n        /**\n         * Deburrs `string` by converting\n         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n         * letters to basic Latin letters and removing\n         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to deburr.\n         * @returns {string} Returns the deburred string.\n         * @example\n         *\n         * _.deburr('dj vu');\n         * // => 'deja vu'\n         */\n        function deburr(string) {\n            string = toString(string);\n            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n        }\n        /**\n         * Checks if `string` ends with the given target string.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to inspect.\n         * @param {string} [target] The string to search for.\n         * @param {number} [position=string.length] The position to search up to.\n         * @returns {boolean} Returns `true` if `string` ends with `target`,\n         *  else `false`.\n         * @example\n         *\n         * _.endsWith('abc', 'c');\n         * // => true\n         *\n         * _.endsWith('abc', 'b');\n         * // => false\n         *\n         * _.endsWith('abc', 'b', 2);\n         * // => true\n         */\n        function endsWith(string, target, position) {\n            string = toString(string);\n            target = baseToString(target);\n            var length = string.length;\n            position = position === undefined\n                ? length\n                : baseClamp(toInteger(position), 0, length);\n            var end = position;\n            position -= target.length;\n            return position >= 0 && string.slice(position, end) == target;\n        }\n        /**\n         * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n         * corresponding HTML entities.\n         *\n         * **Note:** No other characters are escaped. To escape additional\n         * characters use a third-party library like [_he_](https://mths.be/he).\n         *\n         * Though the \">\" character is escaped for symmetry, characters like\n         * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n         * unless they're part of a tag or unquoted attribute value. See\n         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n         * (under \"semi-related fun fact\") for more details.\n         *\n         * When working with HTML you should always\n         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n         * XSS vectors.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category String\n         * @param {string} [string=''] The string to escape.\n         * @returns {string} Returns the escaped string.\n         * @example\n         *\n         * _.escape('fred, barney, & pebbles');\n         * // => 'fred, barney, &amp; pebbles'\n         */\n        function escape(string) {\n            string = toString(string);\n            return (string && reHasUnescapedHtml.test(string))\n                ? string.replace(reUnescapedHtml, escapeHtmlChar)\n                : string;\n        }\n        /**\n         * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n         * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to escape.\n         * @returns {string} Returns the escaped string.\n         * @example\n         *\n         * _.escapeRegExp('[lodash](https://lodash.com/)');\n         * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n         */\n        function escapeRegExp(string) {\n            string = toString(string);\n            return (string && reHasRegExpChar.test(string))\n                ? string.replace(reRegExpChar, '\\\\$&')\n                : string;\n        }\n        /**\n         * Converts `string` to\n         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the kebab cased string.\n         * @example\n         *\n         * _.kebabCase('Foo Bar');\n         * // => 'foo-bar'\n         *\n         * _.kebabCase('fooBar');\n         * // => 'foo-bar'\n         *\n         * _.kebabCase('__FOO_BAR__');\n         * // => 'foo-bar'\n         */\n        var kebabCase = createCompounder(function (result, word, index) {\n            return result + (index ? '-' : '') + word.toLowerCase();\n        });\n        /**\n         * Converts `string`, as space separated words, to lower case.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the lower cased string.\n         * @example\n         *\n         * _.lowerCase('--Foo-Bar--');\n         * // => 'foo bar'\n         *\n         * _.lowerCase('fooBar');\n         * // => 'foo bar'\n         *\n         * _.lowerCase('__FOO_BAR__');\n         * // => 'foo bar'\n         */\n        var lowerCase = createCompounder(function (result, word, index) {\n            return result + (index ? ' ' : '') + word.toLowerCase();\n        });\n        /**\n         * Converts the first character of `string` to lower case.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the converted string.\n         * @example\n         *\n         * _.lowerFirst('Fred');\n         * // => 'fred'\n         *\n         * _.lowerFirst('FRED');\n         * // => 'fRED'\n         */\n        var lowerFirst = createCaseFirst('toLowerCase');\n        /**\n         * Pads `string` on the left and right sides if it's shorter than `length`.\n         * Padding characters are truncated if they can't be evenly divided by `length`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to pad.\n         * @param {number} [length=0] The padding length.\n         * @param {string} [chars=' '] The string used as padding.\n         * @returns {string} Returns the padded string.\n         * @example\n         *\n         * _.pad('abc', 8);\n         * // => '  abc   '\n         *\n         * _.pad('abc', 8, '_-');\n         * // => '_-abc_-_'\n         *\n         * _.pad('abc', 3);\n         * // => 'abc'\n         */\n        function pad(string, length, chars) {\n            string = toString(string);\n            length = toInteger(length);\n            var strLength = length ? stringSize(string) : 0;\n            if (!length || strLength >= length) {\n                return string;\n            }\n            var mid = (length - strLength) / 2;\n            return (createPadding(nativeFloor(mid), chars) +\n                string +\n                createPadding(nativeCeil(mid), chars));\n        }\n        /**\n         * Pads `string` on the right side if it's shorter than `length`. Padding\n         * characters are truncated if they exceed `length`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to pad.\n         * @param {number} [length=0] The padding length.\n         * @param {string} [chars=' '] The string used as padding.\n         * @returns {string} Returns the padded string.\n         * @example\n         *\n         * _.padEnd('abc', 6);\n         * // => 'abc   '\n         *\n         * _.padEnd('abc', 6, '_-');\n         * // => 'abc_-_'\n         *\n         * _.padEnd('abc', 3);\n         * // => 'abc'\n         */\n        function padEnd(string, length, chars) {\n            string = toString(string);\n            length = toInteger(length);\n            var strLength = length ? stringSize(string) : 0;\n            return (length && strLength < length)\n                ? (string + createPadding(length - strLength, chars))\n                : string;\n        }\n        /**\n         * Pads `string` on the left side if it's shorter than `length`. Padding\n         * characters are truncated if they exceed `length`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to pad.\n         * @param {number} [length=0] The padding length.\n         * @param {string} [chars=' '] The string used as padding.\n         * @returns {string} Returns the padded string.\n         * @example\n         *\n         * _.padStart('abc', 6);\n         * // => '   abc'\n         *\n         * _.padStart('abc', 6, '_-');\n         * // => '_-_abc'\n         *\n         * _.padStart('abc', 3);\n         * // => 'abc'\n         */\n        function padStart(string, length, chars) {\n            string = toString(string);\n            length = toInteger(length);\n            var strLength = length ? stringSize(string) : 0;\n            return (length && strLength < length)\n                ? (createPadding(length - strLength, chars) + string)\n                : string;\n        }\n        /**\n         * Converts `string` to an integer of the specified radix. If `radix` is\n         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n         * hexadecimal, in which case a `radix` of `16` is used.\n         *\n         * **Note:** This method aligns with the\n         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n         *\n         * @static\n         * @memberOf _\n         * @since 1.1.0\n         * @category String\n         * @param {string} string The string to convert.\n         * @param {number} [radix=10] The radix to interpret `value` by.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {number} Returns the converted integer.\n         * @example\n         *\n         * _.parseInt('08');\n         * // => 8\n         *\n         * _.map(['6', '08', '10'], _.parseInt);\n         * // => [6, 8, 10]\n         */\n        function parseInt(string, radix, guard) {\n            if (guard || radix == null) {\n                radix = 0;\n            }\n            else if (radix) {\n                radix = +radix;\n            }\n            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n        }\n        /**\n         * Repeats the given string `n` times.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to repeat.\n         * @param {number} [n=1] The number of times to repeat the string.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {string} Returns the repeated string.\n         * @example\n         *\n         * _.repeat('*', 3);\n         * // => '***'\n         *\n         * _.repeat('abc', 2);\n         * // => 'abcabc'\n         *\n         * _.repeat('abc', 0);\n         * // => ''\n         */\n        function repeat(string, n, guard) {\n            if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n                n = 1;\n            }\n            else {\n                n = toInteger(n);\n            }\n            return baseRepeat(toString(string), n);\n        }\n        /**\n         * Replaces matches for `pattern` in `string` with `replacement`.\n         *\n         * **Note:** This method is based on\n         * [`String#replace`](https://mdn.io/String/replace).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to modify.\n         * @param {RegExp|string} pattern The pattern to replace.\n         * @param {Function|string} replacement The match replacement.\n         * @returns {string} Returns the modified string.\n         * @example\n         *\n         * _.replace('Hi Fred', 'Fred', 'Barney');\n         * // => 'Hi Barney'\n         */\n        function replace() {\n            var args = arguments, string = toString(args[0]);\n            return args.length < 3 ? string : string.replace(args[1], args[2]);\n        }\n        /**\n         * Converts `string` to\n         * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the snake cased string.\n         * @example\n         *\n         * _.snakeCase('Foo Bar');\n         * // => 'foo_bar'\n         *\n         * _.snakeCase('fooBar');\n         * // => 'foo_bar'\n         *\n         * _.snakeCase('--FOO-BAR--');\n         * // => 'foo_bar'\n         */\n        var snakeCase = createCompounder(function (result, word, index) {\n            return result + (index ? '_' : '') + word.toLowerCase();\n        });\n        /**\n         * Splits `string` by `separator`.\n         *\n         * **Note:** This method is based on\n         * [`String#split`](https://mdn.io/String/split).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to split.\n         * @param {RegExp|string} separator The separator pattern to split by.\n         * @param {number} [limit] The length to truncate results to.\n         * @returns {Array} Returns the string segments.\n         * @example\n         *\n         * _.split('a-b-c', '-', 2);\n         * // => ['a', 'b']\n         */\n        function split(string, separator, limit) {\n            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n                separator = limit = undefined;\n            }\n            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n            if (!limit) {\n                return [];\n            }\n            string = toString(string);\n            if (string && (typeof separator == 'string' ||\n                (separator != null && !isRegExp(separator)))) {\n                separator = baseToString(separator);\n                if (!separator && hasUnicode(string)) {\n                    return castSlice(stringToArray(string), 0, limit);\n                }\n            }\n            return string.split(separator, limit);\n        }\n        /**\n         * Converts `string` to\n         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n         *\n         * @static\n         * @memberOf _\n         * @since 3.1.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the start cased string.\n         * @example\n         *\n         * _.startCase('--foo-bar--');\n         * // => 'Foo Bar'\n         *\n         * _.startCase('fooBar');\n         * // => 'Foo Bar'\n         *\n         * _.startCase('__FOO_BAR__');\n         * // => 'FOO BAR'\n         */\n        var startCase = createCompounder(function (result, word, index) {\n            return result + (index ? ' ' : '') + upperFirst(word);\n        });\n        /**\n         * Checks if `string` starts with the given target string.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to inspect.\n         * @param {string} [target] The string to search for.\n         * @param {number} [position=0] The position to search from.\n         * @returns {boolean} Returns `true` if `string` starts with `target`,\n         *  else `false`.\n         * @example\n         *\n         * _.startsWith('abc', 'a');\n         * // => true\n         *\n         * _.startsWith('abc', 'b');\n         * // => false\n         *\n         * _.startsWith('abc', 'b', 1);\n         * // => true\n         */\n        function startsWith(string, target, position) {\n            string = toString(string);\n            position = baseClamp(toInteger(position), 0, string.length);\n            target = baseToString(target);\n            return string.slice(position, position + target.length) == target;\n        }\n        /**\n         * Creates a compiled template function that can interpolate data properties\n         * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n         * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n         * properties may be accessed as free variables in the template. If a setting\n         * object is given, it takes precedence over `_.templateSettings` values.\n         *\n         * **Note:** In the development build `_.template` utilizes\n         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n         * for easier debugging.\n         *\n         * For more information on precompiling templates see\n         * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n         *\n         * For more information on Chrome extension sandboxes see\n         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category String\n         * @param {string} [string=''] The template string.\n         * @param {Object} [options={}] The options object.\n         * @param {RegExp} [options.escape=_.templateSettings.escape]\n         *  The HTML \"escape\" delimiter.\n         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n         *  The \"evaluate\" delimiter.\n         * @param {Object} [options.imports=_.templateSettings.imports]\n         *  An object to import into the template as free variables.\n         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n         *  The \"interpolate\" delimiter.\n         * @param {string} [options.sourceURL='lodash.templateSources[n]']\n         *  The sourceURL of the compiled template.\n         * @param {string} [options.variable='obj']\n         *  The data object variable name.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Function} Returns the compiled template function.\n         * @example\n         *\n         * // Use the \"interpolate\" delimiter to create a compiled template.\n         * var compiled = _.template('hello <%= user %>!');\n         * compiled({ 'user': 'fred' });\n         * // => 'hello fred!'\n         *\n         * // Use the HTML \"escape\" delimiter to escape data property values.\n         * var compiled = _.template('<b><%- value %></b>');\n         * compiled({ 'value': '<script>' });\n         * // => '<b>&lt;script&gt;</b>'\n         *\n         * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n         * compiled({ 'users': ['fred', 'barney'] });\n         * // => '<li>fred</li><li>barney</li>'\n         *\n         * // Use the internal `print` function in \"evaluate\" delimiters.\n         * var compiled = _.template('<% print(\"hello \" + user); %>!');\n         * compiled({ 'user': 'barney' });\n         * // => 'hello barney!'\n         *\n         * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n         * // Disable support by replacing the \"interpolate\" delimiter.\n         * var compiled = _.template('hello ${ user }!');\n         * compiled({ 'user': 'pebbles' });\n         * // => 'hello pebbles!'\n         *\n         * // Use backslashes to treat delimiters as plain text.\n         * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n         * compiled({ 'value': 'ignored' });\n         * // => '<%- value %>'\n         *\n         * // Use the `imports` option to import `jQuery` as `jq`.\n         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n         * compiled({ 'users': ['fred', 'barney'] });\n         * // => '<li>fred</li><li>barney</li>'\n         *\n         * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n         * compiled(data);\n         * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n         *\n         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n         * compiled.source;\n         * // => function(data) {\n         * //   var __t, __p = '';\n         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n         * //   return __p;\n         * // }\n         *\n         * // Use custom template delimiters.\n         * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n         * var compiled = _.template('hello {{ user }}!');\n         * compiled({ 'user': 'mustache' });\n         * // => 'hello mustache!'\n         *\n         * // Use the `source` property to inline compiled templates for meaningful\n         * // line numbers in error messages and stack traces.\n         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n         *   var JST = {\\\n         *     \"main\": ' + _.template(mainText).source + '\\\n         *   };\\\n         * ');\n         */\n        function template(string, options, guard) {\n            // Based on John Resig's `tmpl` implementation\n            // (http://ejohn.org/blog/javascript-micro-templating/)\n            // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n            var settings = lodash.templateSettings;\n            if (guard && isIterateeCall(string, options, guard)) {\n                options = undefined;\n            }\n            string = toString(string);\n            options = assignInWith({}, options, settings, assignInDefaults);\n            var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);\n            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = \"__p += '\";\n            // Compile the regexp to match each delimiter.\n            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' +\n                interpolate.source + '|' +\n                (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n                (options.evaluate || reNoMatch).source + '|$', 'g');\n            // Use a sourceURL for easier debugging.\n            var sourceURL = '//# sourceURL=' +\n                ('sourceURL' in options\n                    ? options.sourceURL\n                    : ('lodash.templateSources[' + (++templateCounter) + ']')) + '\\n';\n            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n                interpolateValue || (interpolateValue = esTemplateValue);\n                // Escape characters that can't be included in string literals.\n                source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n                // Replace delimiters with snippets.\n                if (escapeValue) {\n                    isEscaping = true;\n                    source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n                }\n                if (evaluateValue) {\n                    isEvaluating = true;\n                    source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n                }\n                if (interpolateValue) {\n                    source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n                }\n                index = offset + match.length;\n                // The JS engine embedded in Adobe products needs `match` returned in\n                // order to produce the correct `offset` value.\n                return match;\n            });\n            source += \"';\\n\";\n            // If `variable` is not specified wrap a with-statement around the generated\n            // code to add the data object to the top of the scope chain.\n            var variable = options.variable;\n            if (!variable) {\n                source = 'with (obj) {\\n' + source + '\\n}\\n';\n            }\n            // Cleanup code by stripping empty strings.\n            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n                .replace(reEmptyStringMiddle, '$1')\n                .replace(reEmptyStringTrailing, '$1;');\n            // Frame code as the function body.\n            source = 'function(' + (variable || 'obj') + ') {\\n' +\n                (variable\n                    ? ''\n                    : 'obj || (obj = {});\\n') +\n                \"var __t, __p = ''\" +\n                (isEscaping\n                    ? ', __e = _.escape'\n                    : '') +\n                (isEvaluating\n                    ? ', __j = Array.prototype.join;\\n' +\n                        \"function print() { __p += __j.call(arguments, '') }\\n\"\n                    : ';\\n') +\n                source +\n                'return __p\\n}';\n            var result = attempt(function () {\n                return Function(importsKeys, sourceURL + 'return ' + source)\n                    .apply(undefined, importsValues);\n            });\n            // Provide the compiled function's source by its `toString` method or\n            // the `source` property as a convenience for inlining compiled templates.\n            result.source = source;\n            if (isError(result)) {\n                throw result;\n            }\n            return result;\n        }\n        /**\n         * Converts `string`, as a whole, to lower case just like\n         * [String#toLowerCase](https://mdn.io/toLowerCase).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the lower cased string.\n         * @example\n         *\n         * _.toLower('--Foo-Bar--');\n         * // => '--foo-bar--'\n         *\n         * _.toLower('fooBar');\n         * // => 'foobar'\n         *\n         * _.toLower('__FOO_BAR__');\n         * // => '__foo_bar__'\n         */\n        function toLower(value) {\n            return toString(value).toLowerCase();\n        }\n        /**\n         * Converts `string`, as a whole, to upper case just like\n         * [String#toUpperCase](https://mdn.io/toUpperCase).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the upper cased string.\n         * @example\n         *\n         * _.toUpper('--foo-bar--');\n         * // => '--FOO-BAR--'\n         *\n         * _.toUpper('fooBar');\n         * // => 'FOOBAR'\n         *\n         * _.toUpper('__foo_bar__');\n         * // => '__FOO_BAR__'\n         */\n        function toUpper(value) {\n            return toString(value).toUpperCase();\n        }\n        /**\n         * Removes leading and trailing whitespace or specified characters from `string`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to trim.\n         * @param {string} [chars=whitespace] The characters to trim.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {string} Returns the trimmed string.\n         * @example\n         *\n         * _.trim('  abc  ');\n         * // => 'abc'\n         *\n         * _.trim('-_-abc-_-', '_-');\n         * // => 'abc'\n         *\n         * _.map(['  foo  ', '  bar  '], _.trim);\n         * // => ['foo', 'bar']\n         */\n        function trim(string, chars, guard) {\n            string = toString(string);\n            if (string && (guard || chars === undefined)) {\n                return string.replace(reTrim, '');\n            }\n            if (!string || !(chars = baseToString(chars))) {\n                return string;\n            }\n            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;\n            return castSlice(strSymbols, start, end).join('');\n        }\n        /**\n         * Removes trailing whitespace or specified characters from `string`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to trim.\n         * @param {string} [chars=whitespace] The characters to trim.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {string} Returns the trimmed string.\n         * @example\n         *\n         * _.trimEnd('  abc  ');\n         * // => '  abc'\n         *\n         * _.trimEnd('-_-abc-_-', '_-');\n         * // => '-_-abc'\n         */\n        function trimEnd(string, chars, guard) {\n            string = toString(string);\n            if (string && (guard || chars === undefined)) {\n                return string.replace(reTrimEnd, '');\n            }\n            if (!string || !(chars = baseToString(chars))) {\n                return string;\n            }\n            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n            return castSlice(strSymbols, 0, end).join('');\n        }\n        /**\n         * Removes leading whitespace or specified characters from `string`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to trim.\n         * @param {string} [chars=whitespace] The characters to trim.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {string} Returns the trimmed string.\n         * @example\n         *\n         * _.trimStart('  abc  ');\n         * // => 'abc  '\n         *\n         * _.trimStart('-_-abc-_-', '_-');\n         * // => 'abc-_-'\n         */\n        function trimStart(string, chars, guard) {\n            string = toString(string);\n            if (string && (guard || chars === undefined)) {\n                return string.replace(reTrimStart, '');\n            }\n            if (!string || !(chars = baseToString(chars))) {\n                return string;\n            }\n            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));\n            return castSlice(strSymbols, start).join('');\n        }\n        /**\n         * Truncates `string` if it's longer than the given maximum string length.\n         * The last characters of the truncated string are replaced with the omission\n         * string which defaults to \"...\".\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to truncate.\n         * @param {Object} [options={}] The options object.\n         * @param {number} [options.length=30] The maximum string length.\n         * @param {string} [options.omission='...'] The string to indicate text is omitted.\n         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n         * @returns {string} Returns the truncated string.\n         * @example\n         *\n         * _.truncate('hi-diddly-ho there, neighborino');\n         * // => 'hi-diddly-ho there, neighbo...'\n         *\n         * _.truncate('hi-diddly-ho there, neighborino', {\n         *   'length': 24,\n         *   'separator': ' '\n         * });\n         * // => 'hi-diddly-ho there,...'\n         *\n         * _.truncate('hi-diddly-ho there, neighborino', {\n         *   'length': 24,\n         *   'separator': /,? +/\n         * });\n         * // => 'hi-diddly-ho there...'\n         *\n         * _.truncate('hi-diddly-ho there, neighborino', {\n         *   'omission': ' [...]'\n         * });\n         * // => 'hi-diddly-ho there, neig [...]'\n         */\n        function truncate(string, options) {\n            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;\n            if (isObject(options)) {\n                var separator = 'separator' in options ? options.separator : separator;\n                length = 'length' in options ? toInteger(options.length) : length;\n                omission = 'omission' in options ? baseToString(options.omission) : omission;\n            }\n            string = toString(string);\n            var strLength = string.length;\n            if (hasUnicode(string)) {\n                var strSymbols = stringToArray(string);\n                strLength = strSymbols.length;\n            }\n            if (length >= strLength) {\n                return string;\n            }\n            var end = length - stringSize(omission);\n            if (end < 1) {\n                return omission;\n            }\n            var result = strSymbols\n                ? castSlice(strSymbols, 0, end).join('')\n                : string.slice(0, end);\n            if (separator === undefined) {\n                return result + omission;\n            }\n            if (strSymbols) {\n                end += (result.length - end);\n            }\n            if (isRegExp(separator)) {\n                if (string.slice(end).search(separator)) {\n                    var match, substring = result;\n                    if (!separator.global) {\n                        separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n                    }\n                    separator.lastIndex = 0;\n                    while ((match = separator.exec(substring))) {\n                        var newEnd = match.index;\n                    }\n                    result = result.slice(0, newEnd === undefined ? end : newEnd);\n                }\n            }\n            else if (string.indexOf(baseToString(separator), end) != end) {\n                var index = result.lastIndexOf(separator);\n                if (index > -1) {\n                    result = result.slice(0, index);\n                }\n            }\n            return result + omission;\n        }\n        /**\n         * The inverse of `_.escape`; this method converts the HTML entities\n         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n         * their corresponding characters.\n         *\n         * **Note:** No other HTML entities are unescaped. To unescape additional\n         * HTML entities use a third-party library like [_he_](https://mths.be/he).\n         *\n         * @static\n         * @memberOf _\n         * @since 0.6.0\n         * @category String\n         * @param {string} [string=''] The string to unescape.\n         * @returns {string} Returns the unescaped string.\n         * @example\n         *\n         * _.unescape('fred, barney, &amp; pebbles');\n         * // => 'fred, barney, & pebbles'\n         */\n        function unescape(string) {\n            string = toString(string);\n            return (string && reHasEscapedHtml.test(string))\n                ? string.replace(reEscapedHtml, unescapeHtmlChar)\n                : string;\n        }\n        /**\n         * Converts `string`, as space separated words, to upper case.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the upper cased string.\n         * @example\n         *\n         * _.upperCase('--foo-bar');\n         * // => 'FOO BAR'\n         *\n         * _.upperCase('fooBar');\n         * // => 'FOO BAR'\n         *\n         * _.upperCase('__foo_bar__');\n         * // => 'FOO BAR'\n         */\n        var upperCase = createCompounder(function (result, word, index) {\n            return result + (index ? ' ' : '') + word.toUpperCase();\n        });\n        /**\n         * Converts the first character of `string` to upper case.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category String\n         * @param {string} [string=''] The string to convert.\n         * @returns {string} Returns the converted string.\n         * @example\n         *\n         * _.upperFirst('fred');\n         * // => 'Fred'\n         *\n         * _.upperFirst('FRED');\n         * // => 'FRED'\n         */\n        var upperFirst = createCaseFirst('toUpperCase');\n        /**\n         * Splits `string` into an array of its words.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category String\n         * @param {string} [string=''] The string to inspect.\n         * @param {RegExp|string} [pattern] The pattern to match words.\n         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n         * @returns {Array} Returns the words of `string`.\n         * @example\n         *\n         * _.words('fred, barney, & pebbles');\n         * // => ['fred', 'barney', 'pebbles']\n         *\n         * _.words('fred, barney, & pebbles', /[^, ]+/g);\n         * // => ['fred', 'barney', '&', 'pebbles']\n         */\n        function words(string, pattern, guard) {\n            string = toString(string);\n            pattern = guard ? undefined : pattern;\n            if (pattern === undefined) {\n                return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n            }\n            return string.match(pattern) || [];\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Attempts to invoke `func`, returning either the result or the caught error\n         * object. Any additional arguments are provided to `func` when it's invoked.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Util\n         * @param {Function} func The function to attempt.\n         * @param {...*} [args] The arguments to invoke `func` with.\n         * @returns {*} Returns the `func` result or error object.\n         * @example\n         *\n         * // Avoid throwing errors for invalid selectors.\n         * var elements = _.attempt(function(selector) {\n         *   return document.querySelectorAll(selector);\n         * }, '>_>');\n         *\n         * if (_.isError(elements)) {\n         *   elements = [];\n         * }\n         */\n        var attempt = baseRest(function (func, args) {\n            try {\n                return apply(func, undefined, args);\n            }\n            catch (e) {\n                return isError(e) ? e : new Error(e);\n            }\n        });\n        /**\n         * Binds methods of an object to the object itself, overwriting the existing\n         * method.\n         *\n         * **Note:** This method doesn't set the \"length\" property of bound functions.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Util\n         * @param {Object} object The object to bind and assign the bound methods to.\n         * @param {...(string|string[])} methodNames The object method names to bind.\n         * @returns {Object} Returns `object`.\n         * @example\n         *\n         * var view = {\n         *   'label': 'docs',\n         *   'click': function() {\n         *     console.log('clicked ' + this.label);\n         *   }\n         * };\n         *\n         * _.bindAll(view, ['click']);\n         * jQuery(element).on('click', view.click);\n         * // => Logs 'clicked docs' when clicked.\n         */\n        var bindAll = flatRest(function (object, methodNames) {\n            arrayEach(methodNames, function (key) {\n                key = toKey(key);\n                baseAssignValue(object, key, bind(object[key], object));\n            });\n            return object;\n        });\n        /**\n         * Creates a function that iterates over `pairs` and invokes the corresponding\n         * function of the first predicate to return truthy. The predicate-function\n         * pairs are invoked with the `this` binding and arguments of the created\n         * function.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {Array} pairs The predicate-function pairs.\n         * @returns {Function} Returns the new composite function.\n         * @example\n         *\n         * var func = _.cond([\n         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n         *   [_.stubTrue,                      _.constant('no match')]\n         * ]);\n         *\n         * func({ 'a': 1, 'b': 2 });\n         * // => 'matches A'\n         *\n         * func({ 'a': 0, 'b': 1 });\n         * // => 'matches B'\n         *\n         * func({ 'a': '1', 'b': '2' });\n         * // => 'no match'\n         */\n        function cond(pairs) {\n            var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();\n            pairs = !length ? [] : arrayMap(pairs, function (pair) {\n                if (typeof pair[1] != 'function') {\n                    throw new TypeError(FUNC_ERROR_TEXT);\n                }\n                return [toIteratee(pair[0]), pair[1]];\n            });\n            return baseRest(function (args) {\n                var index = -1;\n                while (++index < length) {\n                    var pair = pairs[index];\n                    if (apply(pair[0], this, args)) {\n                        return apply(pair[1], this, args);\n                    }\n                }\n            });\n        }\n        /**\n         * Creates a function that invokes the predicate properties of `source` with\n         * the corresponding property values of a given object, returning `true` if\n         * all predicates return truthy, else `false`.\n         *\n         * **Note:** The created function is equivalent to `_.conformsTo` with\n         * `source` partially applied.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {Object} source The object of property predicates to conform to.\n         * @returns {Function} Returns the new spec function.\n         * @example\n         *\n         * var objects = [\n         *   { 'a': 2, 'b': 1 },\n         *   { 'a': 1, 'b': 2 }\n         * ];\n         *\n         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n         * // => [{ 'a': 1, 'b': 2 }]\n         */\n        function conforms(source) {\n            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n        }\n        /**\n         * Creates a function that returns `value`.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.4.0\n         * @category Util\n         * @param {*} value The value to return from the new function.\n         * @returns {Function} Returns the new constant function.\n         * @example\n         *\n         * var objects = _.times(2, _.constant({ 'a': 1 }));\n         *\n         * console.log(objects);\n         * // => [{ 'a': 1 }, { 'a': 1 }]\n         *\n         * console.log(objects[0] === objects[1]);\n         * // => true\n         */\n        function constant(value) {\n            return function () {\n                return value;\n            };\n        }\n        /**\n         * Checks `value` to determine whether a default value should be returned in\n         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n         * or `undefined`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.14.0\n         * @category Util\n         * @param {*} value The value to check.\n         * @param {*} defaultValue The default value.\n         * @returns {*} Returns the resolved value.\n         * @example\n         *\n         * _.defaultTo(1, 10);\n         * // => 1\n         *\n         * _.defaultTo(undefined, 10);\n         * // => 10\n         */\n        function defaultTo(value, defaultValue) {\n            return (value == null || value !== value) ? defaultValue : value;\n        }\n        /**\n         * Creates a function that returns the result of invoking the given functions\n         * with the `this` binding of the created function, where each successive\n         * invocation is supplied the return value of the previous.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Util\n         * @param {...(Function|Function[])} [funcs] The functions to invoke.\n         * @returns {Function} Returns the new composite function.\n         * @see _.flowRight\n         * @example\n         *\n         * function square(n) {\n         *   return n * n;\n         * }\n         *\n         * var addSquare = _.flow([_.add, square]);\n         * addSquare(1, 2);\n         * // => 9\n         */\n        var flow = createFlow();\n        /**\n         * This method is like `_.flow` except that it creates a function that\n         * invokes the given functions from right to left.\n         *\n         * @static\n         * @since 3.0.0\n         * @memberOf _\n         * @category Util\n         * @param {...(Function|Function[])} [funcs] The functions to invoke.\n         * @returns {Function} Returns the new composite function.\n         * @see _.flow\n         * @example\n         *\n         * function square(n) {\n         *   return n * n;\n         * }\n         *\n         * var addSquare = _.flowRight([square, _.add]);\n         * addSquare(1, 2);\n         * // => 9\n         */\n        var flowRight = createFlow(true);\n        /**\n         * This method returns the first argument it receives.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Util\n         * @param {*} value Any value.\n         * @returns {*} Returns `value`.\n         * @example\n         *\n         * var object = { 'a': 1 };\n         *\n         * console.log(_.identity(object) === object);\n         * // => true\n         */\n        function identity(value) {\n            return value;\n        }\n        /**\n         * Creates a function that invokes `func` with the arguments of the created\n         * function. If `func` is a property name, the created function returns the\n         * property value for a given element. If `func` is an array or object, the\n         * created function returns `true` for elements that contain the equivalent\n         * source properties, otherwise it returns `false`.\n         *\n         * @static\n         * @since 4.0.0\n         * @memberOf _\n         * @category Util\n         * @param {*} [func=_.identity] The value to convert to a callback.\n         * @returns {Function} Returns the callback.\n         * @example\n         *\n         * var users = [\n         *   { 'user': 'barney', 'age': 36, 'active': true },\n         *   { 'user': 'fred',   'age': 40, 'active': false }\n         * ];\n         *\n         * // The `_.matches` iteratee shorthand.\n         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n         *\n         * // The `_.matchesProperty` iteratee shorthand.\n         * _.filter(users, _.iteratee(['user', 'fred']));\n         * // => [{ 'user': 'fred', 'age': 40 }]\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.map(users, _.iteratee('user'));\n         * // => ['barney', 'fred']\n         *\n         * // Create custom iteratee shorthands.\n         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n         *     return func.test(string);\n         *   };\n         * });\n         *\n         * _.filter(['abc', 'def'], /ef/);\n         * // => ['def']\n         */\n        function iteratee(func) {\n            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n        }\n        /**\n         * Creates a function that performs a partial deep comparison between a given\n         * object and `source`, returning `true` if the given object has equivalent\n         * property values, else `false`.\n         *\n         * **Note:** The created function is equivalent to `_.isMatch` with `source`\n         * partially applied.\n         *\n         * Partial comparisons will match empty array and empty object `source`\n         * values against any array or object value, respectively. See `_.isEqual`\n         * for a list of supported value comparisons.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Util\n         * @param {Object} source The object of property values to match.\n         * @returns {Function} Returns the new spec function.\n         * @example\n         *\n         * var objects = [\n         *   { 'a': 1, 'b': 2, 'c': 3 },\n         *   { 'a': 4, 'b': 5, 'c': 6 }\n         * ];\n         *\n         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n         */\n        function matches(source) {\n            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n        }\n        /**\n         * Creates a function that performs a partial deep comparison between the\n         * value at `path` of a given object to `srcValue`, returning `true` if the\n         * object value is equivalent, else `false`.\n         *\n         * **Note:** Partial comparisons will match empty array and empty object\n         * `srcValue` values against any array or object value, respectively. See\n         * `_.isEqual` for a list of supported value comparisons.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.2.0\n         * @category Util\n         * @param {Array|string} path The path of the property to get.\n         * @param {*} srcValue The value to match.\n         * @returns {Function} Returns the new spec function.\n         * @example\n         *\n         * var objects = [\n         *   { 'a': 1, 'b': 2, 'c': 3 },\n         *   { 'a': 4, 'b': 5, 'c': 6 }\n         * ];\n         *\n         * _.find(objects, _.matchesProperty('a', 4));\n         * // => { 'a': 4, 'b': 5, 'c': 6 }\n         */\n        function matchesProperty(path, srcValue) {\n            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n        }\n        /**\n         * Creates a function that invokes the method at `path` of a given object.\n         * Any additional arguments are provided to the invoked method.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.7.0\n         * @category Util\n         * @param {Array|string} path The path of the method to invoke.\n         * @param {...*} [args] The arguments to invoke the method with.\n         * @returns {Function} Returns the new invoker function.\n         * @example\n         *\n         * var objects = [\n         *   { 'a': { 'b': _.constant(2) } },\n         *   { 'a': { 'b': _.constant(1) } }\n         * ];\n         *\n         * _.map(objects, _.method('a.b'));\n         * // => [2, 1]\n         *\n         * _.map(objects, _.method(['a', 'b']));\n         * // => [2, 1]\n         */\n        var method = baseRest(function (path, args) {\n            return function (object) {\n                return baseInvoke(object, path, args);\n            };\n        });\n        /**\n         * The opposite of `_.method`; this method creates a function that invokes\n         * the method at a given path of `object`. Any additional arguments are\n         * provided to the invoked method.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.7.0\n         * @category Util\n         * @param {Object} object The object to query.\n         * @param {...*} [args] The arguments to invoke the method with.\n         * @returns {Function} Returns the new invoker function.\n         * @example\n         *\n         * var array = _.times(3, _.constant),\n         *     object = { 'a': array, 'b': array, 'c': array };\n         *\n         * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n         * // => [2, 0]\n         *\n         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n         * // => [2, 0]\n         */\n        var methodOf = baseRest(function (object, args) {\n            return function (path) {\n                return baseInvoke(object, path, args);\n            };\n        });\n        /**\n         * Adds all own enumerable string keyed function properties of a source\n         * object to the destination object. If `object` is a function, then methods\n         * are added to its prototype as well.\n         *\n         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n         * avoid conflicts caused by modifying the original.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Util\n         * @param {Function|Object} [object=lodash] The destination object.\n         * @param {Object} source The object of functions to add.\n         * @param {Object} [options={}] The options object.\n         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n         * @returns {Function|Object} Returns `object`.\n         * @example\n         *\n         * function vowels(string) {\n         *   return _.filter(string, function(v) {\n         *     return /[aeiou]/i.test(v);\n         *   });\n         * }\n         *\n         * _.mixin({ 'vowels': vowels });\n         * _.vowels('fred');\n         * // => ['e']\n         *\n         * _('fred').vowels().value();\n         * // => ['e']\n         *\n         * _.mixin({ 'vowels': vowels }, { 'chain': false });\n         * _('fred').vowels();\n         * // => ['e']\n         */\n        function mixin(object, source, options) {\n            var props = keys(source), methodNames = baseFunctions(source, props);\n            if (options == null &&\n                !(isObject(source) && (methodNames.length || !props.length))) {\n                options = source;\n                source = object;\n                object = this;\n                methodNames = baseFunctions(source, keys(source));\n            }\n            var chain = !(isObject(options) && 'chain' in options) || !!options.chain, isFunc = isFunction(object);\n            arrayEach(methodNames, function (methodName) {\n                var func = source[methodName];\n                object[methodName] = func;\n                if (isFunc) {\n                    object.prototype[methodName] = function () {\n                        var chainAll = this.__chain__;\n                        if (chain || chainAll) {\n                            var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);\n                            actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n                            result.__chain__ = chainAll;\n                            return result;\n                        }\n                        return func.apply(object, arrayPush([this.value()], arguments));\n                    };\n                }\n            });\n            return object;\n        }\n        /**\n         * Reverts the `_` variable to its previous value and returns a reference to\n         * the `lodash` function.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Util\n         * @returns {Function} Returns the `lodash` function.\n         * @example\n         *\n         * var lodash = _.noConflict();\n         */\n        function noConflict() {\n            if (root._ === this) {\n                root._ = oldDash;\n            }\n            return this;\n        }\n        /**\n         * This method returns `undefined`.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.3.0\n         * @category Util\n         * @example\n         *\n         * _.times(2, _.noop);\n         * // => [undefined, undefined]\n         */\n        function noop() {\n            // No operation performed.\n        }\n        /**\n         * Creates a function that gets the argument at index `n`. If `n` is negative,\n         * the nth argument from the end is returned.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {number} [n=0] The index of the argument to return.\n         * @returns {Function} Returns the new pass-thru function.\n         * @example\n         *\n         * var func = _.nthArg(1);\n         * func('a', 'b', 'c', 'd');\n         * // => 'b'\n         *\n         * var func = _.nthArg(-2);\n         * func('a', 'b', 'c', 'd');\n         * // => 'c'\n         */\n        function nthArg(n) {\n            n = toInteger(n);\n            return baseRest(function (args) {\n                return baseNth(args, n);\n            });\n        }\n        /**\n         * Creates a function that invokes `iteratees` with the arguments it receives\n         * and returns their results.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {...(Function|Function[])} [iteratees=[_.identity]]\n         *  The iteratees to invoke.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * var func = _.over([Math.max, Math.min]);\n         *\n         * func(1, 2, 3, 4);\n         * // => [4, 1]\n         */\n        var over = createOver(arrayMap);\n        /**\n         * Creates a function that checks if **all** of the `predicates` return\n         * truthy when invoked with the arguments it receives.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {...(Function|Function[])} [predicates=[_.identity]]\n         *  The predicates to check.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * var func = _.overEvery([Boolean, isFinite]);\n         *\n         * func('1');\n         * // => true\n         *\n         * func(null);\n         * // => false\n         *\n         * func(NaN);\n         * // => false\n         */\n        var overEvery = createOver(arrayEvery);\n        /**\n         * Creates a function that checks if **any** of the `predicates` return\n         * truthy when invoked with the arguments it receives.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {...(Function|Function[])} [predicates=[_.identity]]\n         *  The predicates to check.\n         * @returns {Function} Returns the new function.\n         * @example\n         *\n         * var func = _.overSome([Boolean, isFinite]);\n         *\n         * func('1');\n         * // => true\n         *\n         * func(null);\n         * // => true\n         *\n         * func(NaN);\n         * // => false\n         */\n        var overSome = createOver(arraySome);\n        /**\n         * Creates a function that returns the value at `path` of a given object.\n         *\n         * @static\n         * @memberOf _\n         * @since 2.4.0\n         * @category Util\n         * @param {Array|string} path The path of the property to get.\n         * @returns {Function} Returns the new accessor function.\n         * @example\n         *\n         * var objects = [\n         *   { 'a': { 'b': 2 } },\n         *   { 'a': { 'b': 1 } }\n         * ];\n         *\n         * _.map(objects, _.property('a.b'));\n         * // => [2, 1]\n         *\n         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n         * // => [1, 2]\n         */\n        function property(path) {\n            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n        }\n        /**\n         * The opposite of `_.property`; this method creates a function that returns\n         * the value at a given path of `object`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.0.0\n         * @category Util\n         * @param {Object} object The object to query.\n         * @returns {Function} Returns the new accessor function.\n         * @example\n         *\n         * var array = [0, 1, 2],\n         *     object = { 'a': array, 'b': array, 'c': array };\n         *\n         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n         * // => [2, 0]\n         *\n         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n         * // => [2, 0]\n         */\n        function propertyOf(object) {\n            return function (path) {\n                return object == null ? undefined : baseGet(object, path);\n            };\n        }\n        /**\n         * Creates an array of numbers (positive and/or negative) progressing from\n         * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n         * `start` is specified without an `end` or `step`. If `end` is not specified,\n         * it's set to `start` with `start` then set to `0`.\n         *\n         * **Note:** JavaScript follows the IEEE-754 standard for resolving\n         * floating-point values which can produce unexpected results.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Util\n         * @param {number} [start=0] The start of the range.\n         * @param {number} end The end of the range.\n         * @param {number} [step=1] The value to increment or decrement by.\n         * @returns {Array} Returns the range of numbers.\n         * @see _.inRange, _.rangeRight\n         * @example\n         *\n         * _.range(4);\n         * // => [0, 1, 2, 3]\n         *\n         * _.range(-4);\n         * // => [0, -1, -2, -3]\n         *\n         * _.range(1, 5);\n         * // => [1, 2, 3, 4]\n         *\n         * _.range(0, 20, 5);\n         * // => [0, 5, 10, 15]\n         *\n         * _.range(0, -4, -1);\n         * // => [0, -1, -2, -3]\n         *\n         * _.range(1, 4, 0);\n         * // => [1, 1, 1]\n         *\n         * _.range(0);\n         * // => []\n         */\n        var range = createRange();\n        /**\n         * This method is like `_.range` except that it populates values in\n         * descending order.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {number} [start=0] The start of the range.\n         * @param {number} end The end of the range.\n         * @param {number} [step=1] The value to increment or decrement by.\n         * @returns {Array} Returns the range of numbers.\n         * @see _.inRange, _.range\n         * @example\n         *\n         * _.rangeRight(4);\n         * // => [3, 2, 1, 0]\n         *\n         * _.rangeRight(-4);\n         * // => [-3, -2, -1, 0]\n         *\n         * _.rangeRight(1, 5);\n         * // => [4, 3, 2, 1]\n         *\n         * _.rangeRight(0, 20, 5);\n         * // => [15, 10, 5, 0]\n         *\n         * _.rangeRight(0, -4, -1);\n         * // => [-3, -2, -1, 0]\n         *\n         * _.rangeRight(1, 4, 0);\n         * // => [1, 1, 1]\n         *\n         * _.rangeRight(0);\n         * // => []\n         */\n        var rangeRight = createRange(true);\n        /**\n         * This method returns a new empty array.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.13.0\n         * @category Util\n         * @returns {Array} Returns the new empty array.\n         * @example\n         *\n         * var arrays = _.times(2, _.stubArray);\n         *\n         * console.log(arrays);\n         * // => [[], []]\n         *\n         * console.log(arrays[0] === arrays[1]);\n         * // => false\n         */\n        function stubArray() {\n            return [];\n        }\n        /**\n         * This method returns `false`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.13.0\n         * @category Util\n         * @returns {boolean} Returns `false`.\n         * @example\n         *\n         * _.times(2, _.stubFalse);\n         * // => [false, false]\n         */\n        function stubFalse() {\n            return false;\n        }\n        /**\n         * This method returns a new empty object.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.13.0\n         * @category Util\n         * @returns {Object} Returns the new empty object.\n         * @example\n         *\n         * var objects = _.times(2, _.stubObject);\n         *\n         * console.log(objects);\n         * // => [{}, {}]\n         *\n         * console.log(objects[0] === objects[1]);\n         * // => false\n         */\n        function stubObject() {\n            return {};\n        }\n        /**\n         * This method returns an empty string.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.13.0\n         * @category Util\n         * @returns {string} Returns the empty string.\n         * @example\n         *\n         * _.times(2, _.stubString);\n         * // => ['', '']\n         */\n        function stubString() {\n            return '';\n        }\n        /**\n         * This method returns `true`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.13.0\n         * @category Util\n         * @returns {boolean} Returns `true`.\n         * @example\n         *\n         * _.times(2, _.stubTrue);\n         * // => [true, true]\n         */\n        function stubTrue() {\n            return true;\n        }\n        /**\n         * Invokes the iteratee `n` times, returning an array of the results of\n         * each invocation. The iteratee is invoked with one argument; (index).\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Util\n         * @param {number} n The number of times to invoke `iteratee`.\n         * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n         * @returns {Array} Returns the array of results.\n         * @example\n         *\n         * _.times(3, String);\n         * // => ['0', '1', '2']\n         *\n         *  _.times(4, _.constant(0));\n         * // => [0, 0, 0, 0]\n         */\n        function times(n, iteratee) {\n            n = toInteger(n);\n            if (n < 1 || n > MAX_SAFE_INTEGER) {\n                return [];\n            }\n            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);\n            iteratee = getIteratee(iteratee);\n            n -= MAX_ARRAY_LENGTH;\n            var result = baseTimes(length, iteratee);\n            while (++index < n) {\n                iteratee(index);\n            }\n            return result;\n        }\n        /**\n         * Converts `value` to a property path array.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Util\n         * @param {*} value The value to convert.\n         * @returns {Array} Returns the new property path array.\n         * @example\n         *\n         * _.toPath('a.b.c');\n         * // => ['a', 'b', 'c']\n         *\n         * _.toPath('a[0].b.c');\n         * // => ['a', '0', 'b', 'c']\n         */\n        function toPath(value) {\n            if (isArray(value)) {\n                return arrayMap(value, toKey);\n            }\n            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n        }\n        /**\n         * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Util\n         * @param {string} [prefix=''] The value to prefix the ID with.\n         * @returns {string} Returns the unique ID.\n         * @example\n         *\n         * _.uniqueId('contact_');\n         * // => 'contact_104'\n         *\n         * _.uniqueId();\n         * // => '105'\n         */\n        function uniqueId(prefix) {\n            var id = ++idCounter;\n            return toString(prefix) + id;\n        }\n        /*------------------------------------------------------------------------*/\n        /**\n         * Adds two numbers.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.4.0\n         * @category Math\n         * @param {number} augend The first number in an addition.\n         * @param {number} addend The second number in an addition.\n         * @returns {number} Returns the total.\n         * @example\n         *\n         * _.add(6, 4);\n         * // => 10\n         */\n        var add = createMathOperation(function (augend, addend) {\n            return augend + addend;\n        }, 0);\n        /**\n         * Computes `number` rounded up to `precision`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.10.0\n         * @category Math\n         * @param {number} number The number to round up.\n         * @param {number} [precision=0] The precision to round up to.\n         * @returns {number} Returns the rounded up number.\n         * @example\n         *\n         * _.ceil(4.006);\n         * // => 5\n         *\n         * _.ceil(6.004, 2);\n         * // => 6.01\n         *\n         * _.ceil(6040, -2);\n         * // => 6100\n         */\n        var ceil = createRound('ceil');\n        /**\n         * Divide two numbers.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.7.0\n         * @category Math\n         * @param {number} dividend The first number in a division.\n         * @param {number} divisor The second number in a division.\n         * @returns {number} Returns the quotient.\n         * @example\n         *\n         * _.divide(6, 4);\n         * // => 1.5\n         */\n        var divide = createMathOperation(function (dividend, divisor) {\n            return dividend / divisor;\n        }, 1);\n        /**\n         * Computes `number` rounded down to `precision`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.10.0\n         * @category Math\n         * @param {number} number The number to round down.\n         * @param {number} [precision=0] The precision to round down to.\n         * @returns {number} Returns the rounded down number.\n         * @example\n         *\n         * _.floor(4.006);\n         * // => 4\n         *\n         * _.floor(0.046, 2);\n         * // => 0.04\n         *\n         * _.floor(4060, -2);\n         * // => 4000\n         */\n        var floor = createRound('floor');\n        /**\n         * Computes the maximum value of `array`. If `array` is empty or falsey,\n         * `undefined` is returned.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @returns {*} Returns the maximum value.\n         * @example\n         *\n         * _.max([4, 2, 8, 6]);\n         * // => 8\n         *\n         * _.max([]);\n         * // => undefined\n         */\n        function max(array) {\n            return (array && array.length)\n                ? baseExtremum(array, identity, baseGt)\n                : undefined;\n        }\n        /**\n         * This method is like `_.max` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * the value is ranked. The iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {*} Returns the maximum value.\n         * @example\n         *\n         * var objects = [{ 'n': 1 }, { 'n': 2 }];\n         *\n         * _.maxBy(objects, function(o) { return o.n; });\n         * // => { 'n': 2 }\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.maxBy(objects, 'n');\n         * // => { 'n': 2 }\n         */\n        function maxBy(array, iteratee) {\n            return (array && array.length)\n                ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n                : undefined;\n        }\n        /**\n         * Computes the mean of the values in `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @returns {number} Returns the mean.\n         * @example\n         *\n         * _.mean([4, 2, 8, 6]);\n         * // => 5\n         */\n        function mean(array) {\n            return baseMean(array, identity);\n        }\n        /**\n         * This method is like `_.mean` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the value to be averaged.\n         * The iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.7.0\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {number} Returns the mean.\n         * @example\n         *\n         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n         *\n         * _.meanBy(objects, function(o) { return o.n; });\n         * // => 5\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.meanBy(objects, 'n');\n         * // => 5\n         */\n        function meanBy(array, iteratee) {\n            return baseMean(array, getIteratee(iteratee, 2));\n        }\n        /**\n         * Computes the minimum value of `array`. If `array` is empty or falsey,\n         * `undefined` is returned.\n         *\n         * @static\n         * @since 0.1.0\n         * @memberOf _\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @returns {*} Returns the minimum value.\n         * @example\n         *\n         * _.min([4, 2, 8, 6]);\n         * // => 2\n         *\n         * _.min([]);\n         * // => undefined\n         */\n        function min(array) {\n            return (array && array.length)\n                ? baseExtremum(array, identity, baseLt)\n                : undefined;\n        }\n        /**\n         * This method is like `_.min` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the criterion by which\n         * the value is ranked. The iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {*} Returns the minimum value.\n         * @example\n         *\n         * var objects = [{ 'n': 1 }, { 'n': 2 }];\n         *\n         * _.minBy(objects, function(o) { return o.n; });\n         * // => { 'n': 1 }\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.minBy(objects, 'n');\n         * // => { 'n': 1 }\n         */\n        function minBy(array, iteratee) {\n            return (array && array.length)\n                ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n                : undefined;\n        }\n        /**\n         * Multiply two numbers.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.7.0\n         * @category Math\n         * @param {number} multiplier The first number in a multiplication.\n         * @param {number} multiplicand The second number in a multiplication.\n         * @returns {number} Returns the product.\n         * @example\n         *\n         * _.multiply(6, 4);\n         * // => 24\n         */\n        var multiply = createMathOperation(function (multiplier, multiplicand) {\n            return multiplier * multiplicand;\n        }, 1);\n        /**\n         * Computes `number` rounded to `precision`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.10.0\n         * @category Math\n         * @param {number} number The number to round.\n         * @param {number} [precision=0] The precision to round to.\n         * @returns {number} Returns the rounded number.\n         * @example\n         *\n         * _.round(4.006);\n         * // => 4\n         *\n         * _.round(4.006, 2);\n         * // => 4.01\n         *\n         * _.round(4060, -2);\n         * // => 4100\n         */\n        var round = createRound('round');\n        /**\n         * Subtract two numbers.\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Math\n         * @param {number} minuend The first number in a subtraction.\n         * @param {number} subtrahend The second number in a subtraction.\n         * @returns {number} Returns the difference.\n         * @example\n         *\n         * _.subtract(6, 4);\n         * // => 2\n         */\n        var subtract = createMathOperation(function (minuend, subtrahend) {\n            return minuend - subtrahend;\n        }, 0);\n        /**\n         * Computes the sum of the values in `array`.\n         *\n         * @static\n         * @memberOf _\n         * @since 3.4.0\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @returns {number} Returns the sum.\n         * @example\n         *\n         * _.sum([4, 2, 8, 6]);\n         * // => 20\n         */\n        function sum(array) {\n            return (array && array.length)\n                ? baseSum(array, identity)\n                : 0;\n        }\n        /**\n         * This method is like `_.sum` except that it accepts `iteratee` which is\n         * invoked for each element in `array` to generate the value to be summed.\n         * The iteratee is invoked with one argument: (value).\n         *\n         * @static\n         * @memberOf _\n         * @since 4.0.0\n         * @category Math\n         * @param {Array} array The array to iterate over.\n         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n         * @returns {number} Returns the sum.\n         * @example\n         *\n         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n         *\n         * _.sumBy(objects, function(o) { return o.n; });\n         * // => 20\n         *\n         * // The `_.property` iteratee shorthand.\n         * _.sumBy(objects, 'n');\n         * // => 20\n         */\n        function sumBy(array, iteratee) {\n            return (array && array.length)\n                ? baseSum(array, getIteratee(iteratee, 2))\n                : 0;\n        }\n        /*------------------------------------------------------------------------*/\n        // Add methods that return wrapped values in chain sequences.\n        lodash.after = after;\n        lodash.ary = ary;\n        lodash.assign = assign;\n        lodash.assignIn = assignIn;\n        lodash.assignInWith = assignInWith;\n        lodash.assignWith = assignWith;\n        lodash.at = at;\n        lodash.before = before;\n        lodash.bind = bind;\n        lodash.bindAll = bindAll;\n        lodash.bindKey = bindKey;\n        lodash.castArray = castArray;\n        lodash.chain = chain;\n        lodash.chunk = chunk;\n        lodash.compact = compact;\n        lodash.concat = concat;\n        lodash.cond = cond;\n        lodash.conforms = conforms;\n        lodash.constant = constant;\n        lodash.countBy = countBy;\n        lodash.create = create;\n        lodash.curry = curry;\n        lodash.curryRight = curryRight;\n        lodash.debounce = debounce;\n        lodash.defaults = defaults;\n        lodash.defaultsDeep = defaultsDeep;\n        lodash.defer = defer;\n        lodash.delay = delay;\n        lodash.difference = difference;\n        lodash.differenceBy = differenceBy;\n        lodash.differenceWith = differenceWith;\n        lodash.drop = drop;\n        lodash.dropRight = dropRight;\n        lodash.dropRightWhile = dropRightWhile;\n        lodash.dropWhile = dropWhile;\n        lodash.fill = fill;\n        lodash.filter = filter;\n        lodash.flatMap = flatMap;\n        lodash.flatMapDeep = flatMapDeep;\n        lodash.flatMapDepth = flatMapDepth;\n        lodash.flatten = flatten;\n        lodash.flattenDeep = flattenDeep;\n        lodash.flattenDepth = flattenDepth;\n        lodash.flip = flip;\n        lodash.flow = flow;\n        lodash.flowRight = flowRight;\n        lodash.fromPairs = fromPairs;\n        lodash.functions = functions;\n        lodash.functionsIn = functionsIn;\n        lodash.groupBy = groupBy;\n        lodash.initial = initial;\n        lodash.intersection = intersection;\n        lodash.intersectionBy = intersectionBy;\n        lodash.intersectionWith = intersectionWith;\n        lodash.invert = invert;\n        lodash.invertBy = invertBy;\n        lodash.invokeMap = invokeMap;\n        lodash.iteratee = iteratee;\n        lodash.keyBy = keyBy;\n        lodash.keys = keys;\n        lodash.keysIn = keysIn;\n        lodash.map = map;\n        lodash.mapKeys = mapKeys;\n        lodash.mapValues = mapValues;\n        lodash.matches = matches;\n        lodash.matchesProperty = matchesProperty;\n        lodash.memoize = memoize;\n        lodash.merge = merge;\n        lodash.mergeWith = mergeWith;\n        lodash.method = method;\n        lodash.methodOf = methodOf;\n        lodash.mixin = mixin;\n        lodash.negate = negate;\n        lodash.nthArg = nthArg;\n        lodash.omit = omit;\n        lodash.omitBy = omitBy;\n        lodash.once = once;\n        lodash.orderBy = orderBy;\n        lodash.over = over;\n        lodash.overArgs = overArgs;\n        lodash.overEvery = overEvery;\n        lodash.overSome = overSome;\n        lodash.partial = partial;\n        lodash.partialRight = partialRight;\n        lodash.partition = partition;\n        lodash.pick = pick;\n        lodash.pickBy = pickBy;\n        lodash.property = property;\n        lodash.propertyOf = propertyOf;\n        lodash.pull = pull;\n        lodash.pullAll = pullAll;\n        lodash.pullAllBy = pullAllBy;\n        lodash.pullAllWith = pullAllWith;\n        lodash.pullAt = pullAt;\n        lodash.range = range;\n        lodash.rangeRight = rangeRight;\n        lodash.rearg = rearg;\n        lodash.reject = reject;\n        lodash.remove = remove;\n        lodash.rest = rest;\n        lodash.reverse = reverse;\n        lodash.sampleSize = sampleSize;\n        lodash.set = set;\n        lodash.setWith = setWith;\n        lodash.shuffle = shuffle;\n        lodash.slice = slice;\n        lodash.sortBy = sortBy;\n        lodash.sortedUniq = sortedUniq;\n        lodash.sortedUniqBy = sortedUniqBy;\n        lodash.split = split;\n        lodash.spread = spread;\n        lodash.tail = tail;\n        lodash.take = take;\n        lodash.takeRight = takeRight;\n        lodash.takeRightWhile = takeRightWhile;\n        lodash.takeWhile = takeWhile;\n        lodash.tap = tap;\n        lodash.throttle = throttle;\n        lodash.thru = thru;\n        lodash.toArray = toArray;\n        lodash.toPairs = toPairs;\n        lodash.toPairsIn = toPairsIn;\n        lodash.toPath = toPath;\n        lodash.toPlainObject = toPlainObject;\n        lodash.transform = transform;\n        lodash.unary = unary;\n        lodash.union = union;\n        lodash.unionBy = unionBy;\n        lodash.unionWith = unionWith;\n        lodash.uniq = uniq;\n        lodash.uniqBy = uniqBy;\n        lodash.uniqWith = uniqWith;\n        lodash.unset = unset;\n        lodash.unzip = unzip;\n        lodash.unzipWith = unzipWith;\n        lodash.update = update;\n        lodash.updateWith = updateWith;\n        lodash.values = values;\n        lodash.valuesIn = valuesIn;\n        lodash.without = without;\n        lodash.words = words;\n        lodash.wrap = wrap;\n        lodash.xor = xor;\n        lodash.xorBy = xorBy;\n        lodash.xorWith = xorWith;\n        lodash.zip = zip;\n        lodash.zipObject = zipObject;\n        lodash.zipObjectDeep = zipObjectDeep;\n        lodash.zipWith = zipWith;\n        // Add aliases.\n        lodash.entries = toPairs;\n        lodash.entriesIn = toPairsIn;\n        lodash.extend = assignIn;\n        lodash.extendWith = assignInWith;\n        // Add methods to `lodash.prototype`.\n        mixin(lodash, lodash);\n        /*------------------------------------------------------------------------*/\n        // Add methods that return unwrapped values in chain sequences.\n        lodash.add = add;\n        lodash.attempt = attempt;\n        lodash.camelCase = camelCase;\n        lodash.capitalize = capitalize;\n        lodash.ceil = ceil;\n        lodash.clamp = clamp;\n        lodash.clone = clone;\n        lodash.cloneDeep = cloneDeep;\n        lodash.cloneDeepWith = cloneDeepWith;\n        lodash.cloneWith = cloneWith;\n        lodash.conformsTo = conformsTo;\n        lodash.deburr = deburr;\n        lodash.defaultTo = defaultTo;\n        lodash.divide = divide;\n        lodash.endsWith = endsWith;\n        lodash.eq = eq;\n        lodash.escape = escape;\n        lodash.escapeRegExp = escapeRegExp;\n        lodash.every = every;\n        lodash.find = find;\n        lodash.findIndex = findIndex;\n        lodash.findKey = findKey;\n        lodash.findLast = findLast;\n        lodash.findLastIndex = findLastIndex;\n        lodash.findLastKey = findLastKey;\n        lodash.floor = floor;\n        lodash.forEach = forEach;\n        lodash.forEachRight = forEachRight;\n        lodash.forIn = forIn;\n        lodash.forInRight = forInRight;\n        lodash.forOwn = forOwn;\n        lodash.forOwnRight = forOwnRight;\n        lodash.get = get;\n        lodash.gt = gt;\n        lodash.gte = gte;\n        lodash.has = has;\n        lodash.hasIn = hasIn;\n        lodash.head = head;\n        lodash.identity = identity;\n        lodash.includes = includes;\n        lodash.indexOf = indexOf;\n        lodash.inRange = inRange;\n        lodash.invoke = invoke;\n        lodash.isArguments = isArguments;\n        lodash.isArray = isArray;\n        lodash.isArrayBuffer = isArrayBuffer;\n        lodash.isArrayLike = isArrayLike;\n        lodash.isArrayLikeObject = isArrayLikeObject;\n        lodash.isBoolean = isBoolean;\n        lodash.isBuffer = isBuffer;\n        lodash.isDate = isDate;\n        lodash.isElement = isElement;\n        lodash.isEmpty = isEmpty;\n        lodash.isEqual = isEqual;\n        lodash.isEqualWith = isEqualWith;\n        lodash.isError = isError;\n        lodash.isFinite = isFinite;\n        lodash.isFunction = isFunction;\n        lodash.isInteger = isInteger;\n        lodash.isLength = isLength;\n        lodash.isMap = isMap;\n        lodash.isMatch = isMatch;\n        lodash.isMatchWith = isMatchWith;\n        lodash.isNaN = isNaN;\n        lodash.isNative = isNative;\n        lodash.isNil = isNil;\n        lodash.isNull = isNull;\n        lodash.isNumber = isNumber;\n        lodash.isObject = isObject;\n        lodash.isObjectLike = isObjectLike;\n        lodash.isPlainObject = isPlainObject;\n        lodash.isRegExp = isRegExp;\n        lodash.isSafeInteger = isSafeInteger;\n        lodash.isSet = isSet;\n        lodash.isString = isString;\n        lodash.isSymbol = isSymbol;\n        lodash.isTypedArray = isTypedArray;\n        lodash.isUndefined = isUndefined;\n        lodash.isWeakMap = isWeakMap;\n        lodash.isWeakSet = isWeakSet;\n        lodash.join = join;\n        lodash.kebabCase = kebabCase;\n        lodash.last = last;\n        lodash.lastIndexOf = lastIndexOf;\n        lodash.lowerCase = lowerCase;\n        lodash.lowerFirst = lowerFirst;\n        lodash.lt = lt;\n        lodash.lte = lte;\n        lodash.max = max;\n        lodash.maxBy = maxBy;\n        lodash.mean = mean;\n        lodash.meanBy = meanBy;\n        lodash.min = min;\n        lodash.minBy = minBy;\n        lodash.stubArray = stubArray;\n        lodash.stubFalse = stubFalse;\n        lodash.stubObject = stubObject;\n        lodash.stubString = stubString;\n        lodash.stubTrue = stubTrue;\n        lodash.multiply = multiply;\n        lodash.nth = nth;\n        lodash.noConflict = noConflict;\n        lodash.noop = noop;\n        lodash.now = now;\n        lodash.pad = pad;\n        lodash.padEnd = padEnd;\n        lodash.padStart = padStart;\n        lodash.parseInt = parseInt;\n        lodash.random = random;\n        lodash.reduce = reduce;\n        lodash.reduceRight = reduceRight;\n        lodash.repeat = repeat;\n        lodash.replace = replace;\n        lodash.result = result;\n        lodash.round = round;\n        lodash.runInContext = runInContext;\n        lodash.sample = sample;\n        lodash.size = size;\n        lodash.snakeCase = snakeCase;\n        lodash.some = some;\n        lodash.sortedIndex = sortedIndex;\n        lodash.sortedIndexBy = sortedIndexBy;\n        lodash.sortedIndexOf = sortedIndexOf;\n        lodash.sortedLastIndex = sortedLastIndex;\n        lodash.sortedLastIndexBy = sortedLastIndexBy;\n        lodash.sortedLastIndexOf = sortedLastIndexOf;\n        lodash.startCase = startCase;\n        lodash.startsWith = startsWith;\n        lodash.subtract = subtract;\n        lodash.sum = sum;\n        lodash.sumBy = sumBy;\n        lodash.template = template;\n        lodash.times = times;\n        lodash.toFinite = toFinite;\n        lodash.toInteger = toInteger;\n        lodash.toLength = toLength;\n        lodash.toLower = toLower;\n        lodash.toNumber = toNumber;\n        lodash.toSafeInteger = toSafeInteger;\n        lodash.toString = toString;\n        lodash.toUpper = toUpper;\n        lodash.trim = trim;\n        lodash.trimEnd = trimEnd;\n        lodash.trimStart = trimStart;\n        lodash.truncate = truncate;\n        lodash.unescape = unescape;\n        lodash.uniqueId = uniqueId;\n        lodash.upperCase = upperCase;\n        lodash.upperFirst = upperFirst;\n        // Add aliases.\n        lodash.each = forEach;\n        lodash.eachRight = forEachRight;\n        lodash.first = head;\n        mixin(lodash, (function () {\n            var source = {};\n            baseForOwn(lodash, function (func, methodName) {\n                if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n                    source[methodName] = func;\n                }\n            });\n            return source;\n        }()), { 'chain': false });\n        /*------------------------------------------------------------------------*/\n        /**\n         * The semantic version number.\n         *\n         * @static\n         * @memberOf _\n         * @type {string}\n         */\n        lodash.VERSION = VERSION;\n        // Assign default placeholders.\n        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {\n            lodash[methodName].placeholder = lodash;\n        });\n        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n        arrayEach(['drop', 'take'], function (methodName, index) {\n            LazyWrapper.prototype[methodName] = function (n) {\n                var filtered = this.__filtered__;\n                if (filtered && !index) {\n                    return new LazyWrapper(this);\n                }\n                n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n                var result = this.clone();\n                if (filtered) {\n                    result.__takeCount__ = nativeMin(n, result.__takeCount__);\n                }\n                else {\n                    result.__views__.push({\n                        'size': nativeMin(n, MAX_ARRAY_LENGTH),\n                        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n                    });\n                }\n                return result;\n            };\n            LazyWrapper.prototype[methodName + 'Right'] = function (n) {\n                return this.reverse()[methodName](n).reverse();\n            };\n        });\n        // Add `LazyWrapper` methods that accept an `iteratee` value.\n        arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {\n            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n            LazyWrapper.prototype[methodName] = function (iteratee) {\n                var result = this.clone();\n                result.__iteratees__.push({\n                    'iteratee': getIteratee(iteratee, 3),\n                    'type': type\n                });\n                result.__filtered__ = result.__filtered__ || isFilter;\n                return result;\n            };\n        });\n        // Add `LazyWrapper` methods for `_.head` and `_.last`.\n        arrayEach(['head', 'last'], function (methodName, index) {\n            var takeName = 'take' + (index ? 'Right' : '');\n            LazyWrapper.prototype[methodName] = function () {\n                return this[takeName](1).value()[0];\n            };\n        });\n        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n        arrayEach(['initial', 'tail'], function (methodName, index) {\n            var dropName = 'drop' + (index ? '' : 'Right');\n            LazyWrapper.prototype[methodName] = function () {\n                return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n            };\n        });\n        LazyWrapper.prototype.compact = function () {\n            return this.filter(identity);\n        };\n        LazyWrapper.prototype.find = function (predicate) {\n            return this.filter(predicate).head();\n        };\n        LazyWrapper.prototype.findLast = function (predicate) {\n            return this.reverse().find(predicate);\n        };\n        LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {\n            if (typeof path == 'function') {\n                return new LazyWrapper(this);\n            }\n            return this.map(function (value) {\n                return baseInvoke(value, path, args);\n            });\n        });\n        LazyWrapper.prototype.reject = function (predicate) {\n            return this.filter(negate(getIteratee(predicate)));\n        };\n        LazyWrapper.prototype.slice = function (start, end) {\n            start = toInteger(start);\n            var result = this;\n            if (result.__filtered__ && (start > 0 || end < 0)) {\n                return new LazyWrapper(result);\n            }\n            if (start < 0) {\n                result = result.takeRight(-start);\n            }\n            else if (start) {\n                result = result.drop(start);\n            }\n            if (end !== undefined) {\n                end = toInteger(end);\n                result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n            }\n            return result;\n        };\n        LazyWrapper.prototype.takeRightWhile = function (predicate) {\n            return this.reverse().takeWhile(predicate).reverse();\n        };\n        LazyWrapper.prototype.toArray = function () {\n            return this.take(MAX_ARRAY_LENGTH);\n        };\n        // Add `LazyWrapper` methods to `lodash.prototype`.\n        baseForOwn(LazyWrapper.prototype, function (func, methodName) {\n            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName], retUnwrapped = isTaker || /^find/.test(methodName);\n            if (!lodashFunc) {\n                return;\n            }\n            lodash.prototype[methodName] = function () {\n                var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);\n                var interceptor = function (value) {\n                    var result = lodashFunc.apply(lodash, arrayPush([value], args));\n                    return (isTaker && chainAll) ? result[0] : result;\n                };\n                if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n                    // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n                    isLazy = useLazy = false;\n                }\n                var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;\n                if (!retUnwrapped && useLazy) {\n                    value = onlyLazy ? value : new LazyWrapper(this);\n                    var result = func.apply(value, args);\n                    result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n                    return new LodashWrapper(result, chainAll);\n                }\n                if (isUnwrapped && onlyLazy) {\n                    return func.apply(this, args);\n                }\n                result = this.thru(interceptor);\n                return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n            };\n        });\n        // Add `Array` methods to `lodash.prototype`.\n        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {\n            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru', retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n            lodash.prototype[methodName] = function () {\n                var args = arguments;\n                if (retUnwrapped && !this.__chain__) {\n                    var value = this.value();\n                    return func.apply(isArray(value) ? value : [], args);\n                }\n                return this[chainName](function (value) {\n                    return func.apply(isArray(value) ? value : [], args);\n                });\n            };\n        });\n        // Map minified method names to their real names.\n        baseForOwn(LazyWrapper.prototype, function (func, methodName) {\n            var lodashFunc = lodash[methodName];\n            if (lodashFunc) {\n                var key = (lodashFunc.name + ''), names = realNames[key] || (realNames[key] = []);\n                names.push({ 'name': methodName, 'func': lodashFunc });\n            }\n        });\n        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n                'name': 'wrapper',\n                'func': undefined\n            }];\n        // Add methods to `LazyWrapper`.\n        LazyWrapper.prototype.clone = lazyClone;\n        LazyWrapper.prototype.reverse = lazyReverse;\n        LazyWrapper.prototype.value = lazyValue;\n        // Add chain sequence methods to the `lodash` wrapper.\n        lodash.prototype.at = wrapperAt;\n        lodash.prototype.chain = wrapperChain;\n        lodash.prototype.commit = wrapperCommit;\n        lodash.prototype.next = wrapperNext;\n        lodash.prototype.plant = wrapperPlant;\n        lodash.prototype.reverse = wrapperReverse;\n        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n        // Add lazy aliases.\n        lodash.prototype.first = lodash.prototype.head;\n        if (symIterator) {\n            lodash.prototype[symIterator] = wrapperToIterator;\n        }\n        return lodash;\n    });\n    /*--------------------------------------------------------------------------*/\n    // Export lodash.\n    var _ = runInContext();\n    // Some AMD build optimizers, like r.js, check for condition patterns like:\n    if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {\n        // Expose Lodash on the global object to prevent errors when Lodash is\n        // loaded by a script tag in the presence of an AMD loader.\n        // See http://requirejs.org/docs/errors.html#mismatch for more details.\n        // Use `_.noConflict` to remove Lodash from the global object.\n        root._ = _;\n        // Define as an anonymous module so, through path mapping, it can be\n        // referenced as the \"underscore\" module.\n        define(function () {\n            return _;\n        });\n    }\n    else if (freeModule) {\n        // Export for Node.js.\n        (freeModule.exports = _)._ = _;\n        // Export for CommonJS support.\n        freeExports._ = _;\n    }\n    else {\n        // Export to the global object.\n        root._ = _;\n    }\n}.call(this));\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var plugins;\n        (function (plugins) {\n            plugins.PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG = {\n                name: 'PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG',\n                displayName: 'PowerBIVisuals',\n                class: 'Visual',\n                version: '1.0.0',\n                apiVersion: '1.2.0',\n                create: function (options) { return new powerbi.extensibility.visual.PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B.Visual(options); },\n                custom: true\n            };\n        })(plugins = visuals.plugins || (visuals.plugins = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n//# sourceMappingURL=visual.js.map","css":".visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG p {\n  font-size: 20px;\n  font-weight: bold;\n  color: green;\n}\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG p em {\n  background: yellow;\n  padding: 5px;\n}\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG .axis text {\n  font: 10px sans-serif;\n}\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG .axis path,\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG .axis line {\n  fill: none;\n  stroke: #000;\n  shape-rendering: crispEdges;\n}\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG .axis .minor line {\n  stroke: #777;\n  stroke-dasharray: 2,2;\n}\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG svg {\n  height: inherit;\n  width: 100%;\n}\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG .container {\n  height: inherit;\n}\n.visual-PBI_CV_DB82D0E6_E5C1_4E34_884B_CAD22AFB245B_DEBUG .slider {\n  height: inherit;\n}\n","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2RpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo3NEY1QjA1NUQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo3NEY1QjA1NEQ0OTAxMUUwQTgxREI2NjMxMkNEMUNEMyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IFdpbmRvd3MiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5Mjk5RDU1ODBGRDRFMDExQTcxQ0JFODI3ODBCQUE5RSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBOEJGMzkxN0NBRDNFMDExQTcxQ0JFODI3ODBCQUE5RSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpDoNX0AAAI3SURBVHjarJRLSFVRFIY9t7SiRDGLoEEPCRJRaCSYkxCiFCXCF+LIMExQLkilgumgwkbdBuWDRC2EomhURCOjgagkXEgKLUKhidobM6H0+i34rxyPnuvEA5/rXPda/1l7739vJxKJxG3ls93+hEKhTILxJhgMftmsiPxdhHw4CfepeR8dCyjWwwB0kZy3iVgCoQ2ewnmXxhrBD7Cgr/ZQVA17fDRPw2UYhzK6G99IsBse6/0QNME+H8FT4EA/YiPqOgA1q4IMzBNuw6iKjkCpj+Av+AdnEEmD3bxfhzvuDk30HaEaLsEkXCO53rN+Bwg5qsvTuj/TjGYtx9nINhRmEx7AYWiFW7AXOuEcbPOUvIZ2mnrl+PkQUbNEh4QHNKUSDdsSBWEOlmxTEfvs26FL9Khe211if6Acgee+xo7xzMgBxfq9qPe3fgWBGN2lEnqtG9nExM7CV3jp3bDos2bKJB0nHFRxAxRpA/5CIXyHh5ABv6GZqd9dJ6iz2SjbxMMypGhJFtTlNzu3kK7xgDxpove8U66FK2A+s6nul5gVVMEL+Ak7lG/T+g9JcIOGar2CRUoogxMwpP/bLTJMB9bRhDbkk5bBUU0y3ES0xS04CBfN9RSHiY90vJK0BHaSzG9h2eejS3RJeVfdtrGzuGyd8CX7Yq6ExuCH63jaVMPkFOv6OibB6DKs2+VEQp+WYBoqERn2sVWWRNN0YurIfeL14U6YkpkLYCSG6e0yqdCxvKBLIm5FgAEAV0nKuwMYRUsAAAAASUVORK5CYII="}}